Index: include/clang/AST/ASTContext.h
===================================================================
--- include/clang/AST/ASTContext.h	(revision 320332)
+++ include/clang/AST/ASTContext.h	(working copy)
@@ -32,6 +32,7 @@
 #include "clang/Basic/PartialDiagnostic.h"
 #include "clang/Basic/SanitizerBlacklist.h"
 #include "clang/Basic/VersionTuple.h"
+#include "clang/Sema/PrefetchAnalysis.h"
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/FoldingSet.h"
 #include "llvm/ADT/IntrusiveRefCntPtr.h"
@@ -295,6 +296,9 @@
   /// definitions of that entity.
   llvm::DenseMap<NamedDecl*, llvm::TinyPtrVector<Module*>> MergedDefModules;
 
+  /// \brief Analysis on statements for which prefetching has been enabled.
+  mutable llvm::DenseMap<const Stmt *, PrefetchAnalysis> PrefetchAnalyses;
+
 public:
   /// \brief A type synonym for the TemplateOrInstantiation mapping.
   typedef llvm::PointerUnion<VarTemplateDecl *, MemberSpecializationInfo *>
@@ -898,6 +902,20 @@
   /// \brief Retrieve the declaration for a 128-bit float stub type.
   TypeDecl *getFloat128StubType() const;
 
+  /// \brief Add a new prefetching analysis.  Note that analysis should be done
+  /// before adding it to the context.
+  void addPrefetchAnalysis(const Stmt *S, PrefetchAnalysis &PA)
+  { PrefetchAnalyses[S] = PA; }
+
+  /// \brief Retrieve prefetching analysis for a statement if it exists, or
+  /// return a nullptr otherwise.
+  const PrefetchAnalysis *getPrefetchAnalysis(const Stmt *S) const {
+    llvm::DenseMap<const Stmt *, PrefetchAnalysis>::iterator it;
+    it = PrefetchAnalyses.find(S);
+    if(it != PrefetchAnalyses.end()) return &it->second;
+    else return nullptr;
+  }
+
   //===--------------------------------------------------------------------===//
   //                           Type Constructors
   //===--------------------------------------------------------------------===//
Index: include/clang/AST/DataRecursiveASTVisitor.h
===================================================================
--- include/clang/AST/DataRecursiveASTVisitor.h	(revision 320332)
+++ include/clang/AST/DataRecursiveASTVisitor.h	(working copy)
@@ -2663,6 +2663,14 @@
   return true;
 }
 
+template <typename Derived>
+bool RecursiveASTVisitor<Derived>::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  TRY_TO(VisitOMPClauseList(C));
+  TRY_TO(TraverseStmt(C->getStartOfRange()));
+  TRY_TO(TraverseStmt(C->getEndOfRange()));
+  return true;
+}
+
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
 // returning decls or qualtypes or nestednamespecifier -- though I'm
Index: include/clang/AST/OpenMPClause.h
===================================================================
--- include/clang/AST/OpenMPClause.h	(revision 320332)
+++ include/clang/AST/OpenMPClause.h	(working copy)
@@ -2300,6 +2300,59 @@
   }
 };
 
+/// \brief This represents a memory prefetch request for Popcorn Linux.  This
+/// should only be used for prefetching contiguous blocks of memory, e.g.,
+/// arrays or pointers to chunks of memory.
+class OMPPrefetchClause : public OMPVarListClause<OMPPrefetchClause> {
+private:
+  /// \brief What type of prefetching to perform.
+  OpenMPPrefetchClauseKind Kind;
+
+  /// \brief Expressions describing the memory range to be prefetched.
+  ///
+  /// 1. If both are nullptr, then the entire array should be prefetched
+  /// 2. If Start is valid and End is nullptr, then use the expression (which
+  ///    should be affine to a for-loop iteration variable) to prefetch the
+  ///    region of memory based on the loop iterations assigned to the thread
+  /// 3. If both Start and End are valid, then prefetch the absolute range
+  ///    denoted by the starting & ending expressions
+  Expr *Start, *End;
+
+  /// \brief Locations of the kind specifier, colons used to separate the
+  /// variable list and range expression(s).  These are valid in conjunction
+  /// with Start & End, respectively.
+  SourceLocation KindLoc, FirstColonLoc, SecondColonLoc;
+
+  OMPPrefetchClause(SourceLocation StartLoc, SourceLocation LParenLoc,
+                    SourceLocation FirstColonLoc,
+                    SourceLocation SecondColonLoc, SourceLocation EndLoc,
+                    unsigned N)
+      : OMPVarListClause<OMPPrefetchClause>(OMPC_prefetch, StartLoc, LParenLoc,
+                                            EndLoc, N),
+        FirstColonLoc(FirstColonLoc), SecondColonLoc(SecondColonLoc) {}
+public:
+  static OMPPrefetchClause *
+  Create(const ASTContext &C, OpenMPPrefetchClauseKind Kind,
+         SourceLocation KindLoc, ArrayRef<Expr *> VL, Expr *Start, Expr *End,
+         SourceLocation StartLoc, SourceLocation LParenLoc,
+         SourceLocation FirstColonLoc, SourceLocation SecondColonLoc,
+         SourceLocation EndLoc);
+
+  OpenMPPrefetchClauseKind getPrefetchKind() const { return Kind; }
+  void setPrefetchKind(OpenMPPrefetchClauseKind Kind) { this->Kind = Kind; }
+
+  Expr *getStartOfRange() const { return Start; }
+  void setStartOfRange(Expr *Start) { this->Start = Start; }
+  Expr *getEndOfRange() const { return End; }
+  void setEndOfRange(Expr *End) { this->End = End; }
+
+  SourceLocation getPrefetchKindLoc() const { return KindLoc; }
+  void setPrefetchKindLoc(SourceLocation Loc) { KindLoc = Loc; }
+  SourceLocation getFirstColonLoc() const { return FirstColonLoc; }
+  SourceLocation getSecondColonLoc() const { return SecondColonLoc; }
+
+};
+
 } // end namespace clang
 
 #endif
Index: include/clang/AST/Prefetch.h
===================================================================
--- include/clang/AST/Prefetch.h	(nonexistent)
+++ include/clang/AST/Prefetch.h	(working copy)
@@ -0,0 +1,38 @@
+//===--- Prefetch.h - Prefetching classes for Popcorn Linux -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines classes for enabling prefetching analysis & instrumentation
+// on Popcorn Linux.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_AST_PREFETCH_H
+#define LLVM_CLANG_AST_PREFETCH_H
+
+namespace clang {
+
+/// Statements for which prefetching analysis & instrumentation can be performed
+/// should inherit this class.
+class Prefetchable {
+protected:
+  /// \brief Whether prefetching has been enabled for the statement.
+  bool PrefetchEnabled;
+
+public:
+  Prefetchable(bool PrefetchEnabled = false)
+    : PrefetchEnabled(PrefetchEnabled) {}
+
+  void setPrefetchEnabled(bool Enable) { PrefetchEnabled = Enable; }
+  bool prefetchEnabled() const { return PrefetchEnabled; }
+};
+
+} // end namespace clang
+
+#endif
+
Index: include/clang/AST/RecursiveASTVisitor.h
===================================================================
--- include/clang/AST/RecursiveASTVisitor.h	(revision 320332)
+++ include/clang/AST/RecursiveASTVisitor.h	(working copy)
@@ -2695,6 +2695,14 @@
   return true;
 }
 
+template <typename Derived>
+bool RecursiveASTVisitor<Derived>::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  TRY_TO(VisitOMPClauseList(C));
+  TRY_TO(TraverseStmt(C->getStartOfRange()));
+  TRY_TO(TraverseStmt(C->getEndOfRange()));
+  return true;
+}
+
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
 // returning decls or qualtypes or nestednamespecifier -- though I'm
Index: include/clang/AST/Stmt.h
===================================================================
--- include/clang/AST/Stmt.h	(revision 320332)
+++ include/clang/AST/Stmt.h	(working copy)
@@ -16,6 +16,7 @@
 
 #include "clang/AST/DeclGroup.h"
 #include "clang/AST/StmtIterator.h"
+#include "clang/AST/Prefetch.h"
 #include "clang/Basic/CapturedStmt.h"
 #include "clang/Basic/IdentifierTable.h"
 #include "clang/Basic/LLVM.h"
@@ -1141,7 +1142,7 @@
 /// the init/cond/inc parts of the ForStmt will be null if they were not
 /// specified in the source.
 ///
-class ForStmt : public Stmt {
+class ForStmt : public Stmt, public Prefetchable {
   SourceLocation ForLoc;
   enum { INIT, CONDVAR, COND, INC, BODY, END_EXPR };
   Stmt* SubExprs[END_EXPR]; // SubExprs[INIT] is an expression or declstmt.
@@ -2069,6 +2070,12 @@
   /// \brief The record for captured variables, a RecordDecl or CXXRecordDecl.
   RecordDecl *TheRecordDecl;
 
+  /// \brief For captured OpenMP parallel regions, variables declared in the
+  /// shared clause may be stored on the main thread's stack.  This causes
+  /// false sharing in Popcorn's distributed execution.  If set, offload shared
+  /// variables to global memory for the capture.
+  bool OffloadShared;
+
   /// \brief Construct a captured statement.
   CapturedStmt(Stmt *S, CapturedRegionKind Kind, ArrayRef<Capture> Captures,
                ArrayRef<Expr *> CaptureInits, CapturedDecl *CD, RecordDecl *RD);
@@ -2134,6 +2141,10 @@
   /// \brief True if this variable has been captured.
   bool capturesVariable(const VarDecl *Var) const;
 
+  /// \brief Getters/setters for the offloading shared variables flag
+  bool offloadShared() const { return OffloadShared; }
+  void setOffloadShared(bool OS) { OffloadShared = OS; }
+
   /// \brief An iterator that walks over the captures.
   typedef Capture *capture_iterator;
   typedef const Capture *const_capture_iterator;
Index: include/clang/AST/StmtOpenMP.h
===================================================================
--- include/clang/AST/StmtOpenMP.h	(revision 320332)
+++ include/clang/AST/StmtOpenMP.h	(working copy)
@@ -42,6 +42,8 @@
   const unsigned NumClauses;
   /// \brief Number of child expressions/stmts.
   const unsigned NumChildren;
+  /// \brief Enable prefetching code generation for Popcorn Linux
+  bool Prefetch;
   /// \brief Offset from this to the start of clauses.
   /// There are NumClauses pointers to clauses, they are followed by
   /// NumChildren pointers to child stmts/exprs (if the directive type
@@ -69,7 +71,7 @@
                          unsigned NumClauses, unsigned NumChildren)
       : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),
         EndLoc(std::move(EndLoc)), NumClauses(NumClauses),
-        NumChildren(NumChildren),
+        NumChildren(NumChildren), Prefetch(false),
         ClausesOffset(llvm::RoundUpToAlignment(sizeof(T),
                                                llvm::alignOf<OMPClause *>())) {}
 
@@ -205,6 +207,9 @@
   ArrayRef<OMPClause *> clauses() const {
     return const_cast<OMPExecutableDirective *>(this)->getClauses();
   }
+
+  bool prefetchingEnabled() const { return Prefetch; }
+  void setPrefetching(bool Prefetch) { this->Prefetch = Prefetch; }
 };
 
 /// \brief This represents '#pragma omp parallel' directive.
Index: include/clang/Basic/DiagnosticParseKinds.td
===================================================================
--- include/clang/Basic/DiagnosticParseKinds.td	(revision 320332)
+++ include/clang/Basic/DiagnosticParseKinds.td	(working copy)
@@ -993,6 +993,14 @@
   "'#pragma omp %0' cannot be an immediate substatement">;
 def err_omp_expected_identifier_for_critical : Error<
   "expected identifier specifying the name of the 'omp critical' directive">;
+def err_omp_invalid_prefetch_kind : Error<
+  "invalid argument; expected 'read' or 'write'">;
+// TODO Technically these are semantics issues, but we're doing checking in the
+// parser for this particular clause
+def err_omp_invalid_prefetch_capture : Error<
+  "can only prefetch variables used in the loop body">;
+def err_omp_invalid_prefetch_loop_var : Error<
+  "can only prefetch loop iteration range using a loop iteration variable">;
 
 // Pragma loop support.
 def err_pragma_loop_missing_argument : Error<
@@ -1008,6 +1016,22 @@
 def warn_pragma_unroll_cuda_value_in_parens : Warning<
   "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++">,
   InGroup<CudaCompat>;
+
+// Pragma popcorn support.
+def warn_pragma_popcorn_ignored : Warning<
+  "Popcorn: unexpected '#pragma popcorn...' in program">, DefaultIgnore;
+def warn_pragma_popcorn_no_arg : Warning<
+  "Popcorn: missing argument; expected 'prefetch'">;
+def warn_pragma_popcorn_invalid_option : Warning<
+  "Popcorn: invalid pragma argument '%0'; expected 'prefetch'">;
+def err_pragma_popcorn_invalid_clause : Error<
+  "Popcorn: invalid clause '%0'; expected 'ignore'">;
+def err_pragma_popcorn_expected_var_name : Error<
+  "Popcorn: expected variable name">;
+
+// Pragma popcorn prefetch support.
+def warn_pragma_popcorn_prefetch_invalid_stmt : Warning<
+  "Popcorn: cannot prefetch for this statement">;
 } // end of Parse Issue category.
 
 let CategoryName = "Modules Issue" in {
Index: include/clang/Basic/DiagnosticSemaKinds.td
===================================================================
--- include/clang/Basic/DiagnosticSemaKinds.td	(revision 320332)
+++ include/clang/Basic/DiagnosticSemaKinds.td	(working copy)
@@ -7649,6 +7649,10 @@
   "parent region for 'omp %select{cancellation point/cancel}0' construct cannot be nowait">;
 def err_omp_parent_cancel_region_ordered : Error<
   "parent region for 'omp %select{cancellation point/cancel}0' construct cannot be ordered">;
+def err_omp_invalid_prefetch_var_type : Error<
+  "invalid variable type; must be %0 type">;
+def err_omp_invalid_prefetch_range_type : Error<
+  "invalid range specifier type; must be of integer (signed or unsigned) type">;
 } // end of OpenMP category
 
 let CategoryName = "Related Result Type Issue" in {
Index: include/clang/Basic/LangOptions.def
===================================================================
--- include/clang/Basic/LangOptions.def	(revision 320332)
+++ include/clang/Basic/LangOptions.def	(working copy)
@@ -230,6 +230,9 @@
                                            "field padding (0: none, 1:least "
                                            "aggressive, 2: more aggressive)")
 
+// Optimize OpenMP code generation for distributed execution on Popcorn Linux
+BENIGN_LANGOPT(DistributedOmp, 1, 0, "Optimize OpenMP for distributed execution")
+
 #undef LANGOPT
 #undef COMPATIBLE_LANGOPT
 #undef BENIGN_LANGOPT
Index: include/clang/Basic/OpenMPKinds.def
===================================================================
--- include/clang/Basic/OpenMPKinds.def	(revision 320332)
+++ include/clang/Basic/OpenMPKinds.def	(working copy)
@@ -72,6 +72,9 @@
 #ifndef OPENMP_DEPEND_KIND
 #define OPENMP_DEPEND_KIND(Name)
 #endif
+#ifndef OPENMP_PREFETCH_KIND
+#define OPENMP_PREFETCH_KIND(Name)
+#endif
 
 // OpenMP directives.
 OPENMP_DIRECTIVE(threadprivate)
@@ -129,6 +132,7 @@
 OPENMP_CLAUSE(capture, OMPCaptureClause)
 OPENMP_CLAUSE(seq_cst, OMPSeqCstClause)
 OPENMP_CLAUSE(depend, OMPDependClause)
+OPENMP_CLAUSE(prefetch, OMPPrefetchClause)
 
 // Clauses allowed for OpenMP directive 'parallel'.
 OPENMP_PARALLEL_CLAUSE(if)
@@ -159,6 +163,7 @@
 OPENMP_FOR_CLAUSE(schedule)
 OPENMP_FOR_CLAUSE(ordered)
 OPENMP_FOR_CLAUSE(nowait)
+OPENMP_FOR_CLAUSE(prefetch)
 
 // Clauses allowed for directive 'omp for simd'.
 OPENMP_FOR_SIMD_CLAUSE(private)
@@ -171,6 +176,7 @@
 OPENMP_FOR_SIMD_CLAUSE(safelen)
 OPENMP_FOR_SIMD_CLAUSE(linear)
 OPENMP_FOR_SIMD_CLAUSE(aligned)
+OPENMP_FOR_SIMD_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'omp sections'.
 OPENMP_SECTIONS_CLAUSE(private)
@@ -206,6 +212,10 @@
 OPENMP_DEPEND_KIND(out)
 OPENMP_DEPEND_KIND(inout)
 
+// Static attributes for 'prefetch' clause.
+OPENMP_PREFETCH_KIND(read)
+OPENMP_PREFETCH_KIND(write)
+
 // Clauses allowed for OpenMP directive 'parallel for'.
 OPENMP_PARALLEL_FOR_CLAUSE(if)
 OPENMP_PARALLEL_FOR_CLAUSE(num_threads)
@@ -220,6 +230,7 @@
 OPENMP_PARALLEL_FOR_CLAUSE(collapse)
 OPENMP_PARALLEL_FOR_CLAUSE(schedule)
 OPENMP_PARALLEL_FOR_CLAUSE(ordered)
+OPENMP_PARALLEL_FOR_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'parallel for simd'.
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(if)
@@ -237,6 +248,7 @@
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(safelen)
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(linear)
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(aligned)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'parallel sections'.
 OPENMP_PARALLEL_SECTIONS_CLAUSE(if)
@@ -280,6 +292,7 @@
 OPENMP_TEAMS_CLAUSE(shared)
 OPENMP_TEAMS_CLAUSE(reduction)
 
+#undef OPENMP_PREFETCH_KIND
 #undef OPENMP_DEPEND_KIND
 #undef OPENMP_SCHEDULE_KIND
 #undef OPENMP_PROC_BIND_KIND
Index: include/clang/Basic/OpenMPKinds.h
===================================================================
--- include/clang/Basic/OpenMPKinds.h	(revision 320332)
+++ include/clang/Basic/OpenMPKinds.h	(working copy)
@@ -70,6 +70,14 @@
   OMPC_DEPEND_unknown
 };
 
+/// \brief OpenMP attributes for 'prefetch' clause.
+enum OpenMPPrefetchClauseKind {
+#define OPENMP_PREFETCH_KIND(Name) \
+  OMPC_PREFETCH_##Name,
+#include "clang/Basic/OpenMPKinds.def"
+  OMPC_PREFETCH_unknown
+};
+
 OpenMPDirectiveKind getOpenMPDirectiveKind(llvm::StringRef Str);
 const char *getOpenMPDirectiveName(OpenMPDirectiveKind Kind);
 
Index: include/clang/Basic/TokenKinds.def
===================================================================
--- include/clang/Basic/TokenKinds.def	(revision 320332)
+++ include/clang/Basic/TokenKinds.def	(working copy)
@@ -752,6 +752,12 @@
 ANNOTATION(module_begin)
 ANNOTATION(module_end)
 
+// Annotations for Popcorn Linux - #pragma popcorn ...
+// The lexer produces these so that they only take effect when the parser
+// handles #pragma popcorn ... directives.
+ANNOTATION(pragma_popcorn_prefetch)
+ANNOTATION(pragma_popcorn_prefetch_end)
+
 #undef ANNOTATION
 #undef TESTING_KEYWORD
 #undef OBJC2_AT_KEYWORD
Index: include/clang/CodeGen/BackendUtil.h
===================================================================
--- include/clang/CodeGen/BackendUtil.h	(revision 320332)
+++ include/clang/CodeGen/BackendUtil.h	(working copy)
@@ -28,13 +28,32 @@
     Backend_EmitLL,        ///< Emit human-readable LLVM assembly
     Backend_EmitNothing,   ///< Don't emit anything (benchmarking mode)
     Backend_EmitMCNull,    ///< Run CodeGen, but don't emit anything
-    Backend_EmitObj        ///< Emit native object files
+    Backend_EmitObj,       ///< Emit native object files
+    Backend_EmitMultiObj   ///< Emit native object files for multiple ISAs
   };
 
+  /// Run both IR optimization passes and backend passes to generate code
   void EmitBackendOutput(DiagnosticsEngine &Diags, const CodeGenOptions &CGOpts,
                          const TargetOptions &TOpts, const LangOptions &LOpts,
                          StringRef TDesc, llvm::Module *M, BackendAction Action,
                          raw_pwrite_stream *OS);
+
+  /// Run IR optimization passes
+  void ApplyIROptimizations(DiagnosticsEngine &Diags,
+                            const CodeGenOptions &CGOpts,
+                            const TargetOptions &TOpts,
+                            const LangOptions &LOpts,
+                            llvm::Module *M, BackendAction Action,
+                            raw_pwrite_stream *OS);
+
+  /// Run backend code-generation passes
+  void CodegenBackendOutput(DiagnosticsEngine &Diags,
+                            const CodeGenOptions &CGOpts,
+                            const TargetOptions &TOpts,
+                            const LangOptions &LOpts,
+                            StringRef TDesc, llvm::Module *M,
+                            BackendAction Action,
+                            raw_pwrite_stream *OS);
 }
 
 #endif
Index: include/clang/CodeGen/CodeGenAction.h
===================================================================
--- include/clang/CodeGen/CodeGenAction.h	(revision 320332)
+++ include/clang/CodeGen/CodeGenAction.h	(working copy)
@@ -11,6 +11,7 @@
 #define LLVM_CLANG_CODEGEN_CODEGENACTION_H
 
 #include "clang/Frontend/FrontendAction.h"
+#include "clang/CodeGen/BackendUtil.h"
 #include <memory>
 
 namespace llvm {
@@ -20,9 +21,10 @@
 
 namespace clang {
 class BackendConsumer;
+class CoverageSourceInfo;
 
 class CodeGenAction : public ASTFrontendAction {
-private:
+protected:
   unsigned Act;
   std::unique_ptr<llvm::Module> TheModule;
   llvm::Module *LinkModule;
@@ -29,7 +31,6 @@
   llvm::LLVMContext *VMContext;
   bool OwnsVMContext;
 
-protected:
   /// Create a new code generation action.  If the optional \p _VMContext
   /// parameter is supplied, the action uses it without taking ownership,
   /// otherwise it creates a fresh LLVM context and takes ownership.
@@ -37,6 +38,14 @@
 
   bool hasIRSupport() const override;
 
+  /// Helpers called in CreateASTConsumer
+  llvm::Module *getLinkModuleToUse(CompilerInstance &CI);
+  CoverageSourceInfo *getCoverageInfo(CompilerInstance &CI);
+
+  /// Helper called in ExecuteAction.  Returns true if the compilation is
+  /// invalid and should therefore be aborted.
+  bool ExecuteActionIRCommon(BackendAction &BA, CompilerInstance &CI);
+
   std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
                                                  StringRef InFile) override;
 
@@ -98,6 +107,23 @@
   EmitObjAction(llvm::LLVMContext *_VMContext = nullptr);
 };
 
+/// Emit multiple object files using a single set of IR.  Used by the Popcorn
+/// Linux compiler toolchain.
+class EmitMultiObjAction : public CodeGenAction {
+  virtual void anchor();
+  SmallVector<std::string, 2> Targets;
+  SmallVector<raw_pwrite_stream *, 2> OutFiles;
+  SmallVector<std::shared_ptr<TargetOptions>, 2> TargetOpts;
+  SmallVector<TargetInfo *, 2> TargetInfos;
+protected:
+  bool InitializeTargets(CompilerInstance &CI, StringRef InFile);
+  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
+                                                 StringRef InFile) override;
+  void ExecuteAction() override;
+public:
+  EmitMultiObjAction(llvm::LLVMContext *_VMContext = nullptr);
+};
+
 }
 
 #endif
Index: include/clang/CodeGen/PopcornUtil.h
===================================================================
--- include/clang/CodeGen/PopcornUtil.h	(nonexistent)
+++ include/clang/CodeGen/PopcornUtil.h	(working copy)
@@ -0,0 +1,47 @@
+//===--- PopcornUtil.h - Popcorn Linux Utilities ----------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_CODEGEN_POPCORNUTIL_H
+#define LLVM_CLANG_CODEGEN_POPCORNUTIL_H
+
+#include <llvm/ADT/StringRef.h>
+#include <llvm/IR/Module.h>
+#include <clang/Basic/TargetOptions.h>
+#include <memory>
+
+namespace clang {
+namespace Popcorn {
+
+/// Return whether a given target is supported by the compiler.
+bool SupportedTarget(const llvm::StringRef Target);
+
+/// Populate an array with all targets currently supported by the Popcorn
+/// compiler.
+void GetAllTargets(llvm::SmallVector<std::string, 2> &Targets);
+
+/// Return a TargetOptions with features appropriate for Popcorn Linux
+std::shared_ptr<TargetOptions>
+GetPopcornTargetOpts(const llvm::StringRef TripleStr);
+
+/// Strip target-specific CPUs & features from function attributes in all
+/// functions in the module.  This silences warnings from the compiler about
+/// unsupported target features when compiling the IR for multiple
+/// architectures.
+void StripTargetAttributes(llvm::Module &M);
+
+
+/// Add the target-features attribute specified in TargetOpts to every function
+/// in module M.
+void AddArchSpecificTargetFeatures(llvm::Module &M,
+                                   std::shared_ptr<TargetOptions> TargetOpts);
+
+} /* end Popcorn namespace */
+} /* end clang namespace */
+
+#endif
Index: include/clang/CodeGen/PrefetchBuilder.h
===================================================================
--- include/clang/CodeGen/PrefetchBuilder.h	(nonexistent)
+++ include/clang/CodeGen/PrefetchBuilder.h	(working copy)
@@ -0,0 +1,55 @@
+//===- Prefetch.h - Prefetching Analysis for Statements -----------*- C++ --*-//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interface for building prefetching calls based on the
+// prefetching analysis.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_CODEGEN_PREFETCHBUILDER_H
+#define LLVM_CLANG_CODEGEN_PREFETCHBUILDER_H
+
+#include "CodeGenFunction.h"
+#include "clang/Sema/PrefetchAnalysis.h"
+#include "llvm/Support/raw_ostream.h"
+
+namespace clang {
+
+/// Generate calls to the prefetching API for analyzed regions.
+class PrefetchBuilder {
+public:
+  PrefetchBuilder(clang::CodeGen::CodeGenFunction *CGF)
+    : CGM(CGF->CGM), CGF(*CGF), Ctx(CGF->getContext()) {}
+
+  /// Emit prefetching API declarations.
+  void EmitPrefetchCallDeclarations();
+
+  /// Emit a prefetch call for a particular range of memory.
+  void EmitPrefetchCall(const PrefetchRange &P);
+
+  /// Emit a call to send the prefetch requests to the OS.
+  void EmitPrefetchExecuteCall();
+
+  // TODO print & dump
+
+private:
+  clang::CodeGen::CodeGenModule &CGM;
+  clang::CodeGen::CodeGenFunction &CGF;
+  ASTContext &Ctx;
+
+  // Prefetch API declarations
+  llvm::Constant *Prefetch, *Execute;
+
+  Expr *buildArrayIndexAddress(VarDecl *Base, Expr *Subscript);
+};
+
+} // end namespace clang
+
+#endif
+
Index: include/clang/Driver/Options.td
===================================================================
--- include/clang/Driver/Options.td	(revision 320332)
+++ include/clang/Driver/Options.td	(working copy)
@@ -83,6 +83,8 @@
 def m_libc_Group          : OptionGroup<"<m libc group>">, Group<m_Group>;
 def u_Group               : OptionGroup<"<u group>">;
 
+def Popcorn_Target_Group  : OptionGroup<"<Popcorn target group>">, Group<CompileOnly_Group>;
+
 def pedantic_Group        : OptionGroup<"<pedantic group>">,
   Group<CompileOnly_Group>;
 def reserved_lib_Group   : OptionGroup<"<reserved libs group>">;
@@ -1538,6 +1540,12 @@
 def pg : Flag<["-"], "pg">, HelpText<"Enable mcount instrumentation">, Flags<[CC1Option]>;
 def pipe : Flag<["-", "--"], "pipe">,
   HelpText<"Use pipes between commands, when possible">;
+def popcorn_migratable : Flag<["-"], "popcorn-migratable">, HelpText<"Instrument code to be migratable on Popcorn Linux (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_metadata : Flag<["-"], "popcorn-metadata">, HelpText<"Generate stack transformation metadata without inserting migration points (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_libc : Flag<["-"], "popcorn-libc">, HelpText<"Compile libc code with appropriate instrumentation for migration (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_alignment : Flag<["-"], "popcorn-alignment">, HelpText<"Run Popcorn passes to prepare for link-time symbol alignment">, Flags<[CC1Option]>;
+def popcorn_target : Joined<["-"], "popcorn-target=">, HelpText<"Targets for which to generate object files (requires -popcorn-migratable)">, Group<Popcorn_Target_Group>, Flags<[CC1Option]>, MetaVarName<"<target>">;
+def distributed_omp : Flag<["-"], "distributed-omp">, HelpText<"Optimize OpenMP code generation for distributed execution on Popcorn Linux">, Flags<[CC1Option]>;
 def prebind__all__twolevel__modules : Flag<["-"], "prebind_all_twolevel_modules">;
 def prebind : Flag<["-"], "prebind">;
 def preload : Flag<["-"], "preload">;
Index: include/clang/Frontend/CodeGenOptions.def
===================================================================
--- include/clang/Frontend/CodeGenOptions.def	(revision 320332)
+++ include/clang/Frontend/CodeGenOptions.def	(working copy)
@@ -158,6 +158,12 @@
 
 CODEGENOPT(EmitLLVMUseLists, 1, 0) ///< Control whether to serialize use-lists.
 
+/// Select places inside functions to instrument with migration points
+CODEGENOPT(PopcornMigratable, 1, 0)
+
+/// Adjust linkage of global values for symbol alignment
+CODEGENOPT(PopcornAlignment, 1, 0)
+
 /// The user specified number of registers to be used for integral arguments,
 /// or 0 if unspecified.
 VALUE_CODEGENOPT(NumRegisterParameters, 32, 0)
Index: include/clang/Frontend/CodeGenOptions.h
===================================================================
--- include/clang/Frontend/CodeGenOptions.h	(revision 320332)
+++ include/clang/Frontend/CodeGenOptions.h	(working copy)
@@ -201,6 +201,9 @@
   /// Set of sanitizer checks that trap rather than diagnose.
   SanitizerSet SanitizeTrap;
 
+  /// Targets for which to emit object code
+  std::vector<std::string> PopcornTargets;
+
 public:
   // Define accessors/mutators for code generation options of enumeration type.
 #define CODEGENOPT(Name, Bits, Default)
Index: include/clang/Frontend/CompilerInstance.h
===================================================================
--- include/clang/Frontend/CompilerInstance.h	(revision 320332)
+++ include/clang/Frontend/CompilerInstance.h	(working copy)
@@ -260,6 +260,13 @@
     return Invocation->getCodeGenOpts();
   }
 
+  CodeGenOptions &getCodeGenNoOpts() {
+    return Invocation->getCodeGenNoOpts();
+  }
+  const CodeGenOptions &getCodeGenNoOpts() const {
+    return Invocation->getCodeGenNoOpts();
+  }
+
   DependencyOutputOptions &getDependencyOutputOpts() {
     return Invocation->getDependencyOutputOpts();
   }
Index: include/clang/Frontend/CompilerInvocation.h
===================================================================
--- include/clang/Frontend/CompilerInvocation.h	(revision 320332)
+++ include/clang/Frontend/CompilerInvocation.h	(working copy)
@@ -108,6 +108,9 @@
   /// Options controlling IRgen and the backend.
   CodeGenOptions CodeGenOpts;
 
+  /// Options controlling IRgen and the backend (with optimization disabled).
+  CodeGenOptions CodeGenOptsNoOpt;
+
   /// Options controlling dependency output.
   DependencyOutputOptions DependencyOutputOpts;
 
@@ -179,6 +182,11 @@
     return CodeGenOpts;
   }
 
+  CodeGenOptions &getCodeGenNoOpts() { return CodeGenOptsNoOpt; }
+  const CodeGenOptions &getCodeGenNoOpts() const {
+    return CodeGenOptsNoOpt;
+  }
+
   DependencyOutputOptions &getDependencyOutputOpts() {
     return DependencyOutputOpts;
   }
Index: include/clang/Frontend/FrontendOptions.h
===================================================================
--- include/clang/Frontend/FrontendOptions.h	(revision 320332)
+++ include/clang/Frontend/FrontendOptions.h	(working copy)
@@ -37,6 +37,7 @@
     EmitLLVMOnly,           ///< Generate LLVM IR, but do not emit anything.
     EmitCodeGenOnly,        ///< Generate machine code, but don't emit anything.
     EmitObj,                ///< Emit a .o file.
+    EmitMultiObj,           ///< Emit a .o file for multiple ISAs.
     FixIt,                  ///< Parse and apply any fixits to the source.
     GenerateModule,         ///< Generate pre-compiled module.
     GeneratePCH,            ///< Generate pre-compiled header.
Index: include/clang/Parse/Parser.h
===================================================================
--- include/clang/Parse/Parser.h	(revision 320332)
+++ include/clang/Parse/Parser.h	(working copy)
@@ -167,6 +167,7 @@
   std::unique_ptr<PragmaHandler> LoopHintHandler;
   std::unique_ptr<PragmaHandler> UnrollHintHandler;
   std::unique_ptr<PragmaHandler> NoUnrollHintHandler;
+  std::unique_ptr<PragmaHandler> PopcornHandler;
 
   std::unique_ptr<CommentHandler> CommentSemaHandler;
 
@@ -528,6 +529,13 @@
   /// #pragma clang loop and #pragma unroll.
   bool HandlePragmaLoopHint(LoopHint &Hint);
 
+  /// \brief Handle the annotation token produced for
+  /// #pragma popcorn...
+  StmtResult HandlePragmaPopcorn();
+
+  /// \brief Parse a comma-separated variable list
+  void ParseVarList(llvm::SmallPtrSet<VarDecl *, 4> &Vars);
+
   /// GetLookAheadToken - This peeks ahead N tokens and returns that token
   /// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)
   /// returns the token after Tok, etc.
@@ -2418,6 +2426,10 @@
 
   //===--------------------------------------------------------------------===//
   // OpenMP: Directives and clauses.
+  /// \brief Checks 'prefetch' clauses for correctness.  Note that we can only
+  /// perform some semantic checks *after* the entire compound statement
+  /// representing the directive's body has been parsed.
+  void CheckOpenMPPrefetchClauses(StmtResult Directive);
   /// \brief Parses declarative OpenMP directives.
   DeclGroupPtrTy ParseOpenMPDeclarativeDirective();
   /// \brief Parses simple list of variables.
Index: include/clang/Sema/PrefetchAnalysis.h
===================================================================
--- include/clang/Sema/PrefetchAnalysis.h	(nonexistent)
+++ include/clang/Sema/PrefetchAnalysis.h	(working copy)
@@ -0,0 +1,132 @@
+//===- PrefetchAnalysis.h - Prefetching Analysis for Statements ---*- C++ --*-//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interface for prefetching analysis over structured
+// blocks.  The analysis traverses the AST to determine how arrays are accessed
+// in structured blocks and generates expressions defining ranges of elements
+// accessed inside arrays.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_AST_PREFETCHANALYSIS_H
+#define LLVM_CLANG_AST_PREFETCHANALYSIS_H
+
+#include "clang/AST/Decl.h"
+#include "clang/AST/Expr.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/Support/raw_ostream.h"
+#include <memory>
+
+namespace clang {
+
+class ASTContext;
+
+/// A range of memory to be prefetched.
+class PrefetchRange {
+public:
+  /// Access type for array.  Sorted in increasing importance.
+  enum Type { Read, Write };
+
+  PrefetchRange(enum Type Ty, VarDecl *Array, Expr *Start, Expr *End)
+    : Ty(Ty), Array(Array), Start(Start), End(End) {}
+
+  enum Type getType() const { return Ty; }
+  VarDecl *getArray() const { return Array; }
+  Expr *getStart() const { return Start; }
+  Expr *getEnd() const { return End; }
+  void setType(enum Type Ty) { this->Ty = Ty; }
+  void setArray(VarDecl *Array) { this->Array = Array; }
+  void setStart(Expr *Start) { this->Start = Start; }
+  void setEnd(Expr *Start) { this->End = End; }
+
+  /// Return true if the other prefetch range is equal to this one (ignoring
+  /// prefetch type differences), or false otherwise.
+  bool equalExceptType(const PrefetchRange &RHS);
+
+  /// Return true if the other prefetch range is equal to this one, or false
+  /// otherwise.
+  bool operator==(const PrefetchRange &RHS);
+
+  // TODO print & dump
+  const char *getTypeName() const {
+    switch(Ty) {
+    case Read: return "read";
+    case Write: return "write";
+    default: return "unknown";
+    }
+  }
+
+private:
+  enum Type Ty;
+  VarDecl *Array;
+  Expr *Start, *End;
+};
+
+class PrefetchAnalysis {
+public:
+  /// Default constructor, really only defined to enable storage in a DenseMap.
+  PrefetchAnalysis() : Ctx(nullptr), S(nullptr) {}
+
+  /// Construct a new prefetch analysis object to analyze a statement.  Doesn't
+  /// run the analysis.
+  PrefetchAnalysis(ASTContext *Ctx, Stmt *S) : Ctx(Ctx), S(S) {}
+
+  /// Ignore a set of variables during access analysis.  In other words, ignore
+  /// memory accesses which use these variables as their base.
+  void ignoreVars(const llvm::SmallPtrSet<VarDecl *, 4> &Ignore)
+  { this->Ignore = Ignore; }
+
+  /// Analyze the statement.
+  void analyzeStmt();
+
+  /// Get prefetch ranges discovered by analysis.
+  const SmallVector<PrefetchRange, 8> &getArraysToPrefetch() const
+  { return ToPrefetch; }
+
+  /// Return true if the QualType is both scalar and of integer type, or false
+  /// otherwise.
+  static bool isScalarIntType(const QualType &Ty);
+
+  /// Return the size in bits of a builtin integer type, or UINT32_MAX if not a
+  /// builtin integer type.
+  static unsigned getTypeSize(BuiltinType::Kind K);
+
+  /// Cast the value declaration to a variable declaration if it is a varaible
+  /// of scalar integer type.
+  static VarDecl *getVarIfScalarInt(ValueDecl *VD);
+
+  void print(llvm::raw_ostream &O) const;
+  void dump() const { print(llvm::errs()); }
+
+private:
+  ASTContext *Ctx;
+  Stmt *S;
+
+  /// Variables (i.e., arrays) to ignore during analysis
+  llvm::SmallPtrSet<VarDecl *, 4> Ignore;
+
+  /// The good stuff -- ranges of memory to prefetch
+  llvm::SmallVector<PrefetchRange, 8> ToPrefetch;
+
+  /// Analyze individual types of statements.
+  void analyzeForStmt();
+
+  /// Clean up prefetch analysis by merging overlapping or duplicate accesses.
+  void mergeArrayAccesses();
+
+  /// Remove trivial or redundant array accesses.
+  void pruneArrayAccesses();
+};
+
+} // end namespace clang
+
+#endif
+
Index: include/clang/Sema/PrefetchDataflow.h
===================================================================
--- include/clang/Sema/PrefetchDataflow.h	(nonexistent)
+++ include/clang/Sema/PrefetchDataflow.h	(working copy)
@@ -0,0 +1,84 @@
+//=- PrefetchDataflow.cpp - Dataflow analysis for prefetching ------------*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the dataflow of expressions as required for prefetching
+// analysis.  This is required to correctly discover how variables are used in
+// memory accesses in order to construct memory access ranges.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _AST_PREFETCHDATAFLOW_H
+#define _AST_PREFETCHDATAFLOW_H
+
+#include "clang/Analysis/CFG.h"
+#include "clang/Analysis/CFGStmtMap.h"
+#include "clang/AST/ParentMap.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/SmallPtrSet.h"
+#include <memory>
+
+namespace clang {
+
+/// Data structures for containing symbolic execution values.
+typedef llvm::SmallPtrSet<Expr *, 1> ExprList;
+typedef llvm::DenseMap<const VarDecl *, ExprList> SymbolicValueMap;
+typedef std::pair<const VarDecl *, ExprList> SymbolicValuePair;
+typedef llvm::SmallPtrSet<const CFGBlock *, 32> CFGBlockSet;
+
+/// Class which runs dataflow analysis over the specified statement.  Tracks
+/// the value of a given set of variables as they change throughout the
+/// statement.
+class PrefetchDataflow {
+public:
+  typedef llvm::SmallPtrSet<const VarDecl *, 8> VarSet;
+
+  /// A lot of boilerplate so we can embed analysis into data structures like
+  /// llvm::DenseMap.  Required because objects use std::unique_ptrs.
+  PrefetchDataflow();
+  PrefetchDataflow(ASTContext *Ctx);
+
+  /// Copy constructor -- only copies the AST.
+  PrefetchDataflow(const PrefetchDataflow &RHS);
+
+  /// Assignment operator -- only copies the AST.
+  PrefetchDataflow &operator=(const PrefetchDataflow &RHS);
+
+  /// Run dataflow analysis over the statement specified at build time.
+  void runDataflow(Stmt *S, VarSet &VarsToTrack);
+
+  /// Get possible values of a variable at a specific use in a statement, if
+  /// any.  The list argument will be populated with expressions.
+  void getVariableValues(VarDecl *Var, const Stmt *Use, ExprList &Exprs) const;
+
+  /// Reset any previous analysis.
+  void reset();
+
+  void print(llvm::raw_ostream &O) const;
+  void dump() const;
+
+private:
+  ASTContext *Ctx;
+  Stmt *S;
+
+  /// Data used in analysis/retrieving results
+  std::unique_ptr<CFG> TheCFG;
+  std::unique_ptr<ParentMap> PMap;
+  std::unique_ptr<CFGStmtMap> StmtToBlock;
+
+  /// Analysis results -- keep an expression used to calculate a variable's
+  /// value for each control flow block.
+  typedef std::pair<const CFGBlock *, SymbolicValueMap> BlockValuesPair;
+  typedef llvm::DenseMap<const CFGBlock *, SymbolicValueMap> BlockValuesMap;
+  BlockValuesMap VarValues;
+};
+
+}
+
+#endif
+
Index: include/clang/Sema/PrefetchExprBuilder.h
===================================================================
--- include/clang/Sema/PrefetchExprBuilder.h	(nonexistent)
+++ include/clang/Sema/PrefetchExprBuilder.h	(working copy)
@@ -0,0 +1,99 @@
+//===- PrefetchExprBuilder.h - Prefetching expression builder -----*- C++ --*-//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines a set of utilities for building expressions for
+// prefetching.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_AST_PREFETCHEXPRBUILDER_H
+#define LLVM_CLANG_AST_PREFETCHEXPRBUILDER_H
+
+#include "clang/AST/Decl.h"
+#include "clang/AST/Expr.h"
+#include "llvm/ADT/DenseMap.h"
+
+namespace clang {
+
+class ASTContext;
+
+typedef std::pair<VarDecl *, Expr *> ReplacePair;
+typedef llvm::DenseMap<VarDecl *, Expr *> ReplaceMap;
+
+/// Utilities for compairing expressions by value.
+namespace PrefetchExprEquality {
+
+/// Compare two expressions by value to see if they're equal.
+bool exprEqual(const Expr *A, const Expr *B);
+
+}
+
+/// Utilities for building expressions.
+namespace PrefetchExprBuilder {
+
+/// Information describing how a statement should be modified.
+struct Modifier {
+  enum Type { Add, Sub, Mul, Div, None, Unknown };
+  void ClassifyModifier(const Expr *E, const ASTContext *Ctx);
+  enum Type getType() const { return Ty; }
+  const llvm::APInt &getVal() const { return Val; }
+private:
+  enum Type Ty;
+  llvm::APInt Val;
+};
+
+/// Information needed for building expressions.
+struct BuildInfo {
+public:
+  BuildInfo(ASTContext *Ctx, ReplaceMap &VarReplace, bool dumpInColor)
+    : Ctx(Ctx), VarReplace(VarReplace), dumpInColor(dumpInColor) {}
+
+  ASTContext *Ctx;
+  ReplaceMap &VarReplace;
+  llvm::SmallPtrSet<VarDecl *, 8> SeenVars;
+  bool dumpInColor;
+
+  void reset() {
+    VarReplace.clear();
+    SeenVars.clear();
+  }
+};
+
+/// Reconstruct expressions with variables replaced by user-supplied
+/// expressions (in Info.VarReplacements).
+Expr *cloneWithReplacement(Expr *E, BuildInfo &Info);
+
+/// Clone an expression, but don't replace any variables.
+Expr *clone(Expr *E, ASTContext *Ctx);
+
+/// Clone a binary operation.
+Expr *cloneBinaryOperator(BinaryOperator *B, BuildInfo &Info);
+
+/// Clone a unary operation.
+Expr *cloneUnaryOperator(UnaryOperator *U, BuildInfo &Info);
+
+/// Clone a declaration reference.  If it's an induction variable, replace
+/// with the bound specified by the Upper flag.
+Expr *cloneDeclRefExpr(DeclRefExpr *D, BuildInfo &Info);
+
+/// Clone an implicit cast.
+Expr *cloneImplicitCastExpr(ImplicitCastExpr *E, BuildInfo &Info);
+
+/// Clone an integer literal.
+Expr *cloneIntegerLiteral(IntegerLiteral *L, BuildInfo &Info);
+
+/// Modify an expression according to a configuration.
+Expr *cloneAndModifyExpr(Expr *E, const Modifier &Mod, ASTContext *Ctx);
+
+} // end namespace PrefetchExprBuilder
+
+} // end namespace clang
+
+#endif
+
Index: include/clang/Sema/Sema.h
===================================================================
--- include/clang/Sema/Sema.h	(revision 320332)
+++ include/clang/Sema/Sema.h	(working copy)
@@ -7950,11 +7950,12 @@
 
   OMPClause *ActOnOpenMPVarListClause(
       OpenMPClauseKind Kind, ArrayRef<Expr *> Vars, Expr *TailExpr,
-      SourceLocation StartLoc, SourceLocation LParenLoc,
-      SourceLocation ColonLoc, SourceLocation EndLoc,
-      CXXScopeSpec &ReductionIdScopeSpec,
+      Expr *EndExpr, SourceLocation StartLoc, SourceLocation LParenLoc,
+      SourceLocation ColonLoc, SourceLocation EndColonLoc,
+      SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,
       const DeclarationNameInfo &ReductionId, OpenMPDependClauseKind DepKind,
-      SourceLocation DepLoc);
+      SourceLocation DepLoc, OpenMPPrefetchClauseKind PrefKind,
+      SourceLocation PrefLoc);
   /// \brief Called on well-formed 'private' clause.
   OMPClause *ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,
                                       SourceLocation StartLoc,
@@ -8018,6 +8019,18 @@
                           SourceLocation StartLoc, SourceLocation LParenLoc,
                           SourceLocation EndLoc);
 
+  /// \brief Called on well-formed 'prefetch' clause.
+  OMPClause *
+  ActOnOpenMPPrefetchClause(OpenMPPrefetchClauseKind PrefKind,
+                            SourceLocation PrefLoc,
+                            ArrayRef<Expr *> VarList,
+                            Expr *Start, Expr *End,
+                            SourceLocation StartLoc,
+                            SourceLocation LParenLoc,
+                            SourceLocation FirstColonLoc,
+                            SourceLocation SecondColonLoc,
+                            SourceLocation EndLoc);
+
   /// \brief The kind of conversion being performed.
   enum CheckedConversionKind {
     /// \brief An implicit conversion.
Index: lib/AST/Stmt.cpp
===================================================================
--- lib/AST/Stmt.cpp	(revision 320332)
+++ lib/AST/Stmt.cpp	(working copy)
@@ -1623,6 +1623,28 @@
   return nullptr;
 }
 
+OMPPrefetchClause *
+OMPPrefetchClause::Create(const ASTContext &C, OpenMPPrefetchClauseKind Kind,
+                          SourceLocation KindLoc, ArrayRef<Expr *> VL,
+                          Expr *Start, Expr *End, SourceLocation StartLoc,
+                          SourceLocation LParenLoc,
+                          SourceLocation FirstColonLoc,
+                          SourceLocation SecondColonLoc,
+                          SourceLocation EndLoc) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPPrefetchClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * VL.size());
+  OMPPrefetchClause *Clause =
+    new (Mem) OMPPrefetchClause(StartLoc, LParenLoc, FirstColonLoc, SecondColonLoc,
+                                EndLoc, VL.size());
+  Clause->setPrefetchKind(Kind);
+  Clause->setPrefetchKindLoc(KindLoc);
+  Clause->setStartOfRange(Start);
+  Clause->setEndOfRange(End);
+  Clause->setVarRefs(VL);
+  return Clause;
+}
+
 OMPParallelDirective *OMPParallelDirective::Create(
                                               const ASTContext &C,
                                               SourceLocation StartLoc,
Index: lib/AST/StmtPrinter.cpp
===================================================================
--- lib/AST/StmtPrinter.cpp	(revision 320332)
+++ lib/AST/StmtPrinter.cpp	(working copy)
@@ -810,7 +810,22 @@
     OS << ")";
   }
 }
+
+void OMPClausePrinter::VisitOMPPrefetchClause(OMPPrefetchClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "prefetch(";
+    OS << getOpenMPSimpleClauseTypeName(Node->getClauseKind(),
+                                        Node->getPrefetchKind())
+       << " :";
+    VisitOMPClauseList(Node, ' ');
+    OS << ",";
+    Node->getStartOfRange()->printPretty(OS, nullptr, Policy, 0);
+    OS << ",";
+    Node->getEndOfRange()->printPretty(OS, nullptr, Policy, 0);
+    OS << ")";
+  }
 }
+}
 
 //===----------------------------------------------------------------------===//
 //  OpenMP directives printing methods
Index: lib/AST/StmtProfile.cpp
===================================================================
--- lib/AST/StmtProfile.cpp	(revision 320332)
+++ lib/AST/StmtProfile.cpp	(working copy)
@@ -428,7 +428,12 @@
 void OMPClauseProfiler::VisitOMPDependClause(const OMPDependClause *C) {
   VisitOMPClauseList(C);
 }
+void OMPClauseProfiler::VisitOMPPrefetchClause(const OMPPrefetchClause *C) {
+  VisitOMPClauseList(C);
+  Profiler->VisitStmt(C->getStartOfRange());
+  Profiler->VisitStmt(C->getEndOfRange());
 }
+}
 
 void
 StmtProfiler::VisitOMPExecutableDirective(const OMPExecutableDirective *S) {
Index: lib/Analysis/CFG.cpp
===================================================================
--- lib/Analysis/CFG.cpp	(revision 320332)
+++ lib/Analysis/CFG.cpp	(working copy)
@@ -1,4 +1,4 @@
-  //===--- CFG.cpp - Classes for representing and building CFGs----*- C++ -*-===//
+//===--- CFG.cpp - Classes for representing and building CFGs----*- C++ -*-===//
 //
 //                     The LLVM Compiler Infrastructure
 //
Index: lib/Basic/OpenMPKinds.cpp
===================================================================
--- lib/Basic/OpenMPKinds.cpp	(revision 320332)
+++ lib/Basic/OpenMPKinds.cpp	(working copy)
@@ -96,6 +96,11 @@
 #define OPENMP_DEPEND_KIND(Name) .Case(#Name, OMPC_DEPEND_##Name)
 #include "clang/Basic/OpenMPKinds.def"
         .Default(OMPC_DEPEND_unknown);
+  case OMPC_prefetch:
+    return llvm::StringSwitch<OpenMPPrefetchClauseKind>(Str)
+#define OPENMP_PREFETCH_KIND(Name) .Case(#Name, OMPC_PREFETCH_##Name)
+#include "clang/Basic/OpenMPKinds.def"
+        .Default(OMPC_PREFETCH_unknown);
   case OMPC_unknown:
   case OMPC_threadprivate:
   case OMPC_if:
@@ -195,6 +200,7 @@
   case OMPC_update:
   case OMPC_capture:
   case OMPC_seq_cst:
+  case OMPC_prefetch:
     break;
   }
   llvm_unreachable("Invalid OpenMP simple clause kind");
Index: lib/Basic/Targets.cpp
===================================================================
--- lib/Basic/Targets.cpp	(revision 320332)
+++ lib/Basic/Targets.cpp	(working copy)
@@ -2239,7 +2239,7 @@
         HasAVX512DQ(false), HasAVX512BW(false), HasAVX512VL(false),
         HasSHA(false), HasCX16(false), CPU(CK_Generic), FPMath(FP_Default) {
     BigEndian = false;
-    LongDoubleFormat = &llvm::APFloat::x87DoubleExtended;
+    LongDoubleFormat = &llvm::APFloat::IEEEdouble;
   }
   unsigned getFloatEvalMethod() const override {
     // X87 evaluates with 80 bits "long double" precision.
@@ -3851,8 +3851,8 @@
     bool IsWinCOFF =
         getTriple().isOSWindows() && getTriple().isOSBinFormatCOFF();
     LongWidth = LongAlign = PointerWidth = PointerAlign = IsX32 ? 32 : 64;
-    LongDoubleWidth = 128;
-    LongDoubleAlign = 128;
+    LongDoubleWidth = 64;
+    LongDoubleAlign = 64;
     LargeArrayMinWidth = 128;
     LargeArrayAlign = 128;
     SuitableAlign = 128;
@@ -4987,8 +4987,8 @@
     MaxAtomicInlineWidth = 128;
     MaxAtomicPromoteWidth = 128;
 
-    LongDoubleWidth = LongDoubleAlign = SuitableAlign = 128;
-    LongDoubleFormat = &llvm::APFloat::IEEEquad;
+    LongDoubleWidth = LongDoubleAlign = SuitableAlign = 64;
+    LongDoubleFormat = &llvm::APFloat::IEEEdouble;
 
     // {} in inline assembly are neon specifiers, not assembly variant
     // specifiers.
Index: lib/CodeGen/BackendUtil.cpp
===================================================================
--- lib/CodeGen/BackendUtil.cpp	(revision 320332)
+++ lib/CodeGen/BackendUtil.cpp	(working copy)
@@ -15,6 +15,7 @@
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Frontend/Utils.h"
 #include "llvm/ADT/StringSwitch.h"
+#include "llvm/Analysis/Passes.h"
 #include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
@@ -39,6 +40,7 @@
 #include "llvm/Transforms/Instrumentation.h"
 #include "llvm/Transforms/ObjCARC.h"
 #include "llvm/Transforms/Scalar.h"
+#include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/SymbolRewriter.h"
 #include <memory>
 using namespace clang;
@@ -132,6 +134,16 @@
 
   std::unique_ptr<TargetMachine> TM;
 
+  /// Set up the assembly helper, including gathering passes
+  void SetupAssemblyHelper(BackendAction Action,
+                           raw_pwrite_stream *OS);
+
+  /// Run only IR optimization passes on a module
+  void ApplyIROptPasses(Module* TheModule);
+
+  /// Run backend passes to generate code
+  void ApplyCodegenPasses(Module* TheModule);
+
   void EmitAssembly(BackendAction Action, raw_pwrite_stream *OS);
 };
 
@@ -271,6 +283,18 @@
   MPM->add(createRewriteSymbolsPass(DL));
 }
 
+static void addPopcornMigPointPasses(const PassManagerBuilder &Builder,
+                                     legacy::PassManagerBase &PM) {
+  PM.add(createPopcornCompatibilityPass());
+  PM.add(createSelectMigrationPointsPass());
+}
+
+static void addPopcornAlignmentPasses(const PassManagerBuilder &Builder,
+                                      legacy::PassManagerBase &PM) {
+  PM.add(createNameStringLiteralsPass());
+  PM.add(createStaticVarSectionsPass());
+}
+
 void EmitAssemblyHelper::CreatePasses() {
   unsigned OptLevel = CodeGenOpts.OptimizationLevel;
   CodeGenOptions::InliningMethod Inlining = CodeGenOpts.getInlining();
@@ -420,6 +444,29 @@
     MPM->add(createInstrProfilingPass(Options));
   }
 
+  // Popcorn Compiler Toolchain passes -- add after IR optimization passes
+  // Select migration points.
+  if (CodeGenOpts.PopcornMigratable) {
+    if (OptLevel > 0)
+      PMBuilder.addExtension(PassManagerBuilder::EP_OptimizerLast,
+                             addPopcornMigPointPasses);
+    else {
+      MPM->add(createPopcornCompatibilityPass());
+      MPM->add(createSelectMigrationPointsPass());
+    }
+  }
+
+  // Adjust global symbol linkage for alignment.
+  if (CodeGenOpts.PopcornAlignment) {
+    if (OptLevel > 0)
+      PMBuilder.addExtension(PassManagerBuilder::EP_OptimizerLast,
+                             addPopcornAlignmentPasses);
+    else {
+      MPM->add(createNameStringLiteralsPass());
+      MPM->add(createStaticVarSectionsPass());
+    }
+  }
+
   PMBuilder.populateModulePassManager(*MPM);
 }
 
@@ -570,7 +617,7 @@
   // Normal mode, emit a .s or .o file by running the code generator. Note,
   // this also adds codegenerator level optimization passes.
   TargetMachine::CodeGenFileType CGFT = TargetMachine::CGFT_AssemblyFile;
-  if (Action == Backend_EmitObj)
+  if (Action == Backend_EmitObj || Action == Backend_EmitMultiObj)
     CGFT = TargetMachine::CGFT_ObjectFile;
   else if (Action == Backend_EmitMCNull)
     CGFT = TargetMachine::CGFT_Null;
@@ -592,8 +639,8 @@
   return true;
 }
 
-void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
-                                      raw_pwrite_stream *OS) {
+void EmitAssemblyHelper::SetupAssemblyHelper(BackendAction Action,
+                                             raw_pwrite_stream *OS) {
   TimeRegion Region(llvm::TimePassesIsEnabled ? &CodeGenerationTime : nullptr);
 
   bool UsesCodeGen = (Action != Backend_EmitNothing &&
@@ -629,7 +676,9 @@
 
   // Before executing passes, print the final values of the LLVM options.
   cl::PrintOptionValues();
+}
 
+void EmitAssemblyHelper::ApplyIROptPasses(Module* M) {
   // Run passes. For now we do all passes at once, but eventually we
   // would like to have the option of streaming code generation.
 
@@ -647,7 +696,9 @@
     PrettyStackTraceString CrashInfo("Per-module optimization passes");
     PerModulePasses->run(*TheModule);
   }
+}
 
+void EmitAssemblyHelper::ApplyCodegenPasses(Module* M) {
   if (CodeGenPasses) {
     PrettyStackTraceString CrashInfo("Code generation");
     CodeGenPasses->run(*TheModule);
@@ -654,6 +705,13 @@
   }
 }
 
+void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
+                                      raw_pwrite_stream *OS) {
+  SetupAssemblyHelper(Action, OS);
+  ApplyIROptPasses(TheModule);
+  ApplyCodegenPasses(TheModule);
+}
+
 void clang::EmitBackendOutput(DiagnosticsEngine &Diags,
                               const CodeGenOptions &CGOpts,
                               const clang::TargetOptions &TOpts,
@@ -677,3 +735,38 @@
     }
   }
 }
+
+void clang::ApplyIROptimizations(DiagnosticsEngine &Diags,
+                                 const CodeGenOptions &CGOpts,
+                                 const clang::TargetOptions &TOpts,
+                                 const LangOptions &LOpts, Module *M,
+                                 BackendAction Action, raw_pwrite_stream *OS) {
+  EmitAssemblyHelper AsmHelper(Diags, CGOpts, TOpts, LOpts, M);
+  AsmHelper.SetupAssemblyHelper(Action, OS);
+  AsmHelper.ApplyIROptPasses(M);
+}
+
+void clang::CodegenBackendOutput(DiagnosticsEngine &Diags,
+                                 const CodeGenOptions &CGOpts,
+                                 const clang::TargetOptions &TOpts,
+                                 const LangOptions &LOpts, StringRef TDesc,
+                                 Module *M, BackendAction Action,
+                                 raw_pwrite_stream *OS) {
+  EmitAssemblyHelper AsmHelper(Diags, CGOpts, TOpts, LOpts, M);
+  AsmHelper.SetupAssemblyHelper(Action, OS);
+
+  // If an optional clang TargetInfo description string was passed in, use it to
+  // verify the LLVM TargetMachine's DataLayout.
+  if (AsmHelper.TM && !TDesc.empty()) {
+    std::string DLDesc =
+        AsmHelper.TM->getDataLayout()->getStringRepresentation();
+    if (DLDesc != TDesc) {
+      unsigned DiagID = Diags.getCustomDiagID(
+          DiagnosticsEngine::Error, "backend data layout '%0' does not match "
+                                    "expected target description '%1'");
+      Diags.Report(DiagID) << DLDesc << TDesc;
+    }
+  }
+
+  AsmHelper.ApplyCodegenPasses(M);
+}
Index: lib/CodeGen/CGStmt.cpp
===================================================================
--- lib/CodeGen/CGStmt.cpp	(revision 320332)
+++ lib/CodeGen/CGStmt.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/AST/StmtVisitor.h"
 #include "clang/Basic/PrettyStackTrace.h"
 #include "clang/Basic/TargetInfo.h"
+#include "clang/CodeGen/PrefetchBuilder.h"
 #include "clang/Sema/LoopHint.h"
 #include "clang/Sema/SemaDiagnostic.h"
 #include "llvm/ADT/StringExtras.h"
@@ -840,6 +841,19 @@
 
   LexicalScope ForScope(*this, S.getSourceRange());
 
+  if(S.prefetchEnabled()) {
+    const PrefetchAnalysis *PA = getContext().getPrefetchAnalysis(&S);
+    if(PA) {
+      PrefetchBuilder PB(this);
+      const SmallVector<PrefetchRange, 8> &Pref = PA->getArraysToPrefetch();
+      if(Pref.size()) {
+        PB.EmitPrefetchCallDeclarations();
+        for(auto &Range : Pref) PB.EmitPrefetchCall(Range);
+        PB.EmitPrefetchExecuteCall();
+      }
+    }
+  }
+
   // Evaluate the first part before the loop.
   if (S.getInit())
     EmitStmt(S.getInit());
@@ -2147,6 +2161,69 @@
   }
 }
 
+
+void CodeGenFunction::addOffloaded(const CapturedStmt *S, ValueDecl *L,
+                                   ValueDecl *G) {
+  assert(S && isa<CapturedStmt>(S) && "Invalid captured statement");
+  assert(L && G && "Invalid value declarations");
+  OffloadedLocals[S].emplace_back(L, G);
+}
+
+const CodeGenFunction::OffloadList &
+CodeGenFunction::getOffloaded(const CapturedStmt *S) const {
+  assert(S && isa<CapturedStmt>(S) && "Invalid captured statement");
+  OffloadMap::const_iterator it = OffloadedLocals.find(S);
+  assert((it != OffloadedLocals.end()) && "Captured statement not visited?");
+  return it->second;
+}
+
+VarDecl *CodeGenFunction::CreateOffloadedGlobal(const Stmt &S, const Expr *I) {
+  ASTContext &AST = getContext();
+  DeclContext *TUC = AST.getTranslationUnitDecl();
+  SourceRange SR = S.getSourceRange();
+  IdentifierInfo *II = &AST.Idents.get("distr_omp_" +
+      std::string(CurFn->getName()) + "_" +
+      cast<DeclRefExpr>(I)->getDecl()->getNameAsString());
+  QualType Ty = I->getType();
+  if(Ty.isLocalConstQualified()) Ty.removeLocalConst();
+  TypeSourceInfo *TSI = AST.getTrivialTypeSourceInfo(Ty, SR.getBegin());
+  return VarDecl::Create(AST, TUC, SR.getBegin(), SR.getEnd(),
+                         II, Ty, TSI, clang::SC_Static);
+}
+
+LValue CodeGenFunction::GetVarDeclLValue(const Expr *I, VarDecl *VD) {
+  QualType SrcType = I->getType();
+  if(SrcType.isLocalConstQualified()) SrcType.removeLocalConst();
+  llvm::Type *Ty = CGM.getTypes().ConvertType(SrcType);
+  llvm::Constant *GV = CGM.GetAddrOfGlobalVar(VD, Ty);
+  llvm::GlobalVariable *CastGV = cast<llvm::GlobalVariable>(GV);
+  CastGV->setInitializer(llvm::Constant::getNullValue(Ty));
+  CastGV->setLinkage(llvm::GlobalValue::InternalLinkage);
+  return MakeNaturalAlignAddrLValue(GV, SrcType);
+}
+
+DeclRefExpr *CodeGenFunction::GetDeclRefForOffload(ValueDecl *VD) {
+  ASTContext &AST = getContext();
+  QualType Ty = VD->getType();
+  DeclRefExpr *DRE = DeclRefExpr::Create(AST, NestedNameSpecifierLoc(),
+                                         SourceLocation(), VD, false,
+                                         VD->getSourceRange().getBegin(),
+                                         Ty, VK_LValue);
+  DRE->getDecl()->setIsUsed();
+  return DRE;
+}
+
+void CodeGenFunction::RestoreOffloadedLocals(const CapturedStmt *S) {
+  Expr *Global;
+  const OffloadList &Offloaded = getOffloaded(S);
+  for(auto Pair : Offloaded) {
+    if(Pair.first->getType().isLocalConstQualified()) continue;
+    LValue LocalLV(EmitDeclRefLValue(GetDeclRefForOffload(Pair.first)));
+    Global = GetDeclRefForOffload(Pair.second);
+    EmitAnyExprToMem(Global, LocalLV.getAddress(), LocalLV.getQuals(), false);
+  }
+}
+
 LValue CodeGenFunction::InitCapturedStruct(const CapturedStmt &S) {
   const RecordDecl *RD = S.getCapturedRecordDecl();
   QualType RecordTy = getContext().getRecordType(RD);
@@ -2155,6 +2232,8 @@
   LValue SlotLV = MakeNaturalAlignAddrLValue(
       CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
 
+  if(S.offloadShared()) OffloadedLocals[&S] = OffloadList();
+
   RecordDecl::field_iterator CurField = RD->field_begin();
   for (CapturedStmt::capture_init_iterator I = S.capture_init_begin(),
                                            E = S.capture_init_end();
@@ -2164,7 +2243,18 @@
       auto VAT = CurField->getCapturedVLAType();
       EmitStoreThroughLValue(RValue::get(VLASizeMap[VAT->getSizeExpr()]), LV);
     } else {
-      EmitInitializerForField(*CurField, LV, *I, None);
+      if(S.offloadShared()) {
+        // If distributed, create global variable, emit initializer & place
+        // address of new global into capture struct
+        assert(isa<DeclRefExpr>(*I) && "Invalid capture type");
+        VarDecl *GLD = CreateOffloadedGlobal(S, *I);
+        LValue GLV = GetVarDeclLValue(*I, GLD);
+        EmitAnyExprToMem(*I, GLV.getAddress(), GLV.getQuals(), false);
+        Expr *GlobalRef = GetDeclRefForOffload(GLD);
+        EmitInitializerForField(*CurField, LV, GlobalRef, None);
+        addOffloaded(&S, cast<DeclRefExpr>(*I)->getDecl(), GLD);
+      }
+      else EmitInitializerForField(*CurField, LV, *I, None);
     }
   }
 
Index: lib/CodeGen/CGStmtOpenMP.cpp
===================================================================
--- lib/CodeGen/CGStmtOpenMP.cpp	(revision 320332)
+++ lib/CodeGen/CGStmtOpenMP.cpp	(working copy)
@@ -17,6 +17,7 @@
 #include "TargetInfo.h"
 #include "clang/AST/Stmt.h"
 #include "clang/AST/StmtOpenMP.h"
+#include "llvm/IR/CallSite.h"
 using namespace clang;
 using namespace CodeGen;
 
@@ -489,6 +490,8 @@
   }
   CGF.CGM.getOpenMPRuntime().emitParallelCall(CGF, S.getLocStart(), OutlinedFn,
                                               CapturedStruct, IfCond);
+
+  if(CS->offloadShared()) CGF.RestoreOffloadedLocals(CS);
 }
 
 void CodeGenFunction::EmitOMPParallelDirective(const OMPParallelDirective &S) {
@@ -743,6 +746,162 @@
   }
 }
 
+/// Ease the variable lookup burden for captures.
+typedef llvm::DenseMap<const VarDecl *, DeclRefExpr *> CaptureMap;
+
+/// Map variable declarations captured in the outer function to their field in
+/// the captured struct.
+static void
+buildCapturedMap(ASTContext &C, CapturedStmt *CS, CaptureMap &Map) {
+  // Captures are in a 1-to-1 correspondence with captured record fields
+  Map.clear();
+  for(auto Child : CS->children()) {
+    if(isa<DeclRefExpr>(Child)) {
+      DeclRefExpr *DRE = cast<DeclRefExpr>(Child);
+      ValueDecl *Decl = DRE->getDecl();
+      if(isa<VarDecl>(Decl)) Map[cast<VarDecl>(Decl)] = DRE;
+    }
+  }
+}
+
+/// Create an expression representing the address of some array index.
+static Expr *getPrefetchAddr(ASTContext &C, Expr *Ptr, Expr *Subscript) {
+  QualType BaseTy = Ptr->getType().getDesugaredType(C), IdxTy;
+
+  // Get an array subscript
+  if(isa<ArrayType>(BaseTy)) IdxTy = cast<ArrayType>(BaseTy)->getElementType();
+  else IdxTy = cast<PointerType>(BaseTy)->getPointeeType();
+  Expr *Index = new (C) ArraySubscriptExpr(Ptr, Subscript, IdxTy,
+                                           VK_RValue, OK_Ordinary,
+                                           SourceLocation());
+
+  // Take the address of the array subscript
+  QualType RePtrTy = C.getPointerType(IdxTy);
+  UnaryOperator *Addr = new (C) UnaryOperator(Index, UO_AddrOf, RePtrTy, VK_LValue,
+                               OK_Ordinary, SourceLocation());
+
+  // Finally, cast to a const void * type
+  QualType VoidPtrTy = C.getPointerType(C.VoidTy.withConst());
+  return ImplicitCastExpr::Create(C, VoidPtrTy, CK_BitCast, Addr, nullptr,
+                                  VK_RValue);
+}
+
+static Expr *getArrayIndexAddr(ASTContext &C, Expr *Arr, const llvm::APInt &Idx) {
+  QualType Ty = Arr->getType();
+  if(Ty->isArrayType()) {
+    Ty = C.getPointerType(cast<ArrayType>(Ty)->getElementType());
+    Arr = ImplicitCastExpr::Create(C, Ty, CK_ArrayToPointerDecay, Arr, nullptr,
+                                   VK_RValue);
+  }
+  Expr *IdxLiteral =
+    IntegerLiteral::Create(C, Idx, C.LongTy, SourceLocation());
+  return getPrefetchAddr(C, Arr, IdxLiteral);
+}
+
+static Expr *getArrayIndexAddr(ASTContext &C, Expr *Arr, int64_t Idx) {
+  return getArrayIndexAddr(C, Arr, llvm::APInt(64, Idx, true));
+}
+
+static llvm::Constant *getPrefetchKind(CodeGenFunction &CGF,
+                                       OpenMPPrefetchClauseKind Kind) {
+  llvm::Type *Ty = llvm::Type::getInt32Ty(CGF.CurFn->getContext());
+  switch(Kind) {
+  case OMPC_PREFETCH_read: return llvm::ConstantInt::get(Ty, 0);
+  case OMPC_PREFETCH_write: return llvm::ConstantInt::get(Ty, 1);
+  //case OMPC_PREFETCH_release: return llvm::ConstantInt::get(Ty, 3);
+  default:
+    llvm_unreachable("Invalid prefetch type\n");
+    return nullptr;
+  }
+}
+
+void CodeGenFunction::EmitOMPPrefetchClauses(const OMPLoopDirective &D) {
+  ASTContext &AST = getContext();
+  CaptureMap AllCaptures;
+  CaptureMap::iterator Captured;
+  const ConstantArrayType *ArrTy;
+  Expr *Base, *Start, *End, *StartAddr, *EndAddr;
+  RValue LoweredStart, LoweredEnd;
+  std::vector<llvm::Value *> Params;
+  std::vector<llvm::Type *> ParamTypes;
+  llvm::FunctionType *FnType;
+  llvm::Constant *Prefetch, *Execute;
+
+  bool HasPrefetch = !D.getClausesOfKind(OMPC_prefetch).empty();
+  if(HasPrefetch) {
+    // declare void @popcorn_prefetch(i32, i8*, i8*)
+    ParamTypes = { Int32Ty, Int8PtrTy, Int8PtrTy };
+    FnType = llvm::FunctionType::get(VoidTy, ParamTypes, false);
+    Prefetch = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch");
+
+    // declare i64 @popcorn_prefetch_execute()
+    ParamTypes.clear();
+    FnType = llvm::FunctionType::get(Int64Ty, ParamTypes, false);
+    Execute = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch_execute");
+
+    // For each prefetched variable, construct start & end range expressions
+    // and call @popcorn_prefetch
+    CapturedStmt *CS = cast<CapturedStmt>(D.getAssociatedStmt());
+    buildCapturedMap(AST, CS, AllCaptures);
+
+    for(auto &&I = D.getClausesOfKind(OMPC_prefetch); I; ++I) {
+      auto *C = cast<OMPPrefetchClause>(*I);
+      Start = C->getStartOfRange();
+      End = C->getEndOfRange();
+
+      for(auto &V : C->varlists()) {
+        const DeclRefExpr *DR = cast<DeclRefExpr>(V);
+        const VarDecl *VD = cast<VarDecl>(DR->getDecl());
+        Captured = AllCaptures.find(VD);
+
+        // TODO the current mechanism for calculating addresses applies an
+        // "inbounds" tag to the array index addressing expression, but we
+        // don't necessarily know this is true.
+        if(Captured != AllCaptures.end()) {
+          Base = Captured->second;
+          if(Start && End) {
+            // User specified entire range
+            StartAddr = getPrefetchAddr(AST, Base, Start);
+            EndAddr = getPrefetchAddr(AST, Base, End);
+          }
+          else if(Start) {
+            // User specified an expression affine to loop iteration variable
+            // TODO if expression is affine transformation of loop induction
+            // variable, need to re-generate for lower/upper bound variables
+            assert(isa<DeclRefExpr>(Start) &&
+                   "Can't handle transformations on loop variables yet");
+            StartAddr = getPrefetchAddr(AST, Base, D.getLowerBoundVariable());
+            EndAddr = getPrefetchAddr(AST, Base, D.getUpperBoundVariable());
+          }
+          else {
+            // User didn't specify a range, prefetch the entire array (note:
+            // should have type checked it's an array by now).
+            QualType QTy = Base->getType();
+            while(isa<DecayedType>(QTy))
+              QTy = cast<DecayedType>(QTy)->getOriginalType();
+            ArrTy = cast<ConstantArrayType>(QTy);
+            const llvm::APInt &Size = ArrTy->getSize();
+            StartAddr = getArrayIndexAddr(AST, Base, 0);
+            EndAddr = getArrayIndexAddr(AST, Base, Size);
+          }
+
+          LoweredStart = EmitAnyExpr(StartAddr);
+          LoweredEnd = EmitAnyExpr(EndAddr);
+          Params = { getPrefetchKind(*this, C->getPrefetchKind()),
+                     LoweredStart.getScalarVal(),
+                     LoweredEnd.getScalarVal() };
+          EmitCallOrInvoke(Prefetch, Params);
+        }
+        else llvm_unreachable("Invalid prefetch variable");
+      }
+    }
+
+    // Finally, call @popcorn_prefetch_execute to issue requests
+    Params.clear();
+    EmitCallOrInvoke(Execute, Params);
+  }
+}
+
 void CodeGenFunction::EmitOMPSimdInit(const OMPLoopDirective &D) {
   // Walk clauses and process safelen/lastprivate.
   LoopStack.setParallel();
@@ -1137,6 +1296,8 @@
         auto LoopExit = getJumpDestInCurrentScope(createBasicBlock("omp.loop.exit"));
         // UB = min(UB, GlobalUB);
         EmitIgnoredExpr(S.getEnsureUpperBound());
+        // Popcorn: emit prefetch function declarations & requests
+        if(S.prefetchingEnabled()) EmitOMPPrefetchClauses(S);
         // IV = LB;
         EmitIgnoredExpr(S.getInit());
         // while (idx <= UB) { BODY; ++idx; }
@@ -2049,6 +2210,7 @@
   case OMPC_threadprivate:
   case OMPC_depend:
   case OMPC_mergeable:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed in 'omp atomic'.");
   }
 }
Index: lib/CodeGen/CMakeLists.txt
===================================================================
--- lib/CodeGen/CMakeLists.txt	(revision 320332)
+++ lib/CodeGen/CMakeLists.txt	(working copy)
@@ -73,6 +73,8 @@
   MicrosoftCXXABI.cpp
   ModuleBuilder.cpp
   ObjectFilePCHContainerOperations.cpp
+  PopcornUtil.cpp
+  PrefetchBuilder.cpp
   SanitizerMetadata.cpp
   TargetInfo.cpp
 
Index: lib/CodeGen/CodeGenAction.cpp
===================================================================
--- lib/CodeGen/CodeGenAction.cpp	(revision 320332)
+++ lib/CodeGen/CodeGenAction.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/CodeGen/BackendUtil.h"
 #include "clang/CodeGen/CodeGenAction.h"
 #include "clang/CodeGen/ModuleBuilder.h"
+#include "clang/CodeGen/PopcornUtil.h"
 #include "clang/Frontend/CompilerInstance.h"
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Lex/Preprocessor.h"
@@ -34,6 +35,7 @@
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Support/Timer.h"
+#include "llvm/Transforms/Utils/Cloning.h"
 #include <memory>
 using namespace clang;
 using namespace llvm;
@@ -41,6 +43,7 @@
 namespace clang {
   class BackendConsumer : public ASTConsumer {
     virtual void anchor();
+  protected:
     DiagnosticsEngine &Diags;
     BackendAction Action;
     const CodeGenOptions &CodeGenOpts;
@@ -129,7 +132,7 @@
         LLVMIRGeneration.stopTimer();
     }
 
-    void HandleTranslationUnit(ASTContext &C) override {
+    void HandleTranslationUnitCommon(ASTContext &C) {
       {
         PrettyStackTraceString CrashInfo("Per-file LLVM IR generation");
         if (llvm::TimePassesIsEnabled)
@@ -165,7 +168,11 @@
                 [=](const DiagnosticInfo &DI) { linkerDiagnosticHandler(DI); }))
           return;
       }
+    }
 
+    void HandleTranslationUnit(ASTContext &C) override {
+      HandleTranslationUnitCommon(C);
+
       // Install an inline asm handler so that diagnostics get printed through
       // our diagnostics hooks.
       LLVMContext &Ctx = TheModule->getContext();
@@ -259,8 +266,78 @@
     void OptimizationFailureHandler(
         const llvm::DiagnosticInfoOptimizationFailure &D);
   };
-  
+
   void BackendConsumer::anchor() {}
+
+  class MultiBackendConsumer : public BackendConsumer {
+  private:
+    virtual void anchor() override;
+    SmallVector<raw_pwrite_stream *, 2> &AsmOutStreams;
+    const SmallVector<std::shared_ptr<TargetOptions>, 2> &AsmTargetOpts;
+    const SmallVector<TargetInfo *, 2> &AsmTargetInfos;
+    const CodeGenOptions &NoOptCodegen;
+  public:
+    MultiBackendConsumer(DiagnosticsEngine &Diags,
+                    const HeaderSearchOptions &HeaderSearchOpts,
+                    const PreprocessorOptions &PPOpts,
+                    const CodeGenOptions &CodeGenOpts,
+                    const CodeGenOptions &NoOptCodegen,
+                    const SmallVector<std::shared_ptr<TargetOptions>, 2> &TargetOpts,
+                    const LangOptions &LangOpts, bool TimePasses,
+                    const std::string &InFile, llvm::Module *LinkModule,
+                    SmallVector<raw_pwrite_stream *, 2> &OSs, LLVMContext &C,
+                    const SmallVector<TargetInfo *, 2> &TargetInfos,
+                    CoverageSourceInfo *CoverageInfo = nullptr)
+        : BackendConsumer(Backend_EmitMultiObj, Diags, HeaderSearchOpts,
+                          PPOpts, CodeGenOpts, *TargetOpts[0], LangOpts,
+                          TimePasses, InFile, LinkModule, OSs[0], C,
+                          CoverageInfo),
+          AsmOutStreams(OSs), AsmTargetOpts(TargetOpts),
+          AsmTargetInfos(TargetInfos), NoOptCodegen(NoOptCodegen) {}
+
+    void HandleTranslationUnit(ASTContext &C) override {
+      HandleTranslationUnitCommon(C);
+
+      // Install an inline asm handler so that diagnostics get printed through
+      // our diagnostics hooks.
+      LLVMContext &Ctx = TheModule->getContext();
+      LLVMContext::InlineAsmDiagHandlerTy OldHandler =
+        Ctx.getInlineAsmDiagnosticHandler();
+      void *OldContext = Ctx.getInlineAsmDiagnosticContext();
+      Ctx.setInlineAsmDiagnosticHandler(InlineAsmDiagHandler, this);
+
+      LLVMContext::DiagnosticHandlerTy OldDiagnosticHandler =
+          Ctx.getDiagnosticHandler();
+      void *OldDiagnosticContext = Ctx.getDiagnosticContext();
+      Ctx.setDiagnosticHandler(DiagnosticHandler, this);
+
+      // Apply IR optimizations, but strip target-specific attributes from
+      // all functions added by analyses
+      std::shared_ptr<TargetOptions> IRTargetOpts =
+        Popcorn::GetPopcornTargetOpts(TheModule->getTargetTriple());
+      ApplyIROptimizations(Diags, CodeGenOpts, *IRTargetOpts, LangOpts,
+                           TheModule.get(), Action, nullptr);
+      Popcorn::StripTargetAttributes(*TheModule);
+
+      // Generate machine code for each target
+      for(size_t i = 0; i < AsmTargetOpts.size(); i++) {
+        llvm::Module* ArchModule = CloneModule(TheModule.get());
+        ArchModule->setTargetTriple(AsmTargetInfos[i]->getTriple().getTriple());
+        ArchModule->setDataLayout(AsmTargetInfos[i]->getTargetDescription());
+        Popcorn::AddArchSpecificTargetFeatures(*ArchModule, AsmTargetOpts[i]);
+        CodegenBackendOutput(Diags, NoOptCodegen, *AsmTargetOpts[i], LangOpts,
+                             AsmTargetInfos[i]->getTargetDescription(),
+                             ArchModule, Action, AsmOutStreams[i]);
+        delete ArchModule;
+      }
+
+      Ctx.setInlineAsmDiagnosticHandler(OldHandler, OldContext);
+
+      Ctx.setDiagnosticHandler(OldDiagnosticHandler, OldDiagnosticContext);
+    }
+  };
+
+  void MultiBackendConsumer::anchor() {}
 }
 
 /// ConvertBackendLocation - Convert a location in a temporary llvm::SourceMgr
@@ -626,6 +703,7 @@
   case Backend_EmitMCNull:
     return CI.createNullOutputFile();
   case Backend_EmitObj:
+  case Backend_EmitMultiObj:
     return CI.createDefaultOutputFile(true, InFile, "o");
   }
 
@@ -632,13 +710,7 @@
   llvm_unreachable("Invalid action!");
 }
 
-std::unique_ptr<ASTConsumer>
-CodeGenAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
-  BackendAction BA = static_cast<BackendAction>(Act);
-  raw_pwrite_stream *OS = GetOutputStream(CI, InFile, BA);
-  if (BA != Backend_EmitNothing && !OS)
-    return nullptr;
-
+llvm::Module *CodeGenAction::getLinkModuleToUse(CompilerInstance &CI) {
   llvm::Module *LinkModuleToUse = LinkModule;
 
   // If we were not given a link module, and the user requested that one be
@@ -662,6 +734,10 @@
     LinkModuleToUse = ModuleOrErr.get().release();
   }
 
+  return LinkModuleToUse;
+}
+
+CoverageSourceInfo *CodeGenAction::getCoverageInfo(CompilerInstance &CI) {
   CoverageSourceInfo *CoverageInfo = nullptr;
   // Add the preprocessor callback only when the coverage mapping is generated.
   if (CI.getCodeGenOpts().CoverageMapping) {
@@ -669,6 +745,19 @@
     CI.getPreprocessor().addPPCallbacks(
                                     std::unique_ptr<PPCallbacks>(CoverageInfo));
   }
+  return CoverageInfo;
+}
+
+std::unique_ptr<ASTConsumer>
+CodeGenAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
+  BackendAction BA = static_cast<BackendAction>(Act);
+  raw_pwrite_stream *OS = GetOutputStream(CI, InFile, BA);
+  if (BA != Backend_EmitNothing && !OS)
+    return nullptr;
+
+  llvm::Module *LinkModuleToUse = getLinkModuleToUse(CI);
+  CoverageSourceInfo *CoverageInfo = getCoverageInfo(CI);
+
   std::unique_ptr<BackendConsumer> Result(new BackendConsumer(
       BA, CI.getDiagnostics(), CI.getHeaderSearchOpts(),
       CI.getPreprocessorOpts(), CI.getCodeGenOpts(), CI.getTargetOpts(),
@@ -684,6 +773,42 @@
   SM.print(nullptr, llvm::errs());
 }
 
+bool CodeGenAction::ExecuteActionIRCommon(BackendAction &BA,
+                                          CompilerInstance &CI) {
+  bool Invalid;
+  SourceManager &SM = CI.getSourceManager();
+  FileID FID = SM.getMainFileID();
+  llvm::MemoryBuffer *MainFile = SM.getBuffer(FID, &Invalid);
+  if (Invalid)
+    return true;
+
+  llvm::SMDiagnostic Err;
+  TheModule = parseIR(MainFile->getMemBufferRef(), Err, *VMContext);
+  if (!TheModule) {
+    // Translate from the diagnostic info to the SourceManager location if
+    // available.
+    // TODO: Unify this with ConvertBackendLocation()
+    SourceLocation Loc;
+    if (Err.getLineNo() > 0) {
+      assert(Err.getColumnNo() >= 0);
+      Loc = SM.translateFileLineCol(SM.getFileEntryForID(FID),
+                                    Err.getLineNo(), Err.getColumnNo() + 1);
+    }
+
+    // Strip off a leading diagnostic code if there is one.
+    StringRef Msg = Err.getMessage();
+    if (Msg.startswith("error: "))
+      Msg = Msg.substr(7);
+
+    unsigned DiagID =
+        CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
+
+    CI.getDiagnostics().Report(Loc, DiagID) << Msg;
+    return true;
+  }
+  return false;
+}
+
 void CodeGenAction::ExecuteAction() {
   // If this is an IR file, we have to treat it specially.
   if (getCurrentFileKind() == IK_LLVM_IR) {
@@ -693,37 +818,9 @@
     if (BA != Backend_EmitNothing && !OS)
       return;
 
-    bool Invalid;
-    SourceManager &SM = CI.getSourceManager();
-    FileID FID = SM.getMainFileID();
-    llvm::MemoryBuffer *MainFile = SM.getBuffer(FID, &Invalid);
-    if (Invalid)
+    if(ExecuteActionIRCommon(BA, CI))
       return;
 
-    llvm::SMDiagnostic Err;
-    TheModule = parseIR(MainFile->getMemBufferRef(), Err, *VMContext);
-    if (!TheModule) {
-      // Translate from the diagnostic info to the SourceManager location if
-      // available.
-      // TODO: Unify this with ConvertBackendLocation()
-      SourceLocation Loc;
-      if (Err.getLineNo() > 0) {
-        assert(Err.getColumnNo() >= 0);
-        Loc = SM.translateFileLineCol(SM.getFileEntryForID(FID),
-                                      Err.getLineNo(), Err.getColumnNo() + 1);
-      }
-
-      // Strip off a leading diagnostic code if there is one.
-      StringRef Msg = Err.getMessage();
-      if (Msg.startswith("error: "))
-        Msg = Msg.substr(7);
-
-      unsigned DiagID =
-          CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
-
-      CI.getDiagnostics().Report(Loc, DiagID) << Msg;
-      return;
-    }
     const TargetOptions &TargetOpts = CI.getTargetOpts();
     if (TheModule->getTargetTriple() != TargetOpts.Triple) {
       CI.getDiagnostics().Report(SourceLocation(),
@@ -769,3 +866,150 @@
 void EmitObjAction::anchor() { }
 EmitObjAction::EmitObjAction(llvm::LLVMContext *_VMContext)
   : CodeGenAction(Backend_EmitObj, _VMContext) {}
+
+void EmitMultiObjAction::anchor() { }
+EmitMultiObjAction::EmitMultiObjAction(llvm::LLVMContext *_VMContext)
+  : CodeGenAction(Backend_EmitMultiObj, _VMContext) {}
+
+static std::string AppendArchName(StringRef File, const TargetInfo *TI) {
+  size_t dot = File.rfind('.');
+  std::string NewFile = File.substr(0, dot);
+  NewFile += "_";
+  NewFile += TI->getTriple().getArchName();
+  NewFile += File.substr(dot, StringRef::npos);
+  return NewFile;
+}
+
+static llvm::SmallVector<std::string, 2>
+dedupTargets(llvm::SmallVector<std::string, 2> &Requested) {
+  std::set<std::string> Targets;
+  for(auto &Target : Requested) Targets.insert(Target);
+  llvm::SmallVector<std::string, 2> Ret;
+  for(auto Target : Targets) Ret.push_back(Target);
+  return Ret;
+}
+
+/// Create target information & output streams for each target.
+bool EmitMultiObjAction::InitializeTargets(CompilerInstance &CI,
+                                           StringRef InFile) {
+  // Note: remove output filename from frontend args, as it will override any
+  // special names we try to specify.
+  std::string OutFile(InFile);
+  if(CI.getFrontendOpts().OutputFile != "") {
+    OutFile = CI.getFrontendOpts().OutputFile;
+    CI.getFrontendOpts().OutputFile = "";
+  }
+
+  // Populate list of targets requested.  If none are requested, default to all
+  // supported targets.
+  std::vector<std::string> &Requested = CI.getCodeGenOpts().PopcornTargets;
+  if(Requested.size()) {
+    for(auto &Target : Requested) {
+      if(!Popcorn::SupportedTarget(Target)) {
+        std::string Msg("Popcorn: unsupported target '" + Target + "'");
+        unsigned DiagID =
+            CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
+        CI.getDiagnostics().Report(DiagID) << Msg;
+        return false;
+      }
+      Targets.push_back(Target);
+    }
+    Targets = dedupTargets(Targets);
+  }
+  else Popcorn::GetAllTargets(this->Targets);
+
+  BackendAction BA = Backend_EmitMultiObj;
+  if(Targets.size() > 1) {
+    for(size_t i = 0; i < Targets.size(); i++) {
+      std::shared_ptr<TargetOptions> Opts = Popcorn::GetPopcornTargetOpts(Targets[i]);
+      TargetOpts.push_back(Opts);
+      TargetInfos.push_back(TargetInfo::CreateTargetInfo(CI.getDiagnostics(), Opts));
+
+      raw_pwrite_stream *OS;
+      OS = GetOutputStream(CI, AppendArchName(OutFile, TargetInfos[i]), BA);
+      if (!OS) return false;
+      OutFiles.push_back(OS);
+    }
+  }
+  else {
+    std::shared_ptr<TargetOptions> Opts = Popcorn::GetPopcornTargetOpts(Targets[0]);
+    TargetOpts.push_back(Opts);
+    TargetInfos.push_back(TargetInfo::CreateTargetInfo(CI.getDiagnostics(), Opts));
+
+    raw_pwrite_stream *OS = GetOutputStream(CI, OutFile, BA);
+    if (!OS) return false;
+    OutFiles.push_back(OS);
+  }
+  CI.getFrontendOpts().OutputFile = OutFile;
+
+  return true;
+}
+
+/// Initialize target information & open output streams for each target.
+std::unique_ptr<ASTConsumer>
+EmitMultiObjAction::CreateASTConsumer(CompilerInstance &CI,
+                                      StringRef InFile) {
+  if(!InitializeTargets(CI, InFile)) return nullptr;
+  llvm::Module *LinkModuleToUse = getLinkModuleToUse(CI);
+  CoverageSourceInfo *CoverageInfo = getCoverageInfo(CI);
+
+  // Create a MultiBackendConsumer, which is identical to a BackendConsumer
+  // except that it runs the generated IR through multiple backends.
+  std::unique_ptr<MultiBackendConsumer> Result(new MultiBackendConsumer(
+      CI.getDiagnostics(), CI.getHeaderSearchOpts(),
+      CI.getPreprocessorOpts(), CI.getCodeGenOpts(), CI.getCodeGenNoOpts(),
+      TargetOpts, CI.getLangOpts(), CI.getFrontendOpts().ShowTimers, InFile,
+      LinkModuleToUse, OutFiles, *VMContext, TargetInfos, CoverageInfo));
+  BEConsumer = Result.get();
+  return std::move(Result);
+}
+
+void EmitMultiObjAction::ExecuteAction() {
+  // If this is an IR file, we have to treat it specially.
+  if (getCurrentFileKind() == IK_LLVM_IR) {
+    // Initialize targets here because we never called CreateASTConsumer
+    CompilerInstance &CI = getCompilerInstance();
+    StringRef OutFile = getCurrentFile();
+    BackendAction BA = Backend_EmitMultiObj;
+
+    if(!InitializeTargets(CI, OutFile)) {
+      // TODO add diagnostics saying we couldn't initialize targets
+      return;
+    }
+
+    if(ExecuteActionIRCommon(BA, CI)) {
+      // TODO add diagnostics saying we couldn't do common IR work
+      return;
+    }
+
+    // Apply IR optimizations, but strip target-specific attributes from all
+    // functions added by analyses
+    std::shared_ptr<TargetOptions> IRTargetOpts =
+      Popcorn::GetPopcornTargetOpts(TheModule->getTargetTriple());
+    ApplyIROptimizations(CI.getDiagnostics(), CI.getCodeGenOpts(),
+                         *IRTargetOpts, CI.getLangOpts(),
+                         TheModule.get(), BA, nullptr);
+    Popcorn::StripTargetAttributes(*TheModule);
+
+    // Emit machine code for all specified architectures
+    for(size_t i = 0; i < Targets.size(); i++) {
+      llvm::Module *ArchModule = CloneModule(TheModule.get());
+      ArchModule->setTargetTriple(Targets[i]);
+      ArchModule->setDataLayout(TargetInfos[i]->getTargetDescription());
+      Popcorn::AddArchSpecificTargetFeatures(*ArchModule, TargetOpts[i]);
+      LLVMContext &Ctx = ArchModule->getContext();
+      Ctx.setInlineAsmDiagnosticHandler(BitcodeInlineAsmDiagHandler);
+      CodegenBackendOutput(CI.getDiagnostics(), CI.getCodeGenNoOpts(),
+                           *TargetOpts[i], CI.getLangOpts(),
+                           TargetInfos[i]->getTargetDescription(),
+                           ArchModule, BA, OutFiles[i]);
+      delete ArchModule;
+    }
+
+    return;
+  }
+
+  // Otherwise follow the normal AST path.
+  this->ASTFrontendAction::ExecuteAction();
+}
+
Index: lib/CodeGen/CodeGenFunction.h
===================================================================
--- lib/CodeGen/CodeGenFunction.h	(revision 320332)
+++ lib/CodeGen/CodeGenFunction.h	(working copy)
@@ -913,6 +913,15 @@
   llvm::MDNode *createProfileWeightsForLoop(const Stmt *Cond,
                                             uint64_t LoopCount);
 
+  /// \brief Locals that were offloaded to global memory for a captured
+  /// statement and need to be restored after the statement has executed.
+  /// First declaration in the pair is the local, second is the global.
+  /// Maintain a mapping of captured statements & their offloaded locals.
+  typedef std::pair<ValueDecl *, ValueDecl *> OffloadPair;
+  typedef llvm::SmallVector<OffloadPair, 4> OffloadList;
+  typedef llvm::DenseMap<const CapturedStmt *, OffloadList> OffloadMap;
+  OffloadMap OffloadedLocals;
+
 public:
   /// Increment the profiler's counter for the given statement.
   void incrementProfileCounter(const Stmt *S) {
@@ -2084,6 +2093,15 @@
   void EmitCXXForRangeStmt(const CXXForRangeStmt &S,
                            ArrayRef<const Attr *> Attrs = None);
 
+  /// \brief Offload/restore capabilities for local variables captured in
+  /// capture statements.
+  void addOffloaded(const CapturedStmt *S, ValueDecl *L, ValueDecl *G);
+  const OffloadList &getOffloaded(const CapturedStmt *S) const;
+  VarDecl *CreateOffloadedGlobal(const Stmt &S, const Expr *I);
+  LValue GetVarDeclLValue(const Expr *I, VarDecl *VD);
+  DeclRefExpr *GetDeclRefForOffload(ValueDecl *VD);
+  void RestoreOffloadedLocals(const CapturedStmt *S);
+
   LValue InitCapturedStruct(const CapturedStmt &S);
   llvm::Function *EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K);
   void GenerateCapturedStmtFunctionProlog(const CapturedStmt &S);
@@ -2191,6 +2209,10 @@
   ///
   /// \param D Directive (possibly) with the 'linear' clause.
   void EmitOMPLinearClauseInit(const OMPLoopDirective &D);
+  /// \brief Emit prefetching requests for loop directive.
+  ///
+  /// \param D Directive (possibly) with the 'prefetch' clause.
+  void EmitOMPPrefetchClauses(const OMPLoopDirective &D);
 
   void EmitOMPParallelDirective(const OMPParallelDirective &S);
   void EmitOMPSimdDirective(const OMPSimdDirective &S);
Index: lib/CodeGen/PopcornUtil.cpp
===================================================================
--- lib/CodeGen/PopcornUtil.cpp	(nonexistent)
+++ lib/CodeGen/PopcornUtil.cpp	(working copy)
@@ -0,0 +1,103 @@
+//===--- PopcornUtil.cpp - LLVM Popcorn Linux Utilities -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include <clang/CodeGen/PopcornUtil.h>
+#include <llvm/ADT/Triple.h>
+#include <llvm/ADT/SmallVector.h>
+
+using namespace clang;
+using namespace llvm;
+
+const static std::vector<std::string> PopcornSupported = {
+  "aarch64-linux-gnu",
+  "x86_64-linux-gnu"
+};
+
+bool Popcorn::SupportedTarget(const StringRef Target) {
+  for(auto SupportedTarget : PopcornSupported)
+    if(Target == SupportedTarget) return true;
+  return false;
+}
+
+void Popcorn::GetAllTargets(SmallVector<std::string, 2> &Targets) {
+  Targets.clear();
+  for(auto Target : PopcornSupported) Targets.push_back(Target);
+}
+
+typedef std::shared_ptr<TargetOptions> TargetOptionsPtr;
+
+TargetOptionsPtr Popcorn::GetPopcornTargetOpts(const StringRef TripleStr) {
+  Triple Triple(Triple::normalize(TripleStr));
+  assert(!Triple.getTriple().empty() && "Invalid target triple");
+
+  TargetOptionsPtr Opts(new TargetOptions);
+  Opts->Triple = Triple.getTriple();
+  Opts->ABI = "";
+  Opts->FPMath = "";
+  Opts->FeaturesAsWritten.clear();
+  Opts->LinkerVersion = "";
+  Opts->Reciprocals.clear();
+
+  // TODO need to make CPU selectable & add target features according to CPU
+
+  switch(Triple.getArch()) {
+  case Triple::ArchType::aarch64:
+    Opts->ABI = "aapcs";
+    Opts->CPU = "generic";
+    Opts->FeaturesAsWritten.push_back("+neon");
+    break;
+  case Triple::ArchType::x86_64:
+    Opts->CPU = "x86-64";
+    Opts->FPMath = "sse";
+    Opts->FeaturesAsWritten.push_back("+sse");
+    Opts->FeaturesAsWritten.push_back("+sse2");
+    Opts->FeaturesAsWritten.push_back("+rtm");
+    break;
+  default: llvm_unreachable("Triple not currently supported on Popcorn");
+  }
+
+  return Opts;
+}
+
+void Popcorn::StripTargetAttributes(Module &M) {
+  /// Target-specific function attributes
+  static SmallVector<std::string, 2> TargetAttributes = {
+    "target-cpu",
+    "target-features"
+  };
+
+  for(Function &F : M) {
+    AttrBuilder AB(F.getAttributes(), AttributeSet::FunctionIndex);
+    for(std::string &Attr : TargetAttributes) {
+      if(F.hasFnAttribute(Attr))
+        AB.removeAttribute(Attr);
+    }
+    F.setAttributes(
+      AttributeSet::get(F.getContext(), AttributeSet::FunctionIndex, AB));
+  }
+}
+
+void Popcorn::AddArchSpecificTargetFeatures(Module &M,
+                                            TargetOptionsPtr TargetOpts) {
+  static const char *TF = "target-features";
+  std::string AllFeatures("");
+
+  for(auto &Feature : TargetOpts->FeaturesAsWritten)
+    AllFeatures += Feature + ",";
+  AllFeatures = AllFeatures.substr(0, AllFeatures.length() - 1);
+
+  for(Function &F : M) {
+    AttrBuilder AB(F.getAttributes(), AttributeSet::FunctionIndex);
+    assert(!F.hasFnAttribute(TF) && "Target features weren't stripped");
+    AB.addAttribute(TF, AllFeatures);
+    F.setAttributes(
+      AttributeSet::get(F.getContext(), AttributeSet::FunctionIndex, AB));
+  }
+}
+
Index: lib/CodeGen/PrefetchBuilder.cpp
===================================================================
--- lib/CodeGen/PrefetchBuilder.cpp	(nonexistent)
+++ lib/CodeGen/PrefetchBuilder.cpp	(working copy)
@@ -0,0 +1,98 @@
+//=- Prefetch.cpp - Prefetching Analysis for Structured Blocks -----------*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements prefetching analysis for structured blocks.  The
+// analysis traverses the AST to determine how arrays are accessed in structured
+// blocks and generates expressions defining ranges of elements accessed.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/CodeGen/PrefetchBuilder.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/Support/Debug.h"
+
+using namespace clang;
+
+//===----------------------------------------------------------------------===//
+// Prefetch builder API
+//
+
+void PrefetchBuilder::EmitPrefetchCallDeclarations() {
+  using namespace clang::CodeGen;
+  std::vector<llvm::Type *> ParamTypes;
+  llvm::FunctionType *FnType;
+
+  // declare void @popcorn_prefetch(i32, i8*, i8*)
+  ParamTypes = { CGF.Int32Ty, CGF.Int8PtrTy, CGF.Int8PtrTy };
+  FnType = llvm::FunctionType::get(CGF.VoidTy, ParamTypes, false);
+  Prefetch = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch");
+
+  // declare i64 @popcorn_prefetch_execute()
+  ParamTypes.clear();
+  FnType = llvm::FunctionType::get(CGF.Int64Ty, ParamTypes, false);
+  Execute = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch_execute");
+}
+
+static llvm::Constant *getPrefetchKind(CodeGen::CodeGenFunction &CGF,
+                                       enum PrefetchRange::Type Perm) {
+  llvm::Type *Ty = llvm::Type::getInt32Ty(CGF.CurFn->getContext());
+  switch(Perm) {
+  case PrefetchRange::Read: return llvm::ConstantInt::get(Ty, 0);
+  case PrefetchRange::Write: return llvm::ConstantInt::get(Ty, 1);
+  default: llvm_unreachable("Invalid prefetch type\n"); return nullptr;
+  }
+}
+
+Expr *PrefetchBuilder::buildArrayIndexAddress(VarDecl *Base, Expr *Subscript) {
+  // Build DeclRefExpr for variable representing base
+  QualType Ty = Base->getType(), ElemTy;
+  DeclRefExpr *DRE = DeclRefExpr::Create(Ctx, NestedNameSpecifierLoc(),
+                                         SourceLocation(), Base, false,
+                                         Base->getSourceRange().getBegin(),
+                                         Ty, VK_LValue);
+
+  // Get an array subscript, e.g., arr[idx]
+  Ty = Ty.getDesugaredType(Ctx);
+  if(isa<ArrayType>(Ty)) ElemTy = cast<ArrayType>(ElemTy)->getElementType();
+  else ElemTy = cast<PointerType>(Ty)->getPointeeType();
+  Expr *Subscr = new (Ctx) ArraySubscriptExpr(DRE, Subscript, ElemTy, VK_RValue,
+                                              OK_Ordinary, SourceLocation());
+
+  // Get the address of the array index, e.g., &arr[idx]
+  QualType RePtrTy = Ctx.getPointerType(ElemTy);
+  UnaryOperator *Addr = new (Ctx) UnaryOperator(Subscr, UO_AddrOf, RePtrTy,
+                                                VK_LValue, OK_Ordinary,
+                                                SourceLocation());
+
+  // Finally, cast it to a void *, e.g., (void *)&arr[idx]
+  QualType VoidPtrTy = Ctx.getPointerType(Ctx.VoidTy.withConst());
+  return ImplicitCastExpr::Create(Ctx, VoidPtrTy, CK_BitCast, Addr, nullptr,
+                                  VK_RValue);
+}
+
+void PrefetchBuilder::EmitPrefetchCall(const PrefetchRange &P) {
+  Expr *StartAddr, *EndAddr;
+  CodeGen::RValue LoweredStart, LoweredEnd;
+  std::vector<llvm::Value *> Params;
+
+  StartAddr = buildArrayIndexAddress(P.getArray(), P.getStart());
+  EndAddr = buildArrayIndexAddress(P.getArray(), P.getEnd());
+  LoweredStart = CGF.EmitAnyExpr(StartAddr);
+  LoweredEnd = CGF.EmitAnyExpr(EndAddr);
+  Params = { getPrefetchKind(CGF, P.getType()),
+             LoweredStart.getScalarVal(),
+             LoweredEnd.getScalarVal() };
+  CGF.EmitCallOrInvoke(Prefetch, Params);
+}
+
+void PrefetchBuilder::EmitPrefetchExecuteCall() {
+  std::vector<llvm::Value *> Params;
+  CGF.EmitCallOrInvoke(Execute, Params);
+}
+
Index: lib/Driver/Tools.cpp
===================================================================
--- lib/Driver/Tools.cpp	(revision 320332)
+++ lib/Driver/Tools.cpp	(working copy)
@@ -4934,6 +4934,49 @@
       A->render(Args, CmdArgs);
   }
 
+  // Forward Popcorn & other standard compiler flags to -cc1 to generate
+  // multi-ISA binaries
+  if(Args.hasArg(options::OPT_popcorn_migratable) ||
+     Args.hasArg(options::OPT_popcorn_metadata)) {
+    // Full-blown Popcorn migration capabilities, including adding migration
+    // points, symbol alignment and generating stack transformation metadata
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+    CmdArgs.push_back("-popcorn-migratable");
+    CmdArgs.push_back("-mllvm");
+    if(Args.hasArg(options::OPT_popcorn_migratable))
+      CmdArgs.push_back("-popcorn-instrument=migration");
+    else
+      CmdArgs.push_back("-popcorn-instrument=metadata");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-optimize-regalloc");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-fast-isel=false");
+    for(auto Target : Args.getAllArgValues(options::OPT_popcorn_target)) {
+      std::string combined("-popcorn-target=" + Target);
+      CmdArgs.push_back(Args.MakeArgString(combined));
+    }
+  }
+  else if(Args.hasArg(options::OPT_popcorn_libc)) {
+    // Symbol alignment for libc & generate stack transformation metadata for
+    // libc thread start functions
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-popcorn-instrument=libc");
+  }
+  else if(Args.hasArg(options::OPT_popcorn_alignment)) {
+    // Only symbol alignment
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+  }
+
+  if(Args.hasArg(options::OPT_distributed_omp))
+    CmdArgs.push_back("-distributed-omp");
+
   // With -save-temps, we want to save the unoptimized bitcode output from the
   // CompileJobAction, so disable optimizations if they are not already
   // disabled.
Index: lib/Frontend/CompilerInvocation.cpp
===================================================================
--- lib/Frontend/CompilerInvocation.cpp	(revision 320332)
+++ lib/Frontend/CompilerInvocation.cpp	(working copy)
@@ -358,22 +358,11 @@
 
 static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
                              DiagnosticsEngine &Diags,
-                             const TargetOptions &TargetOpts) {
+                             const TargetOptions &TargetOpts,
+                             unsigned OptimizationLevel) {
   using namespace options;
   bool Success = true;
 
-  unsigned OptimizationLevel = getOptimizationLevel(Args, IK, Diags);
-  // TODO: This could be done in Driver
-  unsigned MaxOptLevel = 3;
-  if (OptimizationLevel > MaxOptLevel) {
-    // If the optimization level is not supported, fall back on the default
-    // optimization
-    Diags.Report(diag::warn_drv_optimization_value)
-        << Args.getLastArg(OPT_O)->getAsString(Args) << "-O" << MaxOptLevel;
-    OptimizationLevel = MaxOptLevel;
-  }
-  Opts.OptimizationLevel = OptimizationLevel;
-
   // We must always run at least the always inlining pass.
   Opts.setInlining(
     (Opts.OptimizationLevel > 1) ? CodeGenOptions::NormalInlining
@@ -675,9 +664,41 @@
   Opts.CudaGpuBinaryFileNames =
       Args.getAllArgValues(OPT_fcuda_include_gpubinary);
 
+  Opts.PopcornAlignment = Args.hasArg(OPT_popcorn_alignment);
+  Opts.PopcornMigratable = Args.hasArg(OPT_popcorn_migratable);
+
+  // TODO: the Popcorn compiler doesn't currently support vectorization
+  if(Opts.PopcornMigratable || Args.hasArg(OPT_popcorn_libc)) {
+    Opts.VectorizeBB = 0;
+    Opts.VectorizeLoop = 0;
+    Opts.VectorizeSLP = 0;
+  }
+
+  if(Opts.PopcornMigratable)
+    for(auto Target : Args.getAllArgValues(OPT_popcorn_target))
+      Opts.PopcornTargets.push_back(Target);
+
   return Success;
 }
 
+static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
+                             DiagnosticsEngine &Diags,
+                             const TargetOptions &TargetOpts) {
+  unsigned OptimizationLevel = getOptimizationLevel(Args, IK, Diags);
+  // TODO: This could be done in Driver
+  unsigned MaxOptLevel = 3;
+  if (OptimizationLevel > MaxOptLevel) {
+    // If the optimization level is not supported, fall back on the default
+    // optimization
+    Diags.Report(diag::warn_drv_optimization_value)
+        << Args.getLastArg(OPT_O)->getAsString(Args) << "-O" << MaxOptLevel;
+    OptimizationLevel = MaxOptLevel;
+  }
+  Opts.OptimizationLevel = OptimizationLevel;
+  return ParseCodeGenArgs(Opts, Args, IK, Diags, TargetOpts,
+                          OptimizationLevel);
+}
+
 static void ParseDependencyOutputArgs(DependencyOutputOptions &Opts,
                                       ArgList &Args) {
   using namespace options;
@@ -856,7 +877,11 @@
     case OPT_emit_codegen_only:
       Opts.ProgramAction = frontend::EmitCodeGenOnly; break;
     case OPT_emit_obj:
-      Opts.ProgramAction = frontend::EmitObj; break;
+      if(Args.hasArg(OPT_popcorn_migratable))
+        Opts.ProgramAction = frontend::EmitMultiObj;
+      else
+        Opts.ProgramAction = frontend::EmitObj;
+      break;
     case OPT_fixit_EQ:
       Opts.FixItSuffix = A->getValue();
       // fall-through!
@@ -1704,6 +1729,8 @@
   Opts.SanitizeAddressFieldPadding =
       getLastArgIntValue(Args, OPT_fsanitize_address_field_padding, 0, Diags);
   Opts.SanitizerBlacklistFiles = Args.getAllArgValues(OPT_fsanitize_blacklist);
+
+  Opts.DistributedOmp = Args.hasArg(OPT_distributed_omp);
 }
 
 static void ParsePreprocessorArgs(PreprocessorOptions &Opts, ArgList &Args,
@@ -1803,6 +1830,7 @@
   case frontend::EmitLLVMOnly:
   case frontend::EmitCodeGenOnly:
   case frontend::EmitObj:
+  case frontend::EmitMultiObj:
   case frontend::FixIt:
   case frontend::GenerateModule:
   case frontend::GeneratePCH:
@@ -1890,6 +1918,11 @@
   ParseTargetArgs(Res.getTargetOpts(), Args);
   Success &= ParseCodeGenArgs(Res.getCodeGenOpts(), Args, DashX, Diags,
                               Res.getTargetOpts());
+  // TODO Popcorn: until we can limit optimizations across migration points, we
+  // need to turn off backend optimizations
+  if(Args.hasArg(OPT_popcorn_migratable))
+    Success &= ParseCodeGenArgs(Res.getCodeGenNoOpts(), Args, DashX, Diags,
+                                Res.getTargetOpts(), 0);
   ParseHeaderSearchArgs(Res.getHeaderSearchOpts(), Args);
   if (DashX != IK_AST && DashX != IK_LLVM_IR) {
     ParseLangArgs(*Res.getLangOpts(), Args, DashX, Diags);
Index: lib/FrontendTool/ExecuteCompilerInvocation.cpp
===================================================================
--- lib/FrontendTool/ExecuteCompilerInvocation.cpp	(revision 320332)
+++ lib/FrontendTool/ExecuteCompilerInvocation.cpp	(working copy)
@@ -50,6 +50,7 @@
   case EmitLLVMOnly:           return new EmitLLVMOnlyAction();
   case EmitCodeGenOnly:        return new EmitCodeGenOnlyAction();
   case EmitObj:                return new EmitObjAction();
+  case EmitMultiObj:           return new EmitMultiObjAction();
   case FixIt:                  return new FixItAction();
   case GenerateModule:         return new GenerateModuleAction;
   case GeneratePCH:            return new GeneratePCHAction;
Index: lib/Parse/CMakeLists.txt
===================================================================
--- lib/Parse/CMakeLists.txt	(revision 320332)
+++ lib/Parse/CMakeLists.txt	(working copy)
@@ -23,6 +23,7 @@
 
   LINK_LIBS
   clangAST
+  clangAnalysis
   clangBasic
   clangLex
   clangSema
Index: lib/Parse/ParseOpenMP.cpp
===================================================================
--- lib/Parse/ParseOpenMP.cpp	(revision 320332)
+++ lib/Parse/ParseOpenMP.cpp	(working copy)
@@ -14,6 +14,7 @@
 #include "RAIIObjectsForParser.h"
 #include "clang/AST/ASTConsumer.h"
 #include "clang/AST/ASTContext.h"
+#include "clang/AST/RecursiveASTVisitor.h"
 #include "clang/AST/StmtOpenMP.h"
 #include "clang/Parse/ParseDiagnostic.h"
 #include "clang/Parse/Parser.h"
@@ -25,6 +26,82 @@
 // OpenMP declarative directives.
 //===----------------------------------------------------------------------===//
 
+/// \brief Helper class to find variables declared or used in a statement's
+/// sub-tree.
+class VarFinder : public RecursiveASTVisitor<VarFinder> {
+public:
+  void reset() { Variables.clear(); }
+
+  bool VisitDeclRefExpr(DeclRefExpr *D) {
+    ValueDecl *VD = D->getDecl();
+    if(isa<VarDecl>(VD)) Variables.insert(cast<VarDecl>(VD));
+    return true;
+  }
+
+  bool VisitVarDecl(VarDecl *D) { Variables.insert(D); return true; }
+
+  const llvm::SmallPtrSet<const VarDecl *, 2> &
+  getDeclaredOrReferencedVars() const { return Variables; }
+
+private:
+  llvm::SmallPtrSet<const VarDecl *, 2> Variables;
+};
+
+void Parser::CheckOpenMPPrefetchClauses(StmtResult Directive) {
+  VarFinder CapturedVarFinder, LoopVarFinder, UseFinder;
+
+  OMPLoopDirective *D = dyn_cast<OMPLoopDirective>(Directive.get());
+  if(D) {
+    // OpenMP Standard 4.5, Section 2.6:
+    // A loop has canonical loop form if it conforms to the following:
+    //    for (init-expr; test-expr; incr-expr) structured-block
+    //      init-expr     One of the following:
+    //                    var = lb
+    //                    integer-type var = lb
+    //                    random-access-iterator-type var = lb
+    //                    pointer-type var = lb
+    //
+    // Thus we can examine the initialization statement to find the loop
+    // iteration variable.
+    CapturedStmt *Captured = cast<CapturedStmt>(D->getAssociatedStmt());
+    ForStmt *For = cast<ForStmt>(Captured->getCapturedStmt());
+    BinaryOperator *InitExpr = cast<BinaryOperator>(For->getInit());
+
+    // Find captured & loop iteration variables
+    CapturedVarFinder.TraverseStmt(Captured);
+    const llvm::SmallPtrSet<const VarDecl *, 2> &CapturedVars =
+      CapturedVarFinder.getDeclaredOrReferencedVars();
+    LoopVarFinder.TraverseStmt(InitExpr);
+    const llvm::SmallPtrSet<const VarDecl *, 2> &LoopVars =
+      LoopVarFinder.getDeclaredOrReferencedVars();
+
+    for(auto &&I = D->getClausesOfKind(OMPC_prefetch); I; ++I) {
+      auto *C = cast<OMPPrefetchClause>(*I);
+
+      // Verify we're only prefetching captured variables
+      for(auto E : C->varlists()) {
+        UseFinder.reset();
+        // TODO this cast is nasty
+        UseFinder.TraverseStmt((Expr *)E);
+        for(const auto &V : UseFinder.getDeclaredOrReferencedVars())
+          if(!CapturedVars.count(V))
+            Diag(E->getExprLoc(), diag::err_omp_invalid_prefetch_capture);
+      }
+
+      // Verify loop iteration variable use
+      Expr *Start = C->getStartOfRange(), *End = C->getEndOfRange();
+      if(Start && !End) {
+        UseFinder.reset();
+        UseFinder.TraverseStmt(Start);
+
+        for(const auto &V : UseFinder.getDeclaredOrReferencedVars())
+          if(!LoopVars.count(V)) Diag(C->getFirstColonLoc(),
+                                      diag::err_omp_invalid_prefetch_loop_var);
+      }
+    }
+  }
+}
+
 static OpenMPDirectiveKind ParseOpenMPDirectiveKind(Parser &P) {
   // Array of foldings: F[i][0] F[i][1] ===> F[i][2].
   // E.g.: OMPD_for OMPD_simd ===> OMPD_for_simd
@@ -294,6 +371,21 @@
           DKind, DirName, CancelRegion, Clauses, AssociatedStmt.get(), Loc,
           EndLoc);
 
+    // Enable optimizations for Popcorn Linux, if requested.
+    if(PP.getLangOpts().DistributedOmp) {
+      if((DKind == OMPD_parallel || DKind == OMPD_parallel_for ||
+          DKind == OMPD_parallel_for_simd || DKind == OMPD_parallel_sections)) {
+        CapturedStmt *CS = cast<CapturedStmt>(AssociatedStmt.get());
+        CS->setOffloadShared(true);
+      }
+
+      if(DKind == OMPD_for || DKind == OMPD_parallel_for ||
+         DKind == OMPD_parallel_for_simd) {
+        cast<OMPExecutableDirective>(Directive.get())->setPrefetching(true);
+        CheckOpenMPPrefetchClauses(Directive);
+      }
+    }
+
     // Exit scope.
     Actions.EndOpenMPDSABlock(Directive.get());
     OMPDirectiveScope.Exit();
@@ -385,7 +477,7 @@
 ///       lastprivate-clause | reduction-clause | proc_bind-clause |
 ///       schedule-clause | copyin-clause | copyprivate-clause | untied-clause |
 ///       mergeable-clause | flush-clause | read-clause | write-clause |
-///       update-clause | capture-clause | seq_cst-clause
+///       update-clause | capture-clause | seq_cst-clause | prefetch-clause
 ///
 OMPClause *Parser::ParseOpenMPClause(OpenMPDirectiveKind DKind,
                                      OpenMPClauseKind CKind, bool FirstClause) {
@@ -479,6 +571,7 @@
   case OMPC_copyprivate:
   case OMPC_flush:
   case OMPC_depend:
+  case OMPC_prefetch:
     Clause = ParseOpenMPVarListClause(CKind);
     break;
   case OMPC_unknown:
@@ -702,17 +795,20 @@
 ///       'flush' '(' list ')'
 ///    depend-clause:
 ///       'depend' '(' in | out | inout : list ')'
+///    prefetch-clause:
+///       'prefetch' '(' read | write ':' list [ ':' start ':' end ] ')'
 ///
 OMPClause *Parser::ParseOpenMPVarListClause(OpenMPClauseKind Kind) {
   SourceLocation Loc = Tok.getLocation();
   SourceLocation LOpen = ConsumeToken();
-  SourceLocation ColonLoc = SourceLocation();
+  SourceLocation ColonLoc = SourceLocation(), EndColonLoc = SourceLocation();
   // Optional scope specifier and unqualified id for reduction identifier.
   CXXScopeSpec ReductionIdScopeSpec;
   UnqualifiedId ReductionId;
   bool InvalidReductionId = false;
   OpenMPDependClauseKind DepKind = OMPC_DEPEND_unknown;
-  SourceLocation DepLoc;
+  OpenMPPrefetchClauseKind PrefKind = OMPC_PREFETCH_unknown;
+  SourceLocation DepLoc, PrefLoc;
 
   // Parse '('.
   BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
@@ -755,6 +851,20 @@
     } else {
       Diag(Tok, diag::warn_pragma_expected_colon) << "dependency type";
     }
+  } else if (Kind == OMPC_prefetch) {
+  // Handle permission type for prefetch clause.
+    ColonProtectionRAIIObject ColonRAII(*this);
+    PrefKind = static_cast<OpenMPPrefetchClauseKind>(getOpenMPSimpleClauseType(
+        Kind, Tok.is(tok::identifier) ? PP.getSpelling(Tok) : ""));
+    PrefLoc = Tok.getLocation();
+
+    if (PrefKind == OMPC_PREFETCH_unknown) {
+      SkipUntil(tok::r_paren, tok::annot_pragma_openmp_end, StopBeforeMatch);
+      Diag(PrefLoc, diag::err_omp_invalid_prefetch_kind) << true;
+    } else {
+      ConsumeToken(); // Keyword
+      ConsumeToken(); // Colon
+    }
   }
 
   SmallVector<Expr *, 5> Vars;
@@ -761,7 +871,8 @@
   bool IsComma = ((Kind != OMPC_reduction) && (Kind != OMPC_depend)) ||
                  ((Kind == OMPC_reduction) && !InvalidReductionId) ||
                  ((Kind == OMPC_depend) && DepKind != OMPC_DEPEND_unknown);
-  const bool MayHaveTail = (Kind == OMPC_linear || Kind == OMPC_aligned);
+  const bool MayHaveTail = (Kind == OMPC_linear || Kind == OMPC_aligned ||
+                            Kind == OMPC_prefetch);
   while (IsComma || (Tok.isNot(tok::r_paren) && Tok.isNot(tok::colon) &&
                      Tok.isNot(tok::annot_pragma_openmp_end))) {
     ColonProtectionRAIIObject ColonRAII(*this, MayHaveTail);
@@ -787,9 +898,9 @@
           << (Kind == OMPC_flush);
   }
 
-  // Parse ':' linear-step (or ':' alignment).
+  // Parse ':' linear-step, ':' alignment, or ':' start.
   Expr *TailExpr = nullptr;
-  const bool MustHaveTail = MayHaveTail && Tok.is(tok::colon);
+  const bool MustHaveTail = (MayHaveTail && Tok.is(tok::colon));
   if (MustHaveTail) {
     ColonLoc = Tok.getLocation();
     ConsumeToken();
@@ -802,6 +913,20 @@
                 StopBeforeMatch);
   }
 
+  // Parse ':' end.
+  Expr *EndExpr = nullptr;
+  if (Kind == OMPC_prefetch && Tok.is(tok::colon)) {
+    EndColonLoc = Tok.getLocation();
+    ConsumeToken();
+    ExprResult Tail =
+        Actions.CorrectDelayedTyposInExpr(ParseAssignmentExpression());
+    if (Tail.isUsable())
+      EndExpr = Tail.get();
+    else
+      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                StopBeforeMatch);
+  }
+
   // Parse ')'.
   T.consumeClose();
   if ((Kind == OMPC_depend && DepKind != OMPC_DEPEND_unknown && Vars.empty()) ||
@@ -810,10 +935,10 @@
     return nullptr;
 
   return Actions.ActOnOpenMPVarListClause(
-      Kind, Vars, TailExpr, Loc, LOpen, ColonLoc, Tok.getLocation(),
-      ReductionIdScopeSpec,
+      Kind, Vars, TailExpr, EndExpr, Loc, LOpen, ColonLoc, EndColonLoc,
+      Tok.getLocation(), ReductionIdScopeSpec,
       ReductionId.isValid() ? Actions.GetNameFromUnqualifiedId(ReductionId)
                             : DeclarationNameInfo(),
-      DepKind, DepLoc);
+      DepKind, DepLoc, PrefKind, PrefLoc);
 }
 
Index: lib/Parse/ParsePragma.cpp
===================================================================
--- lib/Parse/ParsePragma.cpp	(revision 320332)
+++ lib/Parse/ParsePragma.cpp	(working copy)
@@ -156,6 +156,23 @@
                     Token &FirstToken) override;
 };
 
+struct PragmaNoPopcornHandler: public PragmaHandler {
+  PragmaNoPopcornHandler() : PragmaHandler("popcorn") {}
+  void HandlePragma(Preprocessor &PP,  PragmaIntroducerKind Introducer,
+                    Token &FirstToken) override;
+};
+
+struct PragmaPopcornHandler : public PragmaHandler {
+  enum Type {
+    Prefetch, // Prefetch for the statement following the pragma
+    None      // Unknown pragma type
+  };
+
+  PragmaPopcornHandler() : PragmaHandler("popcorn") {}
+  void HandlePragma(Preprocessor &PP, PragmaIntroducerKind Introducer,
+                    Token &FirstToken) override;
+};
+
 }  // end namespace
 
 void Parser::initializePragmaHandlers() {
@@ -235,6 +252,12 @@
 
   NoUnrollHintHandler.reset(new PragmaUnrollHintHandler("nounroll"));
   PP.AddPragmaHandler(NoUnrollHintHandler.get());
+
+  if (getLangOpts().DistributedOmp)
+    PopcornHandler.reset(new PragmaPopcornHandler());
+  else
+    PopcornHandler.reset(new PragmaNoPopcornHandler());
+  PP.AddPragmaHandler(PopcornHandler.get());
 }
 
 void Parser::resetPragmaHandlers() {
@@ -304,6 +327,9 @@
 
   PP.RemovePragmaHandler(NoUnrollHintHandler.get());
   NoUnrollHintHandler.reset();
+
+  PP.RemovePragmaHandler(PopcornHandler.get());
+  PopcornHandler.reset();
 }
 
 /// \brief Handle the annotation token produced for #pragma unused(...)
@@ -868,6 +894,108 @@
   return true;
 }
 
+enum PopcornClauseKind {
+  PC_PrefetchIgnore, // Ignore array/pointer variable during prefetch analysis
+  PC_Unknown          // Unknown clause type
+};
+
+static const char *getPopcornClauseName(enum PopcornClauseKind K) {
+  switch(K) {
+  default: return "unknown";
+  case PC_PrefetchIgnore: return "ignore";
+  }
+}
+
+static enum PopcornClauseKind getPopcornClauseKind(llvm::StringRef Name) {
+  return llvm::StringSwitch<PopcornClauseKind>(Name)
+    .Case("ignore", PC_PrefetchIgnore)
+    .Default(PC_Unknown);
+}
+
+void Parser::ParseVarList(llvm::SmallPtrSet<VarDecl *, 4> &Vars) {
+  bool isComma = false;
+  DeclRefExpr *D;
+  VarDecl *VD;
+
+  while(isComma || (Tok.isNot(tok::r_paren) &&
+                    Tok.isNot(tok::annot_pragma_popcorn_prefetch_end))) {
+    // Parse variable
+    ExprResult VarExpr =
+      Actions.CorrectDelayedTyposInExpr(ParseAssignmentExpression());
+
+    if(VarExpr.isUsable()) {
+      Expr *E = VarExpr.get();
+      if((D = dyn_cast<DeclRefExpr>(E)) &&
+         (VD = dyn_cast<VarDecl>(D->getDecl())))
+        Vars.insert(VD);
+      else {
+        PP.Diag(E->getLocStart(), diag::err_pragma_popcorn_expected_var_name);
+        SkipUntil(tok::comma, tok::r_paren,
+                  tok::annot_pragma_popcorn_prefetch_end);
+      }
+    }
+
+    // Parse ',' if any
+    isComma = Tok.is(tok::comma);
+    if(isComma) ConsumeToken();
+  }
+}
+
+StmtResult Parser::HandlePragmaPopcorn() {
+  llvm::SmallPtrSet<VarDecl *, 4> Ignore;
+
+  assert(Tok.is(tok::annot_pragma_popcorn_prefetch));
+  ConsumeToken(); // The annotation token.
+
+  while(Tok.isNot(tok::annot_pragma_popcorn_prefetch_end)) {
+    // Parse clause type.
+    enum PopcornClauseKind Kind = getPopcornClauseKind(PP.getSpelling(Tok));
+    if(Kind == PC_Unknown) {
+      PP.Diag(Tok.getLocation(),
+              diag::err_pragma_popcorn_invalid_clause) << PP.getSpelling(Tok);
+      SkipUntil(tok::r_paren, tok::annot_pragma_popcorn_prefetch_end,
+                Parser::StopBeforeMatch);
+      continue;
+    }
+    ConsumeToken();
+
+    // Parse '('.
+    BalancedDelimiterTracker T(*this, tok::l_paren,
+                               tok::annot_pragma_popcorn_prefetch_end);
+    if(T.expectAndConsume(diag::err_expected_lparen_after,
+                          getPopcornClauseName(Kind)))
+      return StmtError();
+
+    switch(Kind) {
+    default: llvm_unreachable("Unknown '#pragma popcorn' clause type"); break;
+    case PC_PrefetchIgnore: ParseVarList(Ignore); break;
+    }
+
+    // Parse ')'.
+    T.consumeClose();
+  }
+  ConsumeToken(); // Consume final token.
+
+  StmtResult R = ParseStatement();
+
+  if(R.isInvalid()) return StmtError();
+  else if(isa<ForStmt>(R.get())) {
+    ASTContext &Ctx = getActions().getASTContext();
+    ForStmt *S = cast<ForStmt>(R.get());
+    S->setPrefetchEnabled(true);
+    PrefetchAnalysis PA(&Ctx, R.get());
+    PA.ignoreVars(Ignore);
+    PA.analyzeStmt();
+    // TODO remove
+    PA.dump();
+    Ctx.addPrefetchAnalysis(R.get(), PA);
+  }
+  else PP.Diag(R.get()->getLocStart(),
+               diag::warn_pragma_popcorn_prefetch_invalid_stmt);
+
+  return R;
+}
+
 // #pragma GCC visibility comes in two variants:
 //   'push' '(' [visibility] ')'
 //   'pop'
@@ -1458,10 +1586,10 @@
 PragmaNoOpenMPHandler::HandlePragma(Preprocessor &PP,
                                     PragmaIntroducerKind Introducer,
                                     Token &FirstTok) {
-  if (!PP.getDiagnostics().isIgnored(diag::warn_pragma_omp_ignored,
+  if (!PP.getDiagnostics().isIgnored(diag::warn_pragma_popcorn_ignored,
                                      FirstTok.getLocation())) {
-    PP.Diag(FirstTok, diag::warn_pragma_omp_ignored);
-    PP.getDiagnostics().setSeverity(diag::warn_pragma_omp_ignored,
+    PP.Diag(FirstTok, diag::warn_pragma_popcorn_ignored);
+    PP.getDiagnostics().setSeverity(diag::warn_pragma_popcorn_ignored,
                                     diag::Severity::Ignored, SourceLocation());
   }
   PP.DiscardUntilEndOfDirective();
@@ -2119,3 +2247,66 @@
   PP.EnterTokenStream(TokenArray, 1, /*DisableMacroExpansion=*/false,
                       /*OwnsTokens=*/true);
 }
+
+void PragmaNoPopcornHandler::HandlePragma(Preprocessor &PP,
+                                          PragmaIntroducerKind Introducer,
+                                          Token &Tok) {
+  if (!PP.getDiagnostics().isIgnored(diag::warn_pragma_omp_ignored,
+                                     Tok.getLocation())) {
+    PP.Diag(Tok, diag::warn_pragma_omp_ignored);
+    PP.getDiagnostics().setSeverity(diag::warn_pragma_omp_ignored,
+                                    diag::Severity::Ignored, SourceLocation());
+  }
+  PP.DiscardUntilEndOfDirective();
+}
+
+void PragmaPopcornHandler::HandlePragma(Preprocessor &PP,
+                                        PragmaIntroducerKind Introducer,
+                                        Token &Tok) {
+  // Incoming token is "popcorn" for "#pragma popcorn".
+  PP.Lex(Tok);
+  if (Tok.isNot(tok::identifier)) {
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_popcorn_no_arg);
+    return;
+  }
+
+  IdentifierInfo *OptionInfo = Tok.getIdentifierInfo();
+  enum PragmaPopcornHandler::Type Ty =
+    llvm::StringSwitch<enum PragmaPopcornHandler::Type>(OptionInfo->getName())
+                             .Case("prefetch", PragmaPopcornHandler::Prefetch)
+                             .Default(PragmaPopcornHandler::None);
+  if (Ty == PragmaPopcornHandler::None) {
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_popcorn_invalid_option)
+        << OptionInfo->getName();
+    return;
+  }
+
+  switch(Ty) {
+  default: llvm_unreachable("Should have weeded out invalid types"); break;
+  case PragmaPopcornHandler::Prefetch: {
+    // Capture all tokens to be included for prefetching analysis.
+    SmallVector<Token, 16> Pragma;
+    Token NextTok;
+
+    NextTok.startToken();
+    NextTok.setKind(tok::annot_pragma_popcorn_prefetch);
+    NextTok.setLocation(Tok.getLocation());
+    while (NextTok.isNot(tok::eod)) {
+      Pragma.push_back(NextTok);
+      PP.Lex(NextTok);
+    }
+    SourceLocation EodLoc = NextTok.getLocation();
+    NextTok.startToken();
+    NextTok.setKind(tok::annot_pragma_popcorn_prefetch_end);
+    NextTok.setLocation(EodLoc);
+    Pragma.push_back(NextTok);
+
+    Token *Toks = new Token[Pragma.size()];
+    std::copy(Pragma.begin(), Pragma.end(), Toks);
+    PP.EnterTokenStream(Toks, Pragma.size(),
+                        /*DisableMacroExpansion=*/false, /*OwnsTokens=*/true);
+    break;
+  }
+  }
+}
+
Index: lib/Parse/ParseStmt.cpp
===================================================================
--- lib/Parse/ParseStmt.cpp	(revision 320332)
+++ lib/Parse/ParseStmt.cpp	(working copy)
@@ -357,6 +357,9 @@
   case tok::annot_pragma_loop_hint:
     ProhibitAttributes(Attrs);
     return ParsePragmaLoopHint(Stmts, OnlyStatement, TrailingElseLoc, Attrs);
+
+  case tok::annot_pragma_popcorn_prefetch:
+    return HandlePragmaPopcorn();
   }
 
   // If we reached this code, the statement must end in a semicolon.
Index: lib/Sema/CMakeLists.txt
===================================================================
--- lib/Sema/CMakeLists.txt	(revision 320332)
+++ lib/Sema/CMakeLists.txt	(working copy)
@@ -11,6 +11,9 @@
   IdentifierResolver.cpp
   JumpDiagnostics.cpp
   MultiplexExternalSemaSource.cpp
+  PrefetchAnalysis.cpp
+  PrefetchDataflow.cpp
+  PrefetchExprBuilder.cpp
   Scope.cpp
   ScopeInfo.cpp
   Sema.cpp
Index: lib/Sema/PrefetchAnalysis.cpp
===================================================================
--- lib/Sema/PrefetchAnalysis.cpp	(nonexistent)
+++ lib/Sema/PrefetchAnalysis.cpp	(working copy)
@@ -0,0 +1,873 @@
+//=- PrefetchAnalysis.cpp - Prefetching Analysis for Structured Blocks ---*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements prefetching analysis for structured blocks.  The
+// analysis traverses the AST to determine how arrays are accessed in structured
+// blocks and generates expressions defining ranges of elements accessed.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/Sema/PrefetchAnalysis.h"
+#include "clang/Sema/PrefetchDataflow.h"
+#include "clang/Sema/PrefetchExprBuilder.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/Support/Debug.h"
+
+using namespace clang;
+
+//===----------------------------------------------------------------------===//
+// PrefetchRange API
+//
+
+bool PrefetchRange::equalExceptType(const PrefetchRange &RHS) {
+  if(Array != RHS.Array) return false;
+  else if(!PrefetchExprEquality::exprEqual(Start, RHS.Start)) return false;
+  else if(!PrefetchExprEquality::exprEqual(End, RHS.End)) return false;
+  else return true;
+}
+
+bool PrefetchRange::operator==(const PrefetchRange &RHS) {
+  if(Ty == RHS.Ty && equalExceptType(RHS)) return true;
+  else return false;
+}
+
+//===----------------------------------------------------------------------===//
+// Common utilities
+//
+
+/// Return whether a type is both scalar and integer.
+bool PrefetchAnalysis::isScalarIntType(const QualType &Ty) {
+  return Ty->isIntegerType() && Ty->isScalarType();
+}
+
+/// Get the size in bits for builtin integer types.
+unsigned PrefetchAnalysis::getTypeSize(BuiltinType::Kind K) {
+  switch(K) {
+  case BuiltinType::Bool:
+  case BuiltinType::Char_U: case BuiltinType::UChar:
+  case BuiltinType::Char_S: case BuiltinType::SChar:
+    return 8;
+  case BuiltinType::WChar_U: case BuiltinType::Char16:
+  case BuiltinType::UShort:
+  case BuiltinType::WChar_S:
+  case BuiltinType::Short:
+    return 16;
+  case BuiltinType::Char32:
+  case BuiltinType::UInt:
+  case BuiltinType::Int:
+    return 32;
+  case BuiltinType::ULong:
+  case BuiltinType::ULongLong:
+  case BuiltinType::Long:
+  case BuiltinType::LongLong:
+    return 64;
+  case BuiltinType::UInt128:
+  case BuiltinType::Int128:
+    return 128;
+  default: return UINT32_MAX;
+  }
+}
+
+/// Return the variable declaration if the declared value is a variable and if
+/// it is a scalar integer type or nullptr otherwise.
+VarDecl *PrefetchAnalysis::getVarIfScalarInt(ValueDecl *VD) {
+  if(isa<VarDecl>(VD)) {
+    VarDecl *Var = cast<VarDecl>(VD);
+    if(isScalarIntType(Var->getType())) return Var;
+  }
+  return nullptr;
+}
+
+// Filter functions to only select appropriate operator types.  Return true if
+// the operator is of a type that should be analyzed, or false otherwise.
+typedef bool (*UnaryOpFilter)(UnaryOperator::Opcode);
+typedef bool (*BinaryOpFilter)(BinaryOperator::Opcode);
+
+// Don't analyze *any* operation types.
+bool NoUnaryOp(UnaryOperator::Opcode Op) { return false; }
+bool NoBinaryOp(BinaryOperator::Opcode Op) { return false; }
+
+// Filter out non-assignment binary operations.
+static bool FilterAssignOp(BinaryOperator::Opcode Op) {
+  switch(Op) {
+  case BO_Assign: case BO_MulAssign: case BO_DivAssign: case BO_RemAssign:
+  case BO_AddAssign: case BO_SubAssign: case BO_ShlAssign: case BO_ShrAssign:
+  case BO_AndAssign: case BO_XorAssign: case BO_OrAssign:
+    return true;
+  default: return false;
+  }
+}
+
+// Filter out non-relational binary operations.
+static bool FilterRelationalOp(BinaryOperator::Opcode Op) {
+  switch(Op) {
+  case BO_LT: case BO_GT: case BO_LE: case BO_GE: case BO_EQ: case BO_NE:
+    return true;
+  default: return false;
+  }
+}
+
+// Filter out non-math/logic binary operations.
+static bool FilterMathLogicOp(BinaryOperator::Opcode Op) {
+  switch(Op) {
+  case BO_Mul: case BO_Div: case BO_Rem: case BO_Add: case BO_Sub:
+  case BO_Shl: case BO_Shr: case BO_And: case BO_Xor: case BO_Or:
+    return true;
+  default: return false;
+  }
+}
+
+// Filter out non-math unary operations.
+static bool FilterMathOp(UnaryOperator::Opcode Op) {
+  switch(Op) {
+  case UO_PostInc: case UO_PostDec: case UO_PreInc: case UO_PreDec:
+    return true;
+  default: return false;
+  }
+}
+
+/// Return the statement if it is a scoping statement (e.g., for-loop) or
+/// nullptr otherwise.
+static bool isScopingStmt(Stmt *S) {
+  if(isa<CapturedStmt>(S) || isa<CompoundStmt>(S) || isa<CXXCatchStmt>(S) ||
+     isa<CXXForRangeStmt>(S) || isa<CXXTryStmt>(S) || isa<DoStmt>(S) ||
+     isa<ForStmt>(S) || isa<IfStmt>(S) || isa<OMPExecutableDirective>(S) ||
+     isa<SwitchStmt>(S) || isa<WhileStmt>(S)) return true;
+  else return false;
+}
+
+/// A vector of variable declarations.
+typedef llvm::SmallVector<VarDecl *, 4> VarVec;
+
+//===----------------------------------------------------------------------===//
+// Prefetch analysis -- array accesses
+//
+
+/// Scoping information for array analyses.  A node in a singly-linked list
+/// which allows traversal from innermost scope outwards.  Nodes are reference
+/// counted, so when array accesses which reference the scope (if any) are
+/// deleted, the scoping chain itself gets deleted.
+struct ScopeInfo {
+  Stmt *ScopeStmt;                        // Statement providing scope
+  std::shared_ptr<ScopeInfo> ParentScope; // The parent in the scope chain
+  ScopeInfo(Stmt *ScopeStmt, std::shared_ptr<ScopeInfo> &ParentScope)
+    : ScopeStmt(ScopeStmt), ParentScope(ParentScope) {}
+};
+typedef std::shared_ptr<ScopeInfo> ScopeInfoPtr;
+
+/// An array access.
+class ArrayAccess {
+public:
+  ArrayAccess(PrefetchRange::Type Ty, ArraySubscriptExpr *S,
+              const ScopeInfoPtr &AccessScope)
+    : Valid(true), Ty(Ty), S(S), Base(nullptr), Idx(S->getIdx()),
+      AccessScope(AccessScope) {
+    DeclRefExpr *DR;
+    VarDecl *VD;
+
+    if(!(DR = dyn_cast<DeclRefExpr>(S->getBase()->IgnoreImpCasts()))) {
+      Valid = false;
+      return;
+    }
+
+    if(!(VD = dyn_cast<VarDecl>(DR->getDecl()))) {
+      Valid = false;
+      return;
+    }
+
+    Base = VD;
+  }
+
+  bool isValid() const { return Valid; }
+  Stmt *getStmt() const { return S; }
+  PrefetchRange::Type getAccessType() const { return Ty; }
+  VarDecl *getBase() const { return Base; }
+  Expr *getIndex() const { return Idx; }
+  const VarVec &getVarsInIdx() const { return VarsInIdx; }
+  const ScopeInfoPtr &getScope() const { return AccessScope; }
+
+  void setInvalid() { Valid = false; }
+  void addVarInIdx(VarDecl *V) { if(V != Base) VarsInIdx.push_back(V); }
+
+  void print(llvm::raw_ostream &O, PrintingPolicy &Policy) const {
+    O << "Array: " << Base->getName() << "\nIndex expression: ";
+    Idx->printPretty(O, nullptr, Policy);
+    O << "\nScoping statement:\n";
+    AccessScope->ScopeStmt->printPretty(O, nullptr, Policy);
+    O << "\nVariables used in index calculation:";
+    for(auto Var : VarsInIdx) O << " " << Var->getName();
+    O << "\n";
+  }
+  void dump(PrintingPolicy &Policy) const { print(llvm::dbgs(), Policy); }
+
+private:
+  bool Valid;               // Is the access valid?
+  PrefetchRange::Type Ty;   // The type of access
+  Stmt *S;                  // The entire array access statement
+  VarDecl *Base;            // The array base
+  Expr *Idx;                // Expression used to calculate index
+  VarVec VarsInIdx;         // Variables used in index calculation
+  ScopeInfoPtr AccessScope; // Scope of the array access
+};
+
+/// Traverse a statement looking for array accesses.
+// TODO *** NEED TO LIMIT TO AFFINE ACCESSES ***
+class ArrayAccessPattern : public RecursiveASTVisitor<ArrayAccessPattern> {
+public:
+  ArrayAccessPattern(llvm::SmallPtrSet<VarDecl *, 4> &Ignore)
+    : Ignore(Ignore) {}
+
+  /// Which sub-tree of a binary operator we're traversing.  This determines
+  /// whether we're reading or writing the array.
+  enum TraverseStructure { LHS, RHS };
+
+  void InitTraversal() {
+    Side.push_back(RHS);
+    CurAccess = nullptr;
+  }
+
+  /// Traverse a statement.  There's a couple of special traversal rules:
+  ///
+  ///  - If it's a scoping statement, add an enclosing scope to the scope chain
+  //     before traversing the sub-tree
+  ///  - If it's an assignment operation, record structure of the traversal
+  ///    before visiting each of the left & right sub-trees
+  ///  - If it's an array subscript, record all variables used to calculate
+  ///    the index
+  bool TraverseStmt(Stmt *S) {
+    if(!S) return true;
+
+    bool isScope = isScopingStmt(S);
+    BinaryOperator *BinOp = dyn_cast<BinaryOperator>(S);
+    ArraySubscriptExpr *Subscript = dyn_cast<ArraySubscriptExpr>(S);
+
+    if(isScope) CurScope = ScopeInfoPtr(new ScopeInfo(S, CurScope));
+
+    if(BinOp && FilterAssignOp(BinOp->getOpcode())) {
+      // For assignment operations, LHS = write and RHS = read
+      Side.push_back(LHS);
+      TraverseStmt(BinOp->getLHS());
+      Side.pop_back();
+      Side.push_back(RHS);
+      TraverseStmt(BinOp->getRHS());
+      Side.pop_back();
+    }
+    else if(Subscript) {
+      // TODO doesn't work for nested accesses, e.g., a[b[i]]
+      RecursiveASTVisitor<ArrayAccessPattern>::TraverseStmt(S);
+      CurAccess = nullptr; // Don't record any more variables
+    }
+    else RecursiveASTVisitor<ArrayAccessPattern>::TraverseStmt(S);
+
+    if(isScope) CurScope = CurScope->ParentScope;
+
+    return true;
+  }
+
+  /// Analyze an array access; in particular, the index.
+  bool VisitArraySubscriptExpr(ArraySubscriptExpr *Sub) {
+    PrefetchRange::Type Ty =
+      (Side.back() == LHS ? PrefetchRange::Write : PrefetchRange::Read);
+    ArrayAccess Access(Ty, Sub, CurScope);
+    if(!Access.isValid() || Ignore.count(Access.getBase())) return true;
+    ArrayAccesses.emplace_back(std::move(Access));
+    CurAccess = &ArrayAccesses.back();
+    return true;
+  }
+
+  /// Record any variables seen during traversing
+  bool VisitDeclRefExpr(DeclRefExpr *DR) {
+    if(CurAccess && CurAccess) {
+      VarDecl *VD = dyn_cast<VarDecl>(DR->getDecl());
+      if(VD) CurAccess->addVarInIdx(VD);
+      else {
+        // Can't analyze if decl != variable
+        CurAccess->setInvalid();
+        CurAccess = nullptr;
+        ArrayAccesses.pop_back();
+      }
+    }
+    return true;
+  }
+
+  const llvm::SmallVector<ArrayAccess, 8> &getArrayAccesses() const
+  { return ArrayAccesses; }
+
+private:
+  llvm::SmallVector<ArrayAccess, 8> ArrayAccesses;
+  ScopeInfoPtr CurScope;
+  llvm::SmallPtrSet<VarDecl *, 4> &Ignore;
+
+  // Traversal state
+  llvm::SmallVector<enum TraverseStructure, 8> Side;
+  ArrayAccess *CurAccess;
+};
+
+void PrefetchAnalysis::mergeArrayAccesses() {
+  // TODO!
+}
+
+void PrefetchAnalysis::pruneArrayAccesses() {
+  // TODO we could prevent a bunch of copying if we used a linked list instead
+  // of a vector for ToPrefetch
+  llvm::SmallVector<PrefetchRange, 8>::iterator Cur, Next;
+  for(Cur = ToPrefetch.begin(); Cur != ToPrefetch.end(); Cur++) {
+    if(PrefetchExprEquality::exprEqual(Cur->getStart(), Cur->getEnd()))
+      Cur = ToPrefetch.erase(Cur) - 1;
+  }
+
+  for(Cur = ToPrefetch.begin(); Cur != ToPrefetch.end(); Cur++) {
+    for(Next = Cur + 1; Next != ToPrefetch.end(); Next++) {
+      if(*Cur == *Next) Next = ToPrefetch.erase(Next) - 1;
+      else if(Cur->equalExceptType(*Next)) {
+        Cur->setType(Cur->getType() > Next->getType() ? Cur->getType() :
+                                                        Next->getType());
+        Next = ToPrefetch.erase(Next) - 1;
+      }
+    }
+  }
+}
+
+//===----------------------------------------------------------------------===//
+// Prefetch analysis -- ForStmts
+//
+
+/// An induction variable and expressions describing its range.
+class InductionVariable {
+public:
+  /// The direction of change for the induction variable
+  enum Direction {
+    Increases, // Update changes variable from lower to higher values
+    Decreases, // Update changes variable from higher to lower values
+    Unknown // Update has an unknown effect, e.g., container interators
+  };
+
+  InductionVariable() : Var(nullptr), Init(nullptr), Cond(nullptr),
+                        Update(nullptr), Dir(Unknown), LowerB(nullptr),
+                        UpperB(nullptr) {}
+
+  InductionVariable(VarDecl *Var, Expr *Init, Expr *Cond, Expr *Update,
+                    ASTContext *Ctx)
+    : Var(Var), Init(Init), Cond(Cond), Update(Update), Dir(Unknown),
+      LowerB(nullptr), UpperB(nullptr) {
+
+    PrefetchExprBuilder::Modifier UpperMod, LowerMod;
+    const UnaryOperator *Unary;
+
+    assert(PrefetchAnalysis::isScalarIntType(Var->getType()) &&
+           "Invalid induction variable");
+
+    // Try to classify update direction to determine which expression specifies
+    // lower and upper bounds
+    if((Unary = dyn_cast<UnaryOperator>(Update)))
+      Dir = classifyUnaryOpDirection(Unary->getOpcode());
+
+    if(Dir == Increases) {
+      LowerMod.ClassifyModifier(Init, Ctx);
+      UpperMod.ClassifyModifier(Cond, Ctx);
+      LowerB = stripInductionVar(Init);
+      UpperB = stripInductionVar(Cond);
+    }
+    else if(Dir == Decreases) {
+      LowerMod.ClassifyModifier(Cond, Ctx);
+      UpperMod.ClassifyModifier(Init, Ctx);
+      LowerB = stripInductionVar(Cond);
+      UpperB = stripInductionVar(Init);
+    }
+
+    if(LowerB && UpperB) {
+      LowerB = PrefetchExprBuilder::cloneAndModifyExpr(LowerB, LowerMod, Ctx);
+      UpperB = PrefetchExprBuilder::cloneAndModifyExpr(UpperB, UpperMod, Ctx);
+    }
+  }
+
+  VarDecl *getVariable() const { return Var; }
+  Expr *getInit() const { return Init; }
+  Expr *getCond() const { return Cond; }
+  Expr *getUpdate() const { return Update; }
+  enum Direction getUpdateDirection() const { return Dir; }
+  Expr *getLowerBound() const { return LowerB; }
+  Expr *getUpperBound() const { return UpperB; }
+
+  void print(llvm::raw_ostream &O, PrintingPolicy &Policy) const {
+    O << "Induction Variable: " << Var->getName() << "\nDirection: ";
+    switch(Dir) {
+    case Increases: O << "increases\n"; break;
+    case Decreases: O << "decreases\n"; break;
+    case Unknown: O << "unknown update direction\n"; break;
+    }
+    if(LowerB && UpperB) {
+      O << "Lower bound: ";
+      LowerB->printPretty(O, nullptr, Policy);
+      O << "\nUpper bound: ";
+      UpperB->printPretty(O, nullptr, Policy);
+    }
+    else O << "-> Could not determine bounds <-";
+    O << "\n";
+  }
+
+  void dump(PrintingPolicy &Policy) const { print(llvm::dbgs(), Policy); }
+
+private:
+  VarDecl *Var;
+  Expr *Init, *Cond, *Update;
+
+  /// Expressions describing the lower & upper bounds of the induction variable
+  /// and its update direction.
+  enum Direction Dir;
+  Expr *LowerB, *UpperB;
+
+  /// Try to classify the induction variable's update direction based on the
+  /// unary operation type.
+  static enum Direction classifyUnaryOpDirection(UnaryOperator::Opcode Op) {
+    switch(Op) {
+    case UO_PostInc:
+    case UO_PreInc:
+      return Increases;
+    case UO_PostDec:
+    case UO_PreDec:
+      return Decreases;
+    default: return Unknown;
+    }
+  }
+
+  Expr *stripInductionVarFromBinOp(BinaryOperator *B) {
+    DeclRefExpr *D;
+    VarDecl *VD;
+
+    D = dyn_cast<DeclRefExpr>(B->getLHS()->IgnoreImpCasts());
+    if(!D) return nullptr;
+    VD = dyn_cast<VarDecl>(D->getDecl());
+    if(!VD) return nullptr;
+    if(VD == Var) return B->getRHS();
+    return nullptr;
+  }
+
+  Expr *stripInductionVarFromExpr(Expr *E) {
+    DeclRefExpr *D;
+    VarDecl *VD;
+
+    D = dyn_cast<DeclRefExpr>(E->IgnoreImpCasts());
+    if(!D) return nullptr;
+    VD = dyn_cast<VarDecl>(D->getDecl());
+    if(!VD) return nullptr;
+    if(VD != Var) return D;
+    return nullptr;
+  }
+
+  /// Remove the induction variable & operator from the expression, leaving
+  /// only a bounds expression.
+  Expr *stripInductionVar(Expr *E) {
+    BinaryOperator *B;
+    IntegerLiteral *L;
+
+    if((B = dyn_cast<BinaryOperator>(E))) return stripInductionVarFromBinOp(B);
+    else if((L = dyn_cast<IntegerLiteral>(E))) return L;
+    else if(E) return stripInductionVarFromExpr(E);
+    else return nullptr;
+  }
+};
+
+/// Syntactic sugar for InductionVariable containers.
+typedef std::shared_ptr<InductionVariable> InductionVariablePtr;
+typedef std::pair<VarDecl *, InductionVariablePtr> IVPair;
+typedef llvm::DenseMap<VarDecl *, InductionVariablePtr> IVMap;
+
+/// Map an induction variable to an expression describing a bound.
+typedef llvm::DenseMap<VarDecl *, Expr *> IVBoundMap;
+typedef std::pair<VarDecl *, Expr *> IVBoundPair;
+
+/// Traversal to find induction variables in loop initialization, condition and
+/// update expressions.
+template<UnaryOpFilter UnaryFilt, BinaryOpFilter BinaryFilt>
+class IVFinder : public RecursiveASTVisitor<IVFinder<UnaryFilt, BinaryFilt>> {
+public:
+  // Visit binary operators to find induction variables.
+  bool VisitBinaryOperator(BinaryOperator *B) {
+    Expr *LHS;
+    DeclRefExpr *DR;
+    VarDecl *Var;
+
+    // Filter out irrelevant operation types
+    if(!BinaryFilt(B->getOpcode())) return true;
+
+    // Look for DeclRefExprs of scalar integer type -- these reference
+    // induction variables
+    LHS = B->getLHS();
+    if(!PrefetchAnalysis::isScalarIntType(LHS->getType())) return true;
+    DR = dyn_cast<DeclRefExpr>(LHS->IgnoreImpCasts());
+    if(!DR) return true;
+
+    // Make sure the expression acting on the induction variable is a scalar
+    // integer (casts may change types)
+    Var = PrefetchAnalysis::getVarIfScalarInt(DR->getDecl());
+    if(!Var) return true;
+    InductionVars[Var] = B;
+    return true;
+  }
+
+  // Visit unary operators to find induction variables.
+  bool VisitUnaryOperator(UnaryOperator *U) {
+    Expr *SubExpr;
+    DeclRefExpr *DR;
+    VarDecl *Var;
+
+    // Filter out irrelevant operation types
+    if(!UnaryFilt(U->getOpcode())) return true;
+
+    // Look for DeclRefExprs of scalar integer type -- these reference
+    // induction variables
+    SubExpr = U->getSubExpr();
+    if(!PrefetchAnalysis::isScalarIntType(SubExpr->getType())) return true;
+    DR = dyn_cast<DeclRefExpr>(SubExpr->IgnoreImpCasts());
+    if(!DR) return true;
+
+    // Make sure the expression acting on the induction variable is a scalar
+    // integer (casts may change types)
+    Var = PrefetchAnalysis::getVarIfScalarInt(DR->getDecl());
+    if(!Var) return true;
+    InductionVars[Var] = U;
+    return true;
+  }
+
+  bool VisitDeclStmt(DeclStmt *D) {
+    VarDecl *Var;
+    for(auto &Child : D->getDeclGroup()) {
+      Var = PrefetchAnalysis::getVarIfScalarInt(dyn_cast<VarDecl>(Child));
+      if(!Var || !Var->hasInit()) continue;
+      InductionVars[Var] = Var->getInit();
+    }
+    return true;
+  }
+
+  /// Return all induction variables found.
+  const IVBoundMap &getInductionVars() const { return InductionVars; }
+
+  /// Return the bounds expression for a given induction variable, or nullptr
+  /// if none was found.
+  Expr *getVarBound(VarDecl *Var) {
+    IVBoundMap::iterator it = InductionVars.find(Var);
+    if(it != InductionVars.end()) return it->second;
+    else return nullptr;
+  }
+
+private:
+  IVBoundMap InductionVars;
+};
+
+/// Structural information about a for-loop, including induction variables and
+/// parent/child loops.
+class ForLoopInfo {
+public:
+  ForLoopInfo(ForStmt *Loop, std::shared_ptr<ForLoopInfo> &Parent, int Level)
+    : Loop(Loop), Parent(Parent), Level(Level) {}
+
+  /// Add an induction variable.
+  void addInductionVar(const InductionVariablePtr &IV)
+  { InductionVars.insert(IVPair(IV->getVariable(), IV)); }
+
+  /// Remove an induction variable if present.  Return true if removed or false
+  /// if we don't have the variable.
+  bool removeInductionVar(const InductionVariablePtr &IV) {
+    IVMap::iterator it = InductionVars.find(IV->getVariable());
+    if(it != InductionVars.end()) {
+      InductionVars.erase(it);
+      return true;
+    }
+    else return false;
+  }
+
+  /// Add a child loop.
+  void addChildLoop(std::shared_ptr<ForLoopInfo> &S) { Children.push_back(S); }
+
+  ForStmt *getLoop() const { return Loop; }
+  const std::shared_ptr<ForLoopInfo> &getParent() const { return Parent; }
+  int getLevel() const { return Level; }
+  const IVMap &getInductionVars() const { return InductionVars; }
+  const llvm::SmallVector<std::shared_ptr<ForLoopInfo>, 4> &getChildren() const
+  { return Children; }
+
+  void print(llvm::raw_ostream &O, PrintingPolicy &Policy) const {
+    O << "Loop @ " << this << "\nDepth: " << Level
+      << "\nParent: " << Parent.get();
+    if(Children.size()) {
+      O << "\nChildren:";
+      for(auto &Child : Children) O << " " << Child.get();
+    }
+    O << "\n";
+    for(auto &IV : InductionVars) IV.second->dump(Policy);
+    O << "\n";
+    Loop->printPretty(O, nullptr, Policy);
+    O << "\n";
+  }
+  void dump(PrintingPolicy &Policy) const { print(llvm::dbgs(), Policy); }
+
+private:
+  ForStmt *Loop;
+  std::shared_ptr<ForLoopInfo> Parent;
+  size_t Level;
+
+  IVMap InductionVars;
+  llvm::SmallVector<std::shared_ptr<ForLoopInfo>, 4> Children;
+};
+typedef std::shared_ptr<ForLoopInfo> ForLoopInfoPtr;
+
+/// Search a sub-tree for loops, calculating induction variables found in any
+/// loops along the way.  We *must* construct tree structural information in
+/// order to correctly handle complex loop nests, e.g.:
+///
+/// int a, b;
+/// for(a = ...; a < ...; a++) {
+///   for(b = 0; b < 10; b++) {
+///     ...
+///   }
+///
+///   for(b = 10; b < 20; b++) {
+///
+///   }
+/// }
+///
+/// In this example, induction variable 'b' has different ranges in each of the
+/// nested loops.
+class LoopNestTraversal : public RecursiveASTVisitor<LoopNestTraversal> {
+public:
+  LoopNestTraversal(ASTContext *Ctx) : Ctx(Ctx) {}
+
+  void InitTraversal() { if(!LoopNest.size()) LoopNest.emplace_back(nullptr); }
+
+  bool VisitForStmt(ForStmt *S) {
+    Expr *InitExpr, *CondExpr, *UpdateExpr;
+    IVFinder<NoUnaryOp, FilterAssignOp> Init;
+    IVFinder<NoUnaryOp, FilterRelationalOp> Cond;
+    IVFinder<FilterMathOp, FilterMathLogicOp> Update;
+
+    // Set up data & tree structure information.
+    LoopNest.emplace_back(
+      new ForLoopInfo(S, LoopNest.back(), LoopNest.size() - 1));
+    ForLoopInfoPtr &Cur = LoopNest.back();
+    Loops[S] = Cur;
+    if(Cur->getParent()) Cur->getParent()->addChildLoop(Cur);
+
+    // Find the induction variables in the loop expressions.
+    Init.TraverseStmt(S->getInit());
+    Cond.TraverseStmt(S->getCond());
+    Update.TraverseStmt(S->getInc());
+
+    // Find induction variables which are referenced in all three parts of the
+    // for-loop header.
+    const IVBoundMap &InitVars = Init.getInductionVars();
+    for(auto Var = InitVars.begin(), E = InitVars.end(); Var != E; Var++) {
+      InitExpr = Var->second;
+      CondExpr = Cond.getVarBound(Var->first),
+      UpdateExpr = Update.getVarBound(Var->first);
+      if(InitExpr && CondExpr && UpdateExpr) {
+        InductionVariablePtr IV(
+          new InductionVariable(Var->first, InitExpr, CondExpr,
+                                UpdateExpr, Ctx));
+        Cur->addInductionVar(std::move(IV));
+      }
+    }
+
+    return true;
+  }
+
+  bool TraverseStmt(Stmt *S) {
+    if(!S) return true;
+    RecursiveASTVisitor<LoopNestTraversal>::TraverseStmt(S);
+    if(isa<ForStmt>(S)) LoopNest.pop_back();
+    return true;
+  }
+
+  /// Prune induction variables so each each loop only maintains its own
+  /// induction variables and not those of any nested loops.
+  // TODO this may not be necessary...
+  void PruneInductionVars() {
+    // Each loop nest is a tree in a forest of all loop nests
+    for(auto &Info : Loops)
+      if(Info.second->getLevel() == 0)
+        PruneInductionVars(Info.second);
+  }
+
+  /// Get all loops discovered during the tree traversal.
+  const llvm::DenseMap<ForStmt *, ForLoopInfoPtr> &getLoops() const
+  { return Loops; }
+
+  /// Get the enclosing loop's information for an array access.
+  const ForLoopInfoPtr getEnclosingLoop(const ArrayAccess &A) const {
+    ScopeInfoPtr S = A.getScope();
+    while(S && !isa<ForStmt>(S->ScopeStmt)) S = S->ParentScope;
+    if(!S) return ForLoopInfoPtr(nullptr);
+
+    llvm::DenseMap<ForStmt *, ForLoopInfoPtr>::const_iterator it
+      = Loops.find(cast<ForStmt>(S->ScopeStmt));
+    if(it != Loops.end()) return it->second;
+    else return ForLoopInfoPtr(nullptr);
+  }
+
+private:
+  ASTContext *Ctx;
+
+  // A stack of nested loops to provide induction variable scoping information.
+  llvm::SmallVector<ForLoopInfoPtr, 4> LoopNest;
+
+  // Map loop statements to information gathered during traversal.
+  llvm::DenseMap<ForStmt *, ForLoopInfoPtr> Loops;
+
+  // Recursively prune induction variables in a bottom-up fashion (post-order
+  // traversal).
+  void PruneInductionVars(ForLoopInfoPtr Loop) {
+    for(auto &Child : Loop->getChildren()) {
+      PruneInductionVars(Child);
+      for(auto &IV : Child->getInductionVars())
+        Loop->removeInductionVar(IV.second);
+    }
+  }
+};
+
+/// Get all induction variables for a scope, including induction variables from
+/// any enclosing scopes.
+static void getAllInductionVars(const ForLoopInfoPtr &Scope, IVMap &IVs) {
+  assert(Scope && "Invalid arguments");
+
+  ForLoopInfoPtr TmpScope = Scope;
+  do {
+    const IVMap &LoopIVs = TmpScope->getInductionVars();
+    for(auto IV : LoopIVs) IVs[IV.first] = IV.second;
+    TmpScope = TmpScope->getParent();
+  } while(TmpScope);
+}
+
+/// A set of variable declarations.
+typedef PrefetchDataflow::VarSet VarSet;
+
+/// Search a for-loop statement for array access patterns based on loop
+/// induction variables that can be prefetched at runtime.
+void PrefetchAnalysis::analyzeForStmt() {
+  LoopNestTraversal Loops(Ctx);
+  ArrayAccessPattern ArrAccesses(Ignore);
+  PrefetchDataflow Dataflow(Ctx);
+  IVMap AllIVs;
+  IVMap::const_iterator IVIt;
+  VarSet VarsToTrack;
+  ExprList VarExprs;
+  ReplaceMap LowerBounds, UpperBounds;
+  Expr *UpperBound, *LowerBound;
+  PrefetchExprBuilder::BuildInfo LowerBuild(Ctx, LowerBounds, true),
+                                 UpperBuild(Ctx, UpperBounds, true);
+
+  // Gather loop nest information, including induction variables
+  Loops.InitTraversal();
+  Loops.TraverseStmt(S);
+  Loops.PruneInductionVars();
+
+  // Find array/pointer accesses.
+  ArrAccesses.InitTraversal();
+  ArrAccesses.TraverseStmt(S);
+
+  // TODO the following could probably be optimized to reduce re-computing
+  // induction variable sets.
+
+  // Run the dataflow analysis.  Collect all non-induction variables used to
+  // construct array indices to see if induction variables are used in any
+  // assignmend expressions.
+  for(auto &Acc : ArrAccesses.getArrayAccesses()) {
+    AllIVs.clear();
+    ForLoopInfoPtr Scope = Loops.getEnclosingLoop(Acc);
+    getAllInductionVars(Scope, AllIVs);
+    for(auto &Var : Acc.getVarsInIdx()) {
+      if(!AllIVs.count(Var)) VarsToTrack.insert(Var);
+    }
+  }
+
+  Dataflow.runDataflow(cast<ForStmt>(S)->getBody(), VarsToTrack);
+
+  // Reconstruct array subscript expressions with induction variable references
+  // replaced by their bounds.  This includes variables defined using
+  // expressions containing induction variables.
+  for(auto &Acc : ArrAccesses.getArrayAccesses()) {
+    LowerBuild.reset();
+    UpperBuild.reset();
+    AllIVs.clear();
+
+    // Get the expressions for replacing upper & lower bounds of induction
+    // variables.  Note that we *must* add all induction variables even if
+    // they're not directly used, as other variables used in the index
+    // calculation may be defined based on induction variables.  For example:
+    //
+    // for(int i = ...; i < ...; i++) {
+    //   int j = i + offset;
+    //   ...
+    //   arr[j] = ...
+    // }
+    //
+    // In this example, 'i' is not directly used in addressing but the dataflow
+    // analysis determines that 'j' is defined based on 'i', and hence we need
+    // to replace 'j' with induction variable bounds expressions.
+    ForLoopInfoPtr Scope = Loops.getEnclosingLoop(Acc);
+    getAllInductionVars(Scope, AllIVs);
+    for(auto &Pair : AllIVs) {
+      const InductionVariablePtr &IV = Pair.second;
+      LowerBounds.insert(ReplacePair(IV->getVariable(), IV->getLowerBound()));
+      UpperBounds.insert(ReplacePair(IV->getVariable(), IV->getUpperBound()));
+    }
+
+    // Add other variables used in array calculation that may be defined using
+    // induction variable expressions.
+    for(auto &Var : Acc.getVarsInIdx()) {
+      IVIt = AllIVs.find(Var);
+      if(IVIt == AllIVs.end()) {
+        Dataflow.getVariableValues(Var, Acc.getStmt(), VarExprs);
+        // TODO currently if a variable used in an index calculation can take
+        // on more than one value due to control flow, we just avoid inserting
+        // prefetch expressions due to all the possible permutations.
+        if(VarExprs.size() == 1) {
+          LowerBounds.insert(ReplacePair(Var, *VarExprs.begin()));
+          UpperBounds.insert(ReplacePair(Var, *VarExprs.begin()));
+        }
+      }
+    }
+
+    // Create array access bounds expressions
+    LowerBound =
+      PrefetchExprBuilder::cloneWithReplacement(Acc.getIndex(), LowerBuild),
+    UpperBound =
+      PrefetchExprBuilder::cloneWithReplacement(Acc.getIndex(), UpperBuild);
+    if(LowerBound && UpperBound)
+      ToPrefetch.emplace_back(Acc.getAccessType(), Acc.getBase(),
+                              LowerBound, UpperBound);
+  }
+}
+
+//===----------------------------------------------------------------------===//
+// Prefetch analysis API
+//
+
+void PrefetchAnalysis::analyzeStmt() {
+  if(!Ctx || !S) return;
+
+  // TODO other types of statements
+  if(isa<ForStmt>(S)) analyzeForStmt();
+
+  mergeArrayAccesses();
+  pruneArrayAccesses();
+}
+
+void PrefetchAnalysis::print(llvm::raw_ostream &O) const {
+  PrintingPolicy Policy(Ctx->getLangOpts());
+  for(auto &Range : ToPrefetch) {
+    O << "Array '" << Range.getArray()->getName() << "': ";
+    Range.getStart()->printPretty(O, nullptr, Policy);
+    O << " to ";
+    Range.getEnd()->printPretty(O, nullptr, Policy);
+    O << " (" << Range.getTypeName() << ")\n";
+  }
+}
+
Index: lib/Sema/PrefetchDataflow.cpp
===================================================================
--- lib/Sema/PrefetchDataflow.cpp	(nonexistent)
+++ lib/Sema/PrefetchDataflow.cpp	(working copy)
@@ -0,0 +1,290 @@
+//=- PrefetchDataflow.cpp - Dataflow analysis for prefetching ------------*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the dataflow of expressions as required for prefetching
+// analysis.  This is required to correctly discover how variables are used in
+// memory accesses in order to construct memory access ranges.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/ParentMap.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "clang/Sema/PrefetchDataflow.h"
+#include "clang/Sema/PrefetchExprBuilder.h"
+#include "llvm/Support/Debug.h"
+#include <queue>
+
+using namespace clang;
+
+//===----------------------------------------------------------------------===//
+// Common utilities
+//
+
+/// Return whether a statement is a loop construct.
+static inline bool isLoopStmt(const Stmt *S) {
+  if(isa<DoStmt>(S) || isa<ForStmt>(S) || isa<WhileStmt>(S)) return true;
+  else return false;
+}
+
+/// Return whether a binary operator is an assign expression.
+static inline bool isAssign(const BinaryOperator *B) {
+  if(B->getOpcode() == BO_Assign) return true;
+  return false;
+}
+
+/// Return whether a binary operator is an operation + assign expression.
+static inline bool isMathAssign(const BinaryOperator *B) {
+  switch(B->getOpcode()) {
+  case BO_MulAssign: case BO_DivAssign: case BO_RemAssign:
+  case BO_AddAssign: case BO_SubAssign: case BO_ShlAssign:
+  case BO_ShrAssign: case BO_AndAssign: case BO_XorAssign:
+  case BO_OrAssign:
+    return true;
+  default: return false;
+  }
+}
+
+/// Return the variable referenced by the expression E, or a nullptr if none
+/// were referenced.
+static const VarDecl *getVariableIfReference(const Expr *E) {
+  const DeclRefExpr *DR;
+  const VarDecl *VD;
+
+  DR = dyn_cast<DeclRefExpr>(E->IgnoreImpCasts());
+  if(!DR) return nullptr;
+  VD = dyn_cast<VarDecl>(DR->getDecl());
+  return VD;
+}
+
+//===----------------------------------------------------------------------===//
+// Expression dataflow API
+//
+
+PrefetchDataflow::PrefetchDataflow() : Ctx(nullptr) {}
+PrefetchDataflow::PrefetchDataflow(ASTContext *Ctx) : Ctx(Ctx) {}
+PrefetchDataflow::PrefetchDataflow(const PrefetchDataflow &RHS)
+  : Ctx(RHS.Ctx) {}
+
+PrefetchDataflow &PrefetchDataflow::operator=(const PrefetchDataflow &RHS) {
+  Ctx = RHS.Ctx;
+  return *this;
+}
+
+/// Analyze a statement to determine if we're defining a relevant variable.  If
+/// so, clone & store the defining expression.
+static void checkAndUpdateVarDefs(ASTContext *Ctx, const Stmt *S,
+                                  const PrefetchDataflow::VarSet &VarsToTrack,
+                                  SymbolicValueMap &VarExprs) {
+  Expr *Clone;
+  const DeclStmt *DS;
+  const BinaryOperator *BO;
+  const VarDecl *VD;
+
+  // Check for variable declarations with initializers, the initial definition.
+  if((DS = dyn_cast<DeclStmt>(S))) {
+    for(auto D : DS->getDeclGroup()) {
+      VD = dyn_cast<VarDecl>(D);
+      if(VD && VD->hasInit() && VarsToTrack.count(VD)) {
+        // TODO unfortunately CFG & accompanying classes expose statements
+        // & expressions with const qualifiers.  But, we *really* need them
+        // to not be const qualified in order to clone them (in particular,
+        // cloning DeclRefExprs becomes a headache).
+        Clone = PrefetchExprBuilder::clone((Expr *)VD->getInit(), Ctx);
+        if(Clone) VarExprs[VD].insert(Clone);
+      }
+    }
+    return;
+  }
+
+  BO = dyn_cast<BinaryOperator>(S);
+  if(!BO) return;
+
+  // Check for assignment operation to a relevant variable.  If we had
+  // previous expression(s) describing the variable's value the assignment
+  // overwrites them.
+  if(isAssign(BO)) {
+    VD = getVariableIfReference(BO->getLHS());
+    if(VD && VarsToTrack.count(VD)) {
+      ExprList &Exprs = VarExprs[VD];
+      Exprs.clear();
+      Clone = PrefetchExprBuilder::clone(BO->getRHS(), Ctx);
+      if(Clone) Exprs.insert(Clone);
+    }
+  }
+  // TODO we currently don't handle math + assign operations, so the
+  // dataflow analysis clamps to 'unknown' (i.e., no expressions).
+  else if(isMathAssign(BO)) {
+    VD = getVariableIfReference(BO->getLHS());
+    if(VD && VarsToTrack.count(VD)) VarExprs.erase(VD);
+  }
+}
+
+void PrefetchDataflow::runDataflow(Stmt *S, VarSet &VarsToTrack) {
+  const CFGBlock *Block;
+  CFGBlock::const_succ_iterator Succ, SE;
+  CFGBlockSet Seen;
+  std::queue<const CFGBlock *> Work;
+  Optional<CFGStmt> StmtNode;
+  BlockValuesMap::iterator BVIt;
+  SymbolicValueMap CurMap;
+
+  if(!VarsToTrack.size()) return;
+  this->S = S;
+  TheCFG = CFG::buildCFG(nullptr, S, Ctx, CFG::BuildOptions());
+
+  Work.push(&TheCFG->getEntry());
+  while(!Work.empty()) {
+    Block = Work.front();
+    Work.pop();
+    Seen.insert(Block);
+
+    // Find assignment operations within the block.  Because of the forward
+    // dataflow algorithm, predecessors should have already pushed dataflow
+    // expressions, if any, to this block.
+    CurMap = VarValues[Block];
+    for(auto &Elem : *Block) {
+      StmtNode = Elem.getAs<CFGStmt>();
+      if(!StmtNode) continue;
+      checkAndUpdateVarDefs(Ctx, StmtNode->getStmt(), VarsToTrack, CurMap);
+    }
+
+    // Push dataflow expressions to successors & add not-yet visited blocks to
+    // the work queue.
+    for(Succ = Block->succ_begin(), SE = Block->succ_end();
+        Succ != SE; Succ++) {
+      if(!Succ->isReachable() || Seen.count(*Succ)) continue;
+      else {
+        SymbolicValueMap &SuccMap = VarValues[*Succ];
+        for(auto &Pair : CurMap) {
+          ExprList &VarExprs = SuccMap[Pair.first];
+          for(auto Expr : Pair.second) VarExprs.insert(Expr);
+        }
+        Work.push(*Succ);
+      }
+    }
+
+    // TODO do we need to treat sub-scopes, e.g., loops, differently?
+  }
+
+  // Make it easier to look up analysis for statements
+  PMap.reset(new ParentMap(S));
+  StmtToBlock.reset(CFGStmtMap::Build(TheCFG.get(), PMap.get()));
+}
+
+/// Search for statements in sub-trees.
+class StmtFinder : public RecursiveASTVisitor<StmtFinder> {
+public:
+  void initialize(const Stmt *TheStmt) {
+    this->TheStmt = TheStmt;
+    Found = false;
+  }
+
+  bool TraverseStmt(Stmt *S) {
+    if(S == TheStmt) {
+      Found = true;
+      return false;
+    }
+    else return RecursiveASTVisitor::TraverseStmt(S);
+  }
+
+  bool foundStmt() const { return Found; }
+
+private:
+  const Stmt *TheStmt;
+  bool Found;
+};
+
+void PrefetchDataflow::getVariableValues(VarDecl *Var,
+                                         const Stmt *Use,
+                                         ExprList &Exprs) const {
+  SymbolicValueMap TmpMap;
+  VarSet VarsToTrack;
+  Optional<CFGStmt> StmtNode;
+  StmtFinder Finder;
+
+  Exprs.clear();
+
+  // Find analysis for the given variable, if any, at the start of the block
+  // containing the statement.
+  if(!StmtToBlock) return;
+  const CFGBlock *B = StmtToBlock->getBlock(Use);
+  if(!B) return;
+  BlockValuesMap::const_iterator ValIt = VarValues.find(B);
+  if(ValIt == VarValues.end()) return;
+  const SymbolicValueMap &Values = ValIt->second;
+  SymbolicValueMap::const_iterator SymIt = Values.find(Var);
+
+  // Walk through the block to the statement, searching for definitions between
+  // the start of the block and the statement argument
+  VarsToTrack.insert(Var);
+  if(SymIt != Values.end()) TmpMap[Var] = SymIt->second;
+  else TmpMap[Var] = ExprList();
+  for(auto &Elem : *B) {
+    StmtNode = Elem.getAs<CFGStmt>();
+    if(!StmtNode) continue;
+
+    // TODO CFG exposes statements with const qualifiers while the
+    // RecursiveASTVisitor requires non-const qualified statements.
+    Finder.initialize(Use);
+    Finder.TraverseStmt((Stmt *)StmtNode->getStmt());
+    if(Finder.foundStmt()) {
+      Exprs = TmpMap[Var];
+      return;
+    }
+
+    checkAndUpdateVarDefs(Ctx, StmtNode->getStmt(), VarsToTrack, TmpMap);
+  }
+}
+
+void PrefetchDataflow::reset() {
+  S = nullptr;
+  StmtToBlock.reset();
+  PMap.reset();
+  TheCFG.reset();
+  VarValues.clear();
+}
+
+void PrefetchDataflow::print(llvm::raw_ostream &O) const {
+  if(!S) {
+    O << "<Prefetch Dataflow> No analysis -- did you run with runDataflow()?\n";
+    return;
+  }
+
+  if(!TheCFG) {
+    O << "<Prefetch Dataflow> No variables to track\n";
+    return;
+  }
+
+  if(!VarValues.size()) {
+    O << "<Prefetch Dataflow> No symbolic expressions detected\n";
+    return;
+  }
+
+  O << "<Prefetch Dataflow> Analysis results:\n";
+  PrintingPolicy PP(Ctx->getLangOpts());
+  for(auto Node : *TheCFG) {
+    Node->print(O, TheCFG.get(), Ctx->getLangOpts(), true);
+    O << "\n";
+    BlockValuesMap::const_iterator BVIt = VarValues.find(Node);
+    if(BVIt != VarValues.end()) {
+      for(auto VarValPair : BVIt->second) {
+        O << "Values for '" << VarValPair.first->getName() << "':\n";
+        for(auto E : VarValPair.second) {
+          E->printPretty(O, nullptr, PP);
+          O << "\n";
+        }
+      }
+    }
+    else O << "\n-> No dataflow values <-\n";
+  }
+}
+
+void PrefetchDataflow::dump() const { print(llvm::dbgs()); }
+
Index: lib/Sema/PrefetchExprBuilder.cpp
===================================================================
--- lib/Sema/PrefetchExprBuilder.cpp	(nonexistent)
+++ lib/Sema/PrefetchExprBuilder.cpp	(working copy)
@@ -0,0 +1,281 @@
+//=- PrefetchExprBuilder.cpp - Prefetching expression builder ------------*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines a set of utilities for building expressions for
+// prefetching.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/ASTContext.h"
+#include "clang/Sema/PrefetchAnalysis.h"
+#include "clang/Sema/PrefetchExprBuilder.h"
+#include "llvm/Support/Debug.h"
+
+using namespace clang;
+
+//===----------------------------------------------------------------------===//
+// Prefetch expression comparisondefinitions
+//
+
+static bool
+BinaryOperatorEqual(const BinaryOperator *A, const BinaryOperator *B) {
+  if(A->getOpcode() != B->getOpcode()) return false;
+  else return PrefetchExprEquality::exprEqual(A->getRHS(), B->getRHS()) &&
+              PrefetchExprEquality::exprEqual(A->getLHS(), B->getLHS());
+}
+
+static bool UnaryOperatorEqual(const UnaryOperator *A, const UnaryOperator *B) {
+  if(A->getOpcode() != B->getOpcode()) return false;
+  else return PrefetchExprEquality::exprEqual(A->getSubExpr(), B->getSubExpr());
+}
+
+static bool DeclRefExprEqual(const DeclRefExpr *A, const DeclRefExpr *B) {
+  if(A->getDecl() == B->getDecl()) return true;
+  else return false;
+}
+
+static bool
+ImplicitCastExprEqual(const ImplicitCastExpr *A, const ImplicitCastExpr *B) {
+  if(A->getCastKind() != B->getCastKind()) return false;
+  else return PrefetchExprEquality::exprEqual(A->getSubExpr(), B->getSubExpr());
+}
+
+static bool
+IntegerLiteralEqual(const IntegerLiteral *A, const IntegerLiteral *B) {
+  return A->getValue() == B->getValue();
+}
+
+bool PrefetchExprEquality::exprEqual(const Expr *A, const Expr *B) {
+  const BinaryOperator *B_A, *B_B;
+  const UnaryOperator *U_A, *U_B;
+  const DeclRefExpr *D_A, *D_B;
+  const ImplicitCastExpr *C_A, *C_B;
+  const IntegerLiteral *I_A, *I_B;
+
+  if(!A || ! B) return false;
+
+  // Check common characteristics.  Note that by checking the statement class,
+  // we know the expressions are of the same type and can use cast<> below.
+  if(A->getStmtClass() != B->getStmtClass() ||
+     A->getType() != B->getType() ||
+     A->getValueKind() != B->getValueKind() ||
+     A->getObjectKind() != B->getObjectKind()) return false;
+
+  // TODO better way to switch on type?
+  if((B_A = dyn_cast<BinaryOperator>(A))) {
+    B_B = cast<BinaryOperator>(B);
+    return BinaryOperatorEqual(B_A, B_B);
+  }
+  else if((U_A = dyn_cast<UnaryOperator>(A))) {
+    U_B = cast<UnaryOperator>(B);
+    return UnaryOperatorEqual(U_A, U_B);
+  }
+  else if((D_A = dyn_cast<DeclRefExpr>(A))) {
+    D_B = cast<DeclRefExpr>(B);
+    return DeclRefExprEqual(D_A, D_B);
+  }
+  else if((C_A = dyn_cast<ImplicitCastExpr>(A))) {
+    C_B = cast<ImplicitCastExpr>(B);
+    return ImplicitCastExprEqual(C_A, C_B);
+  }
+  else if((I_A = dyn_cast<IntegerLiteral>(A))) {
+    I_B = cast<IntegerLiteral>(B);
+    return IntegerLiteralEqual(I_A, I_B);
+  }
+  else return false;
+}
+
+//===----------------------------------------------------------------------===//
+// Modifier class definitions
+//
+
+void PrefetchExprBuilder::Modifier::ClassifyModifier(const Expr *E,
+                                                     const ASTContext *Ctx) {
+  unsigned Bits;
+  const DeclRefExpr *DR;
+  const BinaryOperator *B;
+  const IntegerLiteral *L;
+  QualType BaseTy;
+
+  Ty = Unknown;
+  if(!E) return;
+
+  E = E->IgnoreImpCasts();
+  if((B = dyn_cast<BinaryOperator>(E))) {
+    // Note: both operands *must* have same type
+    BaseTy = B->getLHS()->getType().getDesugaredType(*Ctx);
+    assert(PrefetchAnalysis::isScalarIntType(BaseTy) &&
+           "Invalid expression type");
+    Bits = PrefetchAnalysis::getTypeSize(cast<BuiltinType>(BaseTy)->getKind());
+
+    switch(B->getOpcode()) {
+    default: Ty = None; break;
+    case BO_LT:
+      Ty = Sub;
+      Val = llvm::APInt(Bits, 1, false);
+      break;
+    case BO_GT:
+      Ty = Add;
+      Val = llvm::APInt(Bits, 1, false);
+      break;
+    // TODO hybrid math/assign operations
+    }
+  }
+  else if((DR = dyn_cast<DeclRefExpr>(E))) Ty = None;
+  else if((L = dyn_cast<IntegerLiteral>(E))) Ty = None;
+}
+
+//===----------------------------------------------------------------------===//
+// Prefetch expression builder definitions
+//
+
+typedef PrefetchExprBuilder::BuildInfo BuildInfo;
+
+Expr *PrefetchExprBuilder::cloneWithReplacement(Expr *E, BuildInfo &Info) {
+  BinaryOperator *B;
+  UnaryOperator *U;
+  DeclRefExpr *D;
+  ImplicitCastExpr *C;
+  IntegerLiteral *I;
+
+  if(!E) return nullptr;
+
+  // TODO better way to switch on type?
+  if((B = dyn_cast<BinaryOperator>(E)))
+    return cloneBinaryOperator(B, Info);
+  else if((U = dyn_cast<UnaryOperator>(E)))
+    return cloneUnaryOperator(U, Info);
+  else if((D = dyn_cast<DeclRefExpr>(E)))
+    return cloneDeclRefExpr(D, Info);
+  else if((C = dyn_cast<ImplicitCastExpr>(E)))
+    return cloneImplicitCastExpr(C, Info);
+  else if((I = dyn_cast<IntegerLiteral>(E)))
+    return cloneIntegerLiteral(I, Info);
+  else {
+    // TODO delete
+    llvm::dbgs() << "Unhandled expression:\n";
+    if(Info.dumpInColor) E->dumpColor();
+    else E->dump();
+  }
+
+  return nullptr;
+}
+
+Expr *PrefetchExprBuilder::clone(Expr *E, ASTContext *Ctx) {
+  ReplaceMap Dummy; // No variables, don't replace any DeclRefExprs
+  BuildInfo DummyInfo(Ctx, Dummy, true);
+  return cloneWithReplacement(E, DummyInfo);
+}
+
+Expr *PrefetchExprBuilder::cloneBinaryOperator(BinaryOperator *B,
+                                               BuildInfo &Info) {
+  Expr *LHS = cloneWithReplacement(B->getLHS(), Info),
+       *RHS = cloneWithReplacement(B->getRHS(), Info);
+  if(!LHS || !RHS) return nullptr;
+  return new (*Info.Ctx) BinaryOperator(LHS, RHS, B->getOpcode(),
+                                        B->getType(),
+                                        B->getValueKind(),
+                                        B->getObjectKind(),
+                                        SourceLocation(),
+                                        B->isFPContractable());
+}
+
+Expr *PrefetchExprBuilder::cloneUnaryOperator(UnaryOperator *U,
+                                              BuildInfo &Info) {
+  Expr *Sub = cloneWithReplacement(U->getSubExpr(), Info);
+  if(!Sub) return nullptr;
+  return new (*Info.Ctx) UnaryOperator(Sub, U->getOpcode(),
+                                       U->getType(),
+                                       U->getValueKind(),
+                                       U->getObjectKind(),
+                                       SourceLocation());
+}
+
+Expr *PrefetchExprBuilder::cloneDeclRefExpr(DeclRefExpr *D,
+                                            BuildInfo &Info) {
+  Expr *Clone = nullptr;
+  VarDecl *VD;
+  ReplaceMap::const_iterator it;
+
+  // If the variable is relevant and we haven't replaced it before, replace it
+  // with the specified expression.
+  if((VD = dyn_cast<VarDecl>(D->getDecl())) &&
+     (it = Info.VarReplace.find(VD)) != Info.VarReplace.end() &&
+     !Info.SeenVars.count(VD)) {
+    Info.SeenVars.insert(VD);
+    Clone = cloneWithReplacement(it->second, Info);
+    Info.SeenVars.erase(VD);
+    return Clone;
+  }
+
+  // Clone the DeclRefExpr if the variable isn't relevant or if cloning the
+  // replacement failed.
+  return new (*Info.Ctx) DeclRefExpr(D->getDecl(),
+                                     D->refersToEnclosingVariableOrCapture(),
+                                     D->getType(),
+                                     D->getValueKind(),
+                                     SourceLocation(),
+                                     D->getNameInfo().getInfo());
+}
+
+Expr *PrefetchExprBuilder::cloneImplicitCastExpr(ImplicitCastExpr *C,
+                                                 BuildInfo &Info) {
+  Expr *Sub = cloneWithReplacement(C->getSubExpr(), Info);
+  if(!Sub) return nullptr;
+
+  // Avoid the situation that when replacing an induction variable with another
+  // expression we accidentally chain together 2 implicit casts (which causes
+  // CodeGen to choke).
+  if(C->getCastKind() == CastKind::CK_LValueToRValue &&
+     Sub->getValueKind() == VK_RValue)
+    return Sub;
+  else
+    return new (*Info.Ctx) ImplicitCastExpr(ImplicitCastExpr::OnStack,
+                                            C->getType(),
+                                            C->getCastKind(),
+                                            Sub,
+                                            C->getValueKind());
+}
+
+Expr *PrefetchExprBuilder::cloneIntegerLiteral(IntegerLiteral *L,
+                                               BuildInfo &Info) {
+  return new (*Info.Ctx) IntegerLiteral(*Info.Ctx, L->getValue(),
+                                        L->getType(),
+                                        SourceLocation());
+}
+
+Expr *PrefetchExprBuilder::cloneAndModifyExpr(Expr *E,
+                                              const Modifier &Mod,
+                                              ASTContext *Ctx) {
+  BinaryOperator::Opcode Op;
+  IntegerLiteral *RHS;
+
+  E = clone(E, Ctx);
+  if(!E) return nullptr;
+
+  switch(Mod.getType()) {
+  case Modifier::Add: Op = BO_Add; break;
+  case Modifier::Sub: Op = BO_Sub; break;
+  case Modifier::Mul: Op = BO_Mul; break;
+  case Modifier::Div: Op = BO_Div; break;
+  case Modifier::None: return E; // Nothing to do
+  case Modifier::Unknown: return nullptr; // Couldn't classify
+  }
+
+  RHS = new (*Ctx) IntegerLiteral(*Ctx, Mod.getVal(),
+                                  E->getType(),
+                                  SourceLocation());
+  return new (*Ctx) BinaryOperator(E, RHS, Op,
+                                   E->getType(),
+                                   E->getValueKind(),
+                                   E->getObjectKind(),
+                                   SourceLocation(),
+                                   false);
+}
+
Index: lib/Sema/SemaOpenMP.cpp
===================================================================
--- lib/Sema/SemaOpenMP.cpp	(revision 320332)
+++ lib/Sema/SemaOpenMP.cpp	(working copy)
@@ -4616,6 +4616,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -4831,6 +4832,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -4952,6 +4954,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -5075,6 +5078,7 @@
   case OMPC_flush:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -5129,10 +5133,12 @@
 
 OMPClause *Sema::ActOnOpenMPVarListClause(
     OpenMPClauseKind Kind, ArrayRef<Expr *> VarList, Expr *TailExpr,
-    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation ColonLoc,
+    Expr *EndExpr, SourceLocation StartLoc, SourceLocation LParenLoc,
+    SourceLocation ColonLoc, SourceLocation EndColonLoc,
     SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,
     const DeclarationNameInfo &ReductionId, OpenMPDependClauseKind DepKind,
-    SourceLocation DepLoc) {
+    SourceLocation DepLoc, OpenMPPrefetchClauseKind PrefKind,
+    SourceLocation PrefLoc) {
   OMPClause *Res = nullptr;
   switch (Kind) {
   case OMPC_private:
@@ -5172,6 +5178,11 @@
     Res = ActOnOpenMPDependClause(DepKind, DepLoc, ColonLoc, VarList, StartLoc,
                                   LParenLoc, EndLoc);
     break;
+  case OMPC_prefetch:
+    Res = ActOnOpenMPPrefetchClause(PrefKind, PrefLoc, VarList, TailExpr,
+                                    EndExpr, StartLoc, LParenLoc, ColonLoc,
+                                    EndColonLoc, EndLoc);
+    break;
   case OMPC_if:
   case OMPC_final:
   case OMPC_num_threads:
@@ -6785,3 +6796,58 @@
                                  DepLoc, ColonLoc, Vars);
 }
 
+OMPClause *
+Sema::ActOnOpenMPPrefetchClause(OpenMPPrefetchClauseKind PrefKind,
+                                SourceLocation PrefLoc,
+                                ArrayRef<Expr *> VarList,
+                                Expr *Start, Expr *End,
+                                SourceLocation StartLoc,
+                                SourceLocation LParenLoc,
+                                SourceLocation FirstColonLoc,
+                                SourceLocation SecondColonLoc,
+                                SourceLocation EndLoc) {
+  // Check validity of range expressions & variables which use them
+  if(Start) {
+    if(!Start->getType()->isIntegerType()) {
+      Diag(Start->getExprLoc(), diag::err_omp_invalid_prefetch_range_type);
+      return nullptr;
+    }
+
+    if(End) {
+      if(!End->getType()->isIntegerType()) {
+        Diag(End->getExprLoc(), diag::err_omp_invalid_prefetch_range_type);
+        return nullptr;
+      }
+    }
+
+    for(const auto &Var : VarList) {
+      QualType T = Var->getType();
+
+      if(!T->isArrayType() && !T->isPointerType()) {
+        Diag(Var->getExprLoc(), diag::err_omp_invalid_prefetch_var_type)
+          << "array or pointer";
+        return nullptr;
+      }
+    }
+  }
+  else {
+    for(const auto &Var : VarList) {
+      // Note: array types with known sizes may be decayed to pointer types.
+      // We want the original type (i.e., the array type) but we can't simply
+      // call T.getDesugaredType() as it will return the pointer type.
+      QualType T = Var->getType();
+      while(isa<DecayedType>(T)) T = cast<DecayedType>(T)->getOriginalType();
+
+      if(!T->isConstantArrayType()) {
+        Diag(Var->getExprLoc(), diag::err_omp_invalid_prefetch_var_type)
+          << "constant-sized array";
+        return nullptr;
+      }
+    }
+  }
+
+  return OMPPrefetchClause::Create(Context, PrefKind, PrefLoc, VarList, Start,
+                                   End, StartLoc, LParenLoc, FirstColonLoc,
+                                   SecondColonLoc, EndLoc);
+}
+
Index: lib/Sema/TreeTransform.h
===================================================================
--- lib/Sema/TreeTransform.h	(revision 320332)
+++ lib/Sema/TreeTransform.h	(working copy)
@@ -7469,6 +7469,14 @@
       C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
 }
 
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implmented");
+  return C;
+}
+
 //===----------------------------------------------------------------------===//
 // Expression transformation
 //===----------------------------------------------------------------------===//
Index: lib/Serialization/ASTReaderStmt.cpp
===================================================================
--- lib/Serialization/ASTReaderStmt.cpp	(revision 320332)
+++ lib/Serialization/ASTReaderStmt.cpp	(working copy)
@@ -2065,6 +2065,11 @@
   C->setVarRefs(Vars);
 }
 
+void OMPClauseReader::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
+}
+
 //===----------------------------------------------------------------------===//
 // OpenMP Directives.
 //===----------------------------------------------------------------------===//
Index: lib/Serialization/ASTWriterStmt.cpp
===================================================================
--- lib/Serialization/ASTWriterStmt.cpp	(revision 320332)
+++ lib/Serialization/ASTWriterStmt.cpp	(working copy)
@@ -1916,6 +1916,11 @@
     Writer->Writer.AddStmt(VE);
 }
 
+void OMPClauseWriter::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
+}
+
 //===----------------------------------------------------------------------===//
 // OpenMP Directives.
 //===----------------------------------------------------------------------===//
Index: tools/libclang/CIndex.cpp
===================================================================
--- tools/libclang/CIndex.cpp	(revision 320332)
+++ tools/libclang/CIndex.cpp	(working copy)
@@ -2147,7 +2147,11 @@
 void OMPClauseEnqueue::VisitOMPDependClause(const OMPDependClause *C) {
   VisitOMPClauseList(C);
 }
+void OMPClauseEnqueue::VisitOMPPrefetchClause(const OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
 }
+}
 
 void EnqueueVisitor::EnqueueChildren(const OMPClause *S) {
   unsigned size = WL.size();

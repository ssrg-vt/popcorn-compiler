Index: include/clang/AST/ASTContext.h
===================================================================
--- include/clang/AST/ASTContext.h	(revision 320332)
+++ include/clang/AST/ASTContext.h	(working copy)
@@ -21,6 +21,7 @@
 #include "clang/AST/Decl.h"
 #include "clang/AST/ExternalASTSource.h"
 #include "clang/AST/NestedNameSpecifier.h"
+#include "clang/AST/PrefetchAnalysis.h"
 #include "clang/AST/PrettyPrinter.h"
 #include "clang/AST/RawCommentList.h"
 #include "clang/AST/TemplateName.h"
@@ -295,6 +296,9 @@
   /// definitions of that entity.
   llvm::DenseMap<NamedDecl*, llvm::TinyPtrVector<Module*>> MergedDefModules;
 
+  /// \brief Analysis on statements for which prefetching has been enabled.
+  mutable llvm::DenseMap<const Stmt *, PrefetchAnalysis> PrefetchAnalyses;
+
 public:
   /// \brief A type synonym for the TemplateOrInstantiation mapping.
   typedef llvm::PointerUnion<VarTemplateDecl *, MemberSpecializationInfo *>
@@ -898,6 +902,20 @@
   /// \brief Retrieve the declaration for a 128-bit float stub type.
   TypeDecl *getFloat128StubType() const;
 
+  /// \brief Add a new prefetching analysis.  Note that analysis should be done
+  /// before adding it to the context.
+  void addPrefetchAnalysis(const Stmt *S, PrefetchAnalysis &PA)
+  { PrefetchAnalyses[S] = PA; }
+
+  /// \brief Retrieve prefetching analysis for a statement if it exists, or
+  /// return a nullptr otherwise.
+  const PrefetchAnalysis *getPrefetchAnalysis(const Stmt *S) const {
+    llvm::DenseMap<const Stmt *, PrefetchAnalysis>::iterator it;
+    it = PrefetchAnalyses.find(S);
+    if(it != PrefetchAnalyses.end()) return &it->second;
+    else return nullptr;
+  }
+
   //===--------------------------------------------------------------------===//
   //                           Type Constructors
   //===--------------------------------------------------------------------===//
Index: include/clang/AST/DataRecursiveASTVisitor.h
===================================================================
--- include/clang/AST/DataRecursiveASTVisitor.h	(revision 320332)
+++ include/clang/AST/DataRecursiveASTVisitor.h	(working copy)
@@ -2663,6 +2663,14 @@
   return true;
 }
 
+template <typename Derived>
+bool RecursiveASTVisitor<Derived>::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  TRY_TO(VisitOMPClauseList(C));
+  TRY_TO(TraverseStmt(C->getStartOfRange()));
+  TRY_TO(TraverseStmt(C->getEndOfRange()));
+  return true;
+}
+
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
 // returning decls or qualtypes or nestednamespecifier -- though I'm
Index: include/clang/AST/OpenMPClause.h
===================================================================
--- include/clang/AST/OpenMPClause.h	(revision 320332)
+++ include/clang/AST/OpenMPClause.h	(working copy)
@@ -2300,6 +2300,59 @@
   }
 };
 
+/// \brief This represents a memory prefetch request for Popcorn Linux.  This
+/// should only be used for prefetching contiguous blocks of memory, e.g.,
+/// arrays or pointers to chunks of memory.
+class OMPPrefetchClause : public OMPVarListClause<OMPPrefetchClause> {
+private:
+  /// \brief What type of prefetching to perform.
+  OpenMPPrefetchClauseKind Kind;
+
+  /// \brief Expressions describing the memory range to be prefetched.
+  ///
+  /// 1. If both are nullptr, then the entire array should be prefetched
+  /// 2. If Start is valid and End is nullptr, then use the expression (which
+  ///    should be affine to a for-loop iteration variable) to prefetch the
+  ///    region of memory based on the loop iterations assigned to the thread
+  /// 3. If both Start and End are valid, then prefetch the absolute range
+  ///    denoted by the starting & ending expressions
+  Expr *Start, *End;
+
+  /// \brief Locations of the kind specifier, colons used to separate the
+  /// variable list and range expression(s).  These are valid in conjunction
+  /// with Start & End, respectively.
+  SourceLocation KindLoc, FirstColonLoc, SecondColonLoc;
+
+  OMPPrefetchClause(SourceLocation StartLoc, SourceLocation LParenLoc,
+                    SourceLocation FirstColonLoc,
+                    SourceLocation SecondColonLoc, SourceLocation EndLoc,
+                    unsigned N)
+      : OMPVarListClause<OMPPrefetchClause>(OMPC_prefetch, StartLoc, LParenLoc,
+                                            EndLoc, N),
+        FirstColonLoc(FirstColonLoc), SecondColonLoc(SecondColonLoc) {}
+public:
+  static OMPPrefetchClause *
+  Create(const ASTContext &C, OpenMPPrefetchClauseKind Kind,
+         SourceLocation KindLoc, ArrayRef<Expr *> VL, Expr *Start, Expr *End,
+         SourceLocation StartLoc, SourceLocation LParenLoc,
+         SourceLocation FirstColonLoc, SourceLocation SecondColonLoc,
+         SourceLocation EndLoc);
+
+  OpenMPPrefetchClauseKind getPrefetchKind() const { return Kind; }
+  void setPrefetchKind(OpenMPPrefetchClauseKind Kind) { this->Kind = Kind; }
+
+  Expr *getStartOfRange() const { return Start; }
+  void setStartOfRange(Expr *Start) { this->Start = Start; }
+  Expr *getEndOfRange() const { return End; }
+  void setEndOfRange(Expr *End) { this->End = End; }
+
+  SourceLocation getPrefetchKindLoc() const { return KindLoc; }
+  void setPrefetchKindLoc(SourceLocation Loc) { KindLoc = Loc; }
+  SourceLocation getFirstColonLoc() const { return FirstColonLoc; }
+  SourceLocation getSecondColonLoc() const { return SecondColonLoc; }
+
+};
+
 } // end namespace clang
 
 #endif
Index: include/clang/AST/Prefetch.h
===================================================================
--- include/clang/AST/Prefetch.h	(nonexistent)
+++ include/clang/AST/Prefetch.h	(working copy)
@@ -0,0 +1,38 @@
+//===--- Prefetch.h - Prefetching classes for Popcorn Linux -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines classes for enabling prefetching analysis & instrumentation
+// on Popcorn Linux.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_AST_PREFETCH_H
+#define LLVM_CLANG_AST_PREFETCH_H
+
+namespace clang {
+
+/// Statements for which prefetching analysis & instrumentation can be performed
+/// should inherit this class.
+class Prefetchable {
+protected:
+  /// \brief Whether prefetching has been enabled for the statement.
+  bool PrefetchEnabled;
+
+public:
+  Prefetchable(bool PrefetchEnabled = false)
+    : PrefetchEnabled(PrefetchEnabled) {}
+
+  void setPrefetchEnabled(bool Enable) { PrefetchEnabled = Enable; }
+  bool prefetchEnabled() const { return PrefetchEnabled; }
+};
+
+} // end namespace clang
+
+#endif
+
Index: include/clang/AST/PrefetchAnalysis.h
===================================================================
--- include/clang/AST/PrefetchAnalysis.h	(nonexistent)
+++ include/clang/AST/PrefetchAnalysis.h	(working copy)
@@ -0,0 +1,92 @@
+//===- PrefetchAnalysis.h - Prefetching Analysis for Statements ---*- C++ --*-//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interface for prefetching analysis over structured
+// blocks.  The analysis traverses the AST to determine how arrays are accessed
+// in structured blocks and generates expressions defining ranges of elements
+// accessed inside arrays.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_AST_PREFETCHANALYSIS_H
+#define LLVM_CLANG_AST_PREFETCHANALYSIS_H
+
+#include "clang/AST/Decl.h"
+#include "clang/AST/Expr.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/Support/raw_ostream.h"
+
+namespace clang {
+
+class ASTContext;
+
+/// A range of memory to be prefetched.
+class PrefetchRange {
+public:
+  /// Access type for array.
+  enum Type { Read, Write };
+
+  PrefetchRange(enum Type Ty, VarDecl *Array, Expr *Start, Expr *End)
+    : Ty(Ty), Array(Array), Start(Start), End(End) {}
+
+  enum Type getType() const { return Ty; }
+  VarDecl *getArray() const { return Array; }
+  Expr *getStart() const { return Start; }
+  Expr *getEnd() const { return End; }
+  void setType(enum Type Ty) { this->Ty = Ty; }
+  void setArray(VarDecl *Array) { this->Array = Array; }
+  void setStart(Expr *Start) { this->Start = Start; }
+  void setEnd(Expr *Start) { this->End = End; }
+
+  // TODO print & dump
+  const char *getTypeName() const {
+    switch(Ty) {
+    case Read: return "read";
+    case Write: return "write";
+    default: return "unknown";
+    }
+  }
+
+private:
+  enum Type Ty;
+  VarDecl *Array;
+  Expr *Start, *End;
+};
+
+class PrefetchAnalysis {
+public:
+  /// Default constructor, really only defined to enable storage in a DenseMap.
+  PrefetchAnalysis() : S(nullptr) {}
+
+  /// Construct a new prefetch analysis object to analyze a statement.  Doesn't
+  /// run the analysis.
+  PrefetchAnalysis(Stmt *S) : S(S) {}
+
+  /// Analyze the statement.
+  void analyzeStmt();
+
+  /// Get prefetch ranges discovered by analysis.
+  const SmallVector<PrefetchRange, 8> &getArraysToPrefetch() const
+  { return ToPrefetch; }
+
+  void print(llvm::raw_ostream &O, ASTContext &Ctx) const;
+  void dump(ASTContext &Ctx) const { print(llvm::errs(), Ctx); }
+
+private:
+  Stmt *S;
+  llvm::SmallVector<PrefetchRange, 8> ToPrefetch;
+
+  /// Analyze individual types of statements.
+  void analyzeForStmt();
+};
+
+} // end namespace clang
+
+#endif
+
Index: include/clang/AST/RecursiveASTVisitor.h
===================================================================
--- include/clang/AST/RecursiveASTVisitor.h	(revision 320332)
+++ include/clang/AST/RecursiveASTVisitor.h	(working copy)
@@ -2695,6 +2695,14 @@
   return true;
 }
 
+template <typename Derived>
+bool RecursiveASTVisitor<Derived>::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  TRY_TO(VisitOMPClauseList(C));
+  TRY_TO(TraverseStmt(C->getStartOfRange()));
+  TRY_TO(TraverseStmt(C->getEndOfRange()));
+  return true;
+}
+
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
 // returning decls or qualtypes or nestednamespecifier -- though I'm
Index: include/clang/AST/Stmt.h
===================================================================
--- include/clang/AST/Stmt.h	(revision 320332)
+++ include/clang/AST/Stmt.h	(working copy)
@@ -16,6 +16,7 @@
 
 #include "clang/AST/DeclGroup.h"
 #include "clang/AST/StmtIterator.h"
+#include "clang/AST/Prefetch.h"
 #include "clang/Basic/CapturedStmt.h"
 #include "clang/Basic/IdentifierTable.h"
 #include "clang/Basic/LLVM.h"
@@ -1141,7 +1142,7 @@
 /// the init/cond/inc parts of the ForStmt will be null if they were not
 /// specified in the source.
 ///
-class ForStmt : public Stmt {
+class ForStmt : public Stmt, public Prefetchable {
   SourceLocation ForLoc;
   enum { INIT, CONDVAR, COND, INC, BODY, END_EXPR };
   Stmt* SubExprs[END_EXPR]; // SubExprs[INIT] is an expression or declstmt.
@@ -2069,6 +2070,12 @@
   /// \brief The record for captured variables, a RecordDecl or CXXRecordDecl.
   RecordDecl *TheRecordDecl;
 
+  /// \brief For captured OpenMP parallel regions, variables declared in the
+  /// shared clause may be stored on the main thread's stack.  This causes
+  /// false sharing in Popcorn's distributed execution.  If set, offload shared
+  /// variables to global memory for the capture.
+  bool OffloadShared;
+
   /// \brief Construct a captured statement.
   CapturedStmt(Stmt *S, CapturedRegionKind Kind, ArrayRef<Capture> Captures,
                ArrayRef<Expr *> CaptureInits, CapturedDecl *CD, RecordDecl *RD);
@@ -2134,6 +2141,10 @@
   /// \brief True if this variable has been captured.
   bool capturesVariable(const VarDecl *Var) const;
 
+  /// \brief Getters/setters for the offloading shared variables flag
+  bool offloadShared() const { return OffloadShared; }
+  void setOffloadShared(bool OS) { OffloadShared = OS; }
+
   /// \brief An iterator that walks over the captures.
   typedef Capture *capture_iterator;
   typedef const Capture *const_capture_iterator;
Index: include/clang/AST/StmtOpenMP.h
===================================================================
--- include/clang/AST/StmtOpenMP.h	(revision 320332)
+++ include/clang/AST/StmtOpenMP.h	(working copy)
@@ -42,6 +42,8 @@
   const unsigned NumClauses;
   /// \brief Number of child expressions/stmts.
   const unsigned NumChildren;
+  /// \brief Enable prefetching code generation for Popcorn Linux
+  bool Prefetch;
   /// \brief Offset from this to the start of clauses.
   /// There are NumClauses pointers to clauses, they are followed by
   /// NumChildren pointers to child stmts/exprs (if the directive type
@@ -69,7 +71,7 @@
                          unsigned NumClauses, unsigned NumChildren)
       : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),
         EndLoc(std::move(EndLoc)), NumClauses(NumClauses),
-        NumChildren(NumChildren),
+        NumChildren(NumChildren), Prefetch(false),
         ClausesOffset(llvm::RoundUpToAlignment(sizeof(T),
                                                llvm::alignOf<OMPClause *>())) {}
 
@@ -205,6 +207,9 @@
   ArrayRef<OMPClause *> clauses() const {
     return const_cast<OMPExecutableDirective *>(this)->getClauses();
   }
+
+  bool prefetchingEnabled() const { return Prefetch; }
+  void setPrefetching(bool Prefetch) { this->Prefetch = Prefetch; }
 };
 
 /// \brief This represents '#pragma omp parallel' directive.
Index: include/clang/Basic/DiagnosticParseKinds.td
===================================================================
--- include/clang/Basic/DiagnosticParseKinds.td	(revision 320332)
+++ include/clang/Basic/DiagnosticParseKinds.td	(working copy)
@@ -993,6 +993,14 @@
   "'#pragma omp %0' cannot be an immediate substatement">;
 def err_omp_expected_identifier_for_critical : Error<
   "expected identifier specifying the name of the 'omp critical' directive">;
+def err_omp_invalid_prefetch_kind : Error<
+  "invalid argument; expected 'read' or 'write'">;
+// TODO Technically these are semantics issues, but we're doing checking in the
+// parser for this particular clause
+def err_omp_invalid_prefetch_capture : Error<
+  "can only prefetch variables used in the loop body">;
+def err_omp_invalid_prefetch_loop_var : Error<
+  "can only prefetch loop iteration range using a loop iteration variable">;
 
 // Pragma loop support.
 def err_pragma_loop_missing_argument : Error<
@@ -1008,6 +1016,18 @@
 def warn_pragma_unroll_cuda_value_in_parens : Warning<
   "argument to '#pragma unroll' should not be in parentheses in CUDA C/C++">,
   InGroup<CudaCompat>;
+
+// Pragma popcorn support.
+def warn_pragma_popcorn_ignored : Warning<
+  "Popcorn: unexpected '#pragma popcorn...' in program">, DefaultIgnore;
+def warn_pragma_popcorn_no_arg : Warning<
+  "Popcorn: missing argument; expected 'prefetch'">;
+def warn_pragma_popcorn_invalid_option : Warning<
+  "Popcorn: invalid pragma argument '%0'; expected 'prefetch'">;
+
+// Pragma popcorn prefetch support.
+def warn_pragma_popcorn_prefetch_invalid_stmt : Warning<
+  "Popcorn: cannot prefetch for this statement">;
 } // end of Parse Issue category.
 
 let CategoryName = "Modules Issue" in {
Index: include/clang/Basic/DiagnosticSemaKinds.td
===================================================================
--- include/clang/Basic/DiagnosticSemaKinds.td	(revision 320332)
+++ include/clang/Basic/DiagnosticSemaKinds.td	(working copy)
@@ -7649,6 +7649,10 @@
   "parent region for 'omp %select{cancellation point/cancel}0' construct cannot be nowait">;
 def err_omp_parent_cancel_region_ordered : Error<
   "parent region for 'omp %select{cancellation point/cancel}0' construct cannot be ordered">;
+def err_omp_invalid_prefetch_var_type : Error<
+  "invalid variable type; must be %0 type">;
+def err_omp_invalid_prefetch_range_type : Error<
+  "invalid range specifier type; must be of integer (signed or unsigned) type">;
 } // end of OpenMP category
 
 let CategoryName = "Related Result Type Issue" in {
Index: include/clang/Basic/LangOptions.def
===================================================================
--- include/clang/Basic/LangOptions.def	(revision 320332)
+++ include/clang/Basic/LangOptions.def	(working copy)
@@ -230,6 +230,9 @@
                                            "field padding (0: none, 1:least "
                                            "aggressive, 2: more aggressive)")
 
+// Optimize OpenMP code generation for distributed execution on Popcorn Linux
+BENIGN_LANGOPT(DistributedOmp, 1, 0, "Optimize OpenMP for distributed execution")
+
 #undef LANGOPT
 #undef COMPATIBLE_LANGOPT
 #undef BENIGN_LANGOPT
Index: include/clang/Basic/OpenMPKinds.def
===================================================================
--- include/clang/Basic/OpenMPKinds.def	(revision 320332)
+++ include/clang/Basic/OpenMPKinds.def	(working copy)
@@ -72,6 +72,9 @@
 #ifndef OPENMP_DEPEND_KIND
 #define OPENMP_DEPEND_KIND(Name)
 #endif
+#ifndef OPENMP_PREFETCH_KIND
+#define OPENMP_PREFETCH_KIND(Name)
+#endif
 
 // OpenMP directives.
 OPENMP_DIRECTIVE(threadprivate)
@@ -129,6 +132,7 @@
 OPENMP_CLAUSE(capture, OMPCaptureClause)
 OPENMP_CLAUSE(seq_cst, OMPSeqCstClause)
 OPENMP_CLAUSE(depend, OMPDependClause)
+OPENMP_CLAUSE(prefetch, OMPPrefetchClause)
 
 // Clauses allowed for OpenMP directive 'parallel'.
 OPENMP_PARALLEL_CLAUSE(if)
@@ -159,6 +163,7 @@
 OPENMP_FOR_CLAUSE(schedule)
 OPENMP_FOR_CLAUSE(ordered)
 OPENMP_FOR_CLAUSE(nowait)
+OPENMP_FOR_CLAUSE(prefetch)
 
 // Clauses allowed for directive 'omp for simd'.
 OPENMP_FOR_SIMD_CLAUSE(private)
@@ -171,6 +176,7 @@
 OPENMP_FOR_SIMD_CLAUSE(safelen)
 OPENMP_FOR_SIMD_CLAUSE(linear)
 OPENMP_FOR_SIMD_CLAUSE(aligned)
+OPENMP_FOR_SIMD_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'omp sections'.
 OPENMP_SECTIONS_CLAUSE(private)
@@ -206,6 +212,10 @@
 OPENMP_DEPEND_KIND(out)
 OPENMP_DEPEND_KIND(inout)
 
+// Static attributes for 'prefetch' clause.
+OPENMP_PREFETCH_KIND(read)
+OPENMP_PREFETCH_KIND(write)
+
 // Clauses allowed for OpenMP directive 'parallel for'.
 OPENMP_PARALLEL_FOR_CLAUSE(if)
 OPENMP_PARALLEL_FOR_CLAUSE(num_threads)
@@ -220,6 +230,7 @@
 OPENMP_PARALLEL_FOR_CLAUSE(collapse)
 OPENMP_PARALLEL_FOR_CLAUSE(schedule)
 OPENMP_PARALLEL_FOR_CLAUSE(ordered)
+OPENMP_PARALLEL_FOR_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'parallel for simd'.
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(if)
@@ -237,6 +248,7 @@
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(safelen)
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(linear)
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(aligned)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'parallel sections'.
 OPENMP_PARALLEL_SECTIONS_CLAUSE(if)
@@ -280,6 +292,7 @@
 OPENMP_TEAMS_CLAUSE(shared)
 OPENMP_TEAMS_CLAUSE(reduction)
 
+#undef OPENMP_PREFETCH_KIND
 #undef OPENMP_DEPEND_KIND
 #undef OPENMP_SCHEDULE_KIND
 #undef OPENMP_PROC_BIND_KIND
Index: include/clang/Basic/OpenMPKinds.h
===================================================================
--- include/clang/Basic/OpenMPKinds.h	(revision 320332)
+++ include/clang/Basic/OpenMPKinds.h	(working copy)
@@ -70,6 +70,14 @@
   OMPC_DEPEND_unknown
 };
 
+/// \brief OpenMP attributes for 'prefetch' clause.
+enum OpenMPPrefetchClauseKind {
+#define OPENMP_PREFETCH_KIND(Name) \
+  OMPC_PREFETCH_##Name,
+#include "clang/Basic/OpenMPKinds.def"
+  OMPC_PREFETCH_unknown
+};
+
 OpenMPDirectiveKind getOpenMPDirectiveKind(llvm::StringRef Str);
 const char *getOpenMPDirectiveName(OpenMPDirectiveKind Kind);
 
Index: include/clang/Basic/TokenKinds.def
===================================================================
--- include/clang/Basic/TokenKinds.def	(revision 320332)
+++ include/clang/Basic/TokenKinds.def	(working copy)
@@ -752,6 +752,12 @@
 ANNOTATION(module_begin)
 ANNOTATION(module_end)
 
+// Annotations for Popcorn Linux - #pragma popcorn ...
+// The lexer produces these so that they only take effect when the parser
+// handles #pragma popcorn ... directives.
+ANNOTATION(pragma_popcorn_prefetch)
+ANNOTATION(pragma_popcorn_prefetch_end)
+
 #undef ANNOTATION
 #undef TESTING_KEYWORD
 #undef OBJC2_AT_KEYWORD
Index: include/clang/CodeGen/BackendUtil.h
===================================================================
--- include/clang/CodeGen/BackendUtil.h	(revision 320332)
+++ include/clang/CodeGen/BackendUtil.h	(working copy)
@@ -28,13 +28,32 @@
     Backend_EmitLL,        ///< Emit human-readable LLVM assembly
     Backend_EmitNothing,   ///< Don't emit anything (benchmarking mode)
     Backend_EmitMCNull,    ///< Run CodeGen, but don't emit anything
-    Backend_EmitObj        ///< Emit native object files
+    Backend_EmitObj,       ///< Emit native object files
+    Backend_EmitMultiObj   ///< Emit native object files for multiple ISAs
   };
 
+  /// Run both IR optimization passes and backend passes to generate code
   void EmitBackendOutput(DiagnosticsEngine &Diags, const CodeGenOptions &CGOpts,
                          const TargetOptions &TOpts, const LangOptions &LOpts,
                          StringRef TDesc, llvm::Module *M, BackendAction Action,
                          raw_pwrite_stream *OS);
+
+  /// Run IR optimization passes
+  void ApplyIROptimizations(DiagnosticsEngine &Diags,
+                            const CodeGenOptions &CGOpts,
+                            const TargetOptions &TOpts,
+                            const LangOptions &LOpts,
+                            llvm::Module *M, BackendAction Action,
+                            raw_pwrite_stream *OS);
+
+  /// Run backend code-generation passes
+  void CodegenBackendOutput(DiagnosticsEngine &Diags,
+                            const CodeGenOptions &CGOpts,
+                            const TargetOptions &TOpts,
+                            const LangOptions &LOpts,
+                            StringRef TDesc, llvm::Module *M,
+                            BackendAction Action,
+                            raw_pwrite_stream *OS);
 }
 
 #endif
Index: include/clang/CodeGen/CodeGenAction.h
===================================================================
--- include/clang/CodeGen/CodeGenAction.h	(revision 320332)
+++ include/clang/CodeGen/CodeGenAction.h	(working copy)
@@ -11,6 +11,7 @@
 #define LLVM_CLANG_CODEGEN_CODEGENACTION_H
 
 #include "clang/Frontend/FrontendAction.h"
+#include "clang/CodeGen/BackendUtil.h"
 #include <memory>
 
 namespace llvm {
@@ -20,9 +21,10 @@
 
 namespace clang {
 class BackendConsumer;
+class CoverageSourceInfo;
 
 class CodeGenAction : public ASTFrontendAction {
-private:
+protected:
   unsigned Act;
   std::unique_ptr<llvm::Module> TheModule;
   llvm::Module *LinkModule;
@@ -29,7 +31,6 @@
   llvm::LLVMContext *VMContext;
   bool OwnsVMContext;
 
-protected:
   /// Create a new code generation action.  If the optional \p _VMContext
   /// parameter is supplied, the action uses it without taking ownership,
   /// otherwise it creates a fresh LLVM context and takes ownership.
@@ -37,6 +38,14 @@
 
   bool hasIRSupport() const override;
 
+  /// Helpers called in CreateASTConsumer
+  llvm::Module *getLinkModuleToUse(CompilerInstance &CI);
+  CoverageSourceInfo *getCoverageInfo(CompilerInstance &CI);
+
+  /// Helper called in ExecuteAction.  Returns true if the compilation is
+  /// invalid and should therefore be aborted.
+  bool ExecuteActionIRCommon(BackendAction &BA, CompilerInstance &CI);
+
   std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
                                                  StringRef InFile) override;
 
@@ -98,6 +107,23 @@
   EmitObjAction(llvm::LLVMContext *_VMContext = nullptr);
 };
 
+/// Emit multiple object files using a single set of IR.  Used by the Popcorn
+/// Linux compiler toolchain.
+class EmitMultiObjAction : public CodeGenAction {
+  virtual void anchor();
+  SmallVector<std::string, 2> Targets;
+  SmallVector<raw_pwrite_stream *, 2> OutFiles;
+  SmallVector<std::shared_ptr<TargetOptions>, 2> TargetOpts;
+  SmallVector<TargetInfo *, 2> TargetInfos;
+protected:
+  bool InitializeTargets(CompilerInstance &CI, StringRef InFile);
+  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
+                                                 StringRef InFile) override;
+  void ExecuteAction() override;
+public:
+  EmitMultiObjAction(llvm::LLVMContext *_VMContext = nullptr);
+};
+
 }
 
 #endif
Index: include/clang/CodeGen/PopcornUtil.h
===================================================================
--- include/clang/CodeGen/PopcornUtil.h	(nonexistent)
+++ include/clang/CodeGen/PopcornUtil.h	(working copy)
@@ -0,0 +1,47 @@
+//===--- PopcornUtil.h - Popcorn Linux Utilities ----------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_CODEGEN_POPCORNUTIL_H
+#define LLVM_CLANG_CODEGEN_POPCORNUTIL_H
+
+#include <llvm/ADT/StringRef.h>
+#include <llvm/IR/Module.h>
+#include <clang/Basic/TargetOptions.h>
+#include <memory>
+
+namespace clang {
+namespace Popcorn {
+
+/// Return whether a given target is supported by the compiler.
+bool SupportedTarget(const llvm::StringRef Target);
+
+/// Populate an array with all targets currently supported by the Popcorn
+/// compiler.
+void GetAllTargets(llvm::SmallVector<std::string, 2> &Targets);
+
+/// Return a TargetOptions with features appropriate for Popcorn Linux
+std::shared_ptr<TargetOptions>
+GetPopcornTargetOpts(const llvm::StringRef TripleStr);
+
+/// Strip target-specific CPUs & features from function attributes in all
+/// functions in the module.  This silences warnings from the compiler about
+/// unsupported target features when compiling the IR for multiple
+/// architectures.
+void StripTargetAttributes(llvm::Module &M);
+
+
+/// Add the target-features attribute specified in TargetOpts to every function
+/// in module M.
+void AddArchSpecificTargetFeatures(llvm::Module &M,
+                                   std::shared_ptr<TargetOptions> TargetOpts);
+
+} /* end Popcorn namespace */
+} /* end clang namespace */
+
+#endif
Index: include/clang/CodeGen/PrefetchBuilder.h
===================================================================
--- include/clang/CodeGen/PrefetchBuilder.h	(nonexistent)
+++ include/clang/CodeGen/PrefetchBuilder.h	(working copy)
@@ -0,0 +1,55 @@
+//===- Prefetch.h - Prefetching Analysis for Statements -----------*- C++ --*-//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interface for building prefetching calls based on the
+// prefetching analysis.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_CODEGEN_PREFETCHBUILDER_H
+#define LLVM_CLANG_CODEGEN_PREFETCHBUILDER_H
+
+#include "CodeGenFunction.h"
+#include "clang/AST/PrefetchAnalysis.h"
+#include "llvm/Support/raw_ostream.h"
+
+namespace clang {
+
+/// Generate calls to the prefetching API for analyzed regions.
+class PrefetchBuilder {
+public:
+  PrefetchBuilder(clang::CodeGen::CodeGenFunction *CGF)
+    : CGM(CGF->CGM), CGF(*CGF), Ctx(CGF->getContext()) {}
+
+  /// Emit prefetching API declarations.
+  void EmitPrefetchCallDeclarations();
+
+  /// Emit a prefetch call for a particular range of memory.
+  void EmitPrefetchCall(const PrefetchRange &P);
+
+  /// Emit a call to send the prefetch requests to the OS.
+  void EmitPrefetchExecuteCall();
+
+  // TODO print & dump
+
+private:
+  clang::CodeGen::CodeGenModule &CGM;
+  clang::CodeGen::CodeGenFunction &CGF;
+  ASTContext &Ctx;
+
+  // Prefetch API declarations
+  llvm::Constant *Prefetch, *Execute;
+
+  Expr *buildArrayIndexAddress(VarDecl *Base, Expr *Subscript);
+};
+
+} // end namespace clang
+
+#endif
+
Index: include/clang/Driver/Options.td
===================================================================
--- include/clang/Driver/Options.td	(revision 320332)
+++ include/clang/Driver/Options.td	(working copy)
@@ -83,6 +83,8 @@
 def m_libc_Group          : OptionGroup<"<m libc group>">, Group<m_Group>;
 def u_Group               : OptionGroup<"<u group>">;
 
+def Popcorn_Target_Group  : OptionGroup<"<Popcorn target group>">, Group<CompileOnly_Group>;
+
 def pedantic_Group        : OptionGroup<"<pedantic group>">,
   Group<CompileOnly_Group>;
 def reserved_lib_Group   : OptionGroup<"<reserved libs group>">;
@@ -1538,6 +1540,12 @@
 def pg : Flag<["-"], "pg">, HelpText<"Enable mcount instrumentation">, Flags<[CC1Option]>;
 def pipe : Flag<["-", "--"], "pipe">,
   HelpText<"Use pipes between commands, when possible">;
+def popcorn_migratable : Flag<["-"], "popcorn-migratable">, HelpText<"Instrument code to be migratable on Popcorn Linux (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_metadata : Flag<["-"], "popcorn-metadata">, HelpText<"Generate stack transformation metadata without inserting migration points (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_libc : Flag<["-"], "popcorn-libc">, HelpText<"Compile libc code with appropriate instrumentation for migration (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_alignment : Flag<["-"], "popcorn-alignment">, HelpText<"Run Popcorn passes to prepare for link-time symbol alignment">, Flags<[CC1Option]>;
+def popcorn_target : Joined<["-"], "popcorn-target=">, HelpText<"Targets for which to generate object files (requires -popcorn-migratable)">, Group<Popcorn_Target_Group>, Flags<[CC1Option]>, MetaVarName<"<target>">;
+def distributed_omp : Flag<["-"], "distributed-omp">, HelpText<"Optimize OpenMP code generation for distributed execution on Popcorn Linux">, Flags<[CC1Option]>;
 def prebind__all__twolevel__modules : Flag<["-"], "prebind_all_twolevel_modules">;
 def prebind : Flag<["-"], "prebind">;
 def preload : Flag<["-"], "preload">;
Index: include/clang/Frontend/CodeGenOptions.def
===================================================================
--- include/clang/Frontend/CodeGenOptions.def	(revision 320332)
+++ include/clang/Frontend/CodeGenOptions.def	(working copy)
@@ -158,6 +158,12 @@
 
 CODEGENOPT(EmitLLVMUseLists, 1, 0) ///< Control whether to serialize use-lists.
 
+/// Select places inside functions to instrument with migration points
+CODEGENOPT(PopcornMigratable, 1, 0)
+
+/// Adjust linkage of global values for symbol alignment
+CODEGENOPT(PopcornAlignment, 1, 0)
+
 /// The user specified number of registers to be used for integral arguments,
 /// or 0 if unspecified.
 VALUE_CODEGENOPT(NumRegisterParameters, 32, 0)
Index: include/clang/Frontend/CodeGenOptions.h
===================================================================
--- include/clang/Frontend/CodeGenOptions.h	(revision 320332)
+++ include/clang/Frontend/CodeGenOptions.h	(working copy)
@@ -201,6 +201,9 @@
   /// Set of sanitizer checks that trap rather than diagnose.
   SanitizerSet SanitizeTrap;
 
+  /// Targets for which to emit object code
+  std::vector<std::string> PopcornTargets;
+
 public:
   // Define accessors/mutators for code generation options of enumeration type.
 #define CODEGENOPT(Name, Bits, Default)
Index: include/clang/Frontend/CompilerInstance.h
===================================================================
--- include/clang/Frontend/CompilerInstance.h	(revision 320332)
+++ include/clang/Frontend/CompilerInstance.h	(working copy)
@@ -260,6 +260,13 @@
     return Invocation->getCodeGenOpts();
   }
 
+  CodeGenOptions &getCodeGenNoOpts() {
+    return Invocation->getCodeGenNoOpts();
+  }
+  const CodeGenOptions &getCodeGenNoOpts() const {
+    return Invocation->getCodeGenNoOpts();
+  }
+
   DependencyOutputOptions &getDependencyOutputOpts() {
     return Invocation->getDependencyOutputOpts();
   }
Index: include/clang/Frontend/CompilerInvocation.h
===================================================================
--- include/clang/Frontend/CompilerInvocation.h	(revision 320332)
+++ include/clang/Frontend/CompilerInvocation.h	(working copy)
@@ -108,6 +108,9 @@
   /// Options controlling IRgen and the backend.
   CodeGenOptions CodeGenOpts;
 
+  /// Options controlling IRgen and the backend (with optimization disabled).
+  CodeGenOptions CodeGenOptsNoOpt;
+
   /// Options controlling dependency output.
   DependencyOutputOptions DependencyOutputOpts;
 
@@ -179,6 +182,11 @@
     return CodeGenOpts;
   }
 
+  CodeGenOptions &getCodeGenNoOpts() { return CodeGenOptsNoOpt; }
+  const CodeGenOptions &getCodeGenNoOpts() const {
+    return CodeGenOptsNoOpt;
+  }
+
   DependencyOutputOptions &getDependencyOutputOpts() {
     return DependencyOutputOpts;
   }
Index: include/clang/Frontend/FrontendOptions.h
===================================================================
--- include/clang/Frontend/FrontendOptions.h	(revision 320332)
+++ include/clang/Frontend/FrontendOptions.h	(working copy)
@@ -37,6 +37,7 @@
     EmitLLVMOnly,           ///< Generate LLVM IR, but do not emit anything.
     EmitCodeGenOnly,        ///< Generate machine code, but don't emit anything.
     EmitObj,                ///< Emit a .o file.
+    EmitMultiObj,           ///< Emit a .o file for multiple ISAs.
     FixIt,                  ///< Parse and apply any fixits to the source.
     GenerateModule,         ///< Generate pre-compiled module.
     GeneratePCH,            ///< Generate pre-compiled header.
Index: include/clang/Parse/Parser.h
===================================================================
--- include/clang/Parse/Parser.h	(revision 320332)
+++ include/clang/Parse/Parser.h	(working copy)
@@ -167,6 +167,7 @@
   std::unique_ptr<PragmaHandler> LoopHintHandler;
   std::unique_ptr<PragmaHandler> UnrollHintHandler;
   std::unique_ptr<PragmaHandler> NoUnrollHintHandler;
+  std::unique_ptr<PragmaHandler> PopcornHandler;
 
   std::unique_ptr<CommentHandler> CommentSemaHandler;
 
@@ -528,6 +529,10 @@
   /// #pragma clang loop and #pragma unroll.
   bool HandlePragmaLoopHint(LoopHint &Hint);
 
+  /// \brief Handle the annotation token produced for
+  /// #pragma popcorn...
+  StmtResult HandlePragmaPopcorn();
+
   /// GetLookAheadToken - This peeks ahead N tokens and returns that token
   /// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)
   /// returns the token after Tok, etc.
@@ -2418,6 +2423,10 @@
 
   //===--------------------------------------------------------------------===//
   // OpenMP: Directives and clauses.
+  /// \brief Checks 'prefetch' clauses for correctness.  Note that we can only
+  /// perform some semantic checks *after* the entire compound statement
+  /// representing the directive's body has been parsed.
+  void CheckOpenMPPrefetchClauses(StmtResult Directive);
   /// \brief Parses declarative OpenMP directives.
   DeclGroupPtrTy ParseOpenMPDeclarativeDirective();
   /// \brief Parses simple list of variables.
Index: include/clang/Sema/Sema.h
===================================================================
--- include/clang/Sema/Sema.h	(revision 320332)
+++ include/clang/Sema/Sema.h	(working copy)
@@ -7950,11 +7950,12 @@
 
   OMPClause *ActOnOpenMPVarListClause(
       OpenMPClauseKind Kind, ArrayRef<Expr *> Vars, Expr *TailExpr,
-      SourceLocation StartLoc, SourceLocation LParenLoc,
-      SourceLocation ColonLoc, SourceLocation EndLoc,
-      CXXScopeSpec &ReductionIdScopeSpec,
+      Expr *EndExpr, SourceLocation StartLoc, SourceLocation LParenLoc,
+      SourceLocation ColonLoc, SourceLocation EndColonLoc,
+      SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,
       const DeclarationNameInfo &ReductionId, OpenMPDependClauseKind DepKind,
-      SourceLocation DepLoc);
+      SourceLocation DepLoc, OpenMPPrefetchClauseKind PrefKind,
+      SourceLocation PrefLoc);
   /// \brief Called on well-formed 'private' clause.
   OMPClause *ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,
                                       SourceLocation StartLoc,
@@ -8018,6 +8019,18 @@
                           SourceLocation StartLoc, SourceLocation LParenLoc,
                           SourceLocation EndLoc);
 
+  /// \brief Called on well-formed 'prefetch' clause.
+  OMPClause *
+  ActOnOpenMPPrefetchClause(OpenMPPrefetchClauseKind PrefKind,
+                            SourceLocation PrefLoc,
+                            ArrayRef<Expr *> VarList,
+                            Expr *Start, Expr *End,
+                            SourceLocation StartLoc,
+                            SourceLocation LParenLoc,
+                            SourceLocation FirstColonLoc,
+                            SourceLocation SecondColonLoc,
+                            SourceLocation EndLoc);
+
   /// \brief The kind of conversion being performed.
   enum CheckedConversionKind {
     /// \brief An implicit conversion.
Index: lib/AST/CMakeLists.txt
===================================================================
--- lib/AST/CMakeLists.txt	(revision 320332)
+++ lib/AST/CMakeLists.txt	(working copy)
@@ -40,6 +40,7 @@
   NestedNameSpecifier.cpp
   NSAPI.cpp
   ParentMap.cpp
+  PrefetchAnalysis.cpp
   RawCommentList.cpp
   RecordLayout.cpp
   RecordLayoutBuilder.cpp
Index: lib/AST/PrefetchAnalysis.cpp
===================================================================
--- lib/AST/PrefetchAnalysis.cpp	(nonexistent)
+++ lib/AST/PrefetchAnalysis.cpp	(working copy)
@@ -0,0 +1,463 @@
+//=- PrefetchAnalysis.cpp - Prefetching Analysis for Structured Blocks ---*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements prefetching analysis for structured blocks.  The
+// analysis traverses the AST to determine how arrays are accessed in structured
+// blocks and generates expressions defining ranges of elements accessed.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/PrefetchAnalysis.h"
+#include "clang/AST/RecursiveASTVisitor.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/Support/Debug.h"
+#include <utility>
+
+using namespace clang;
+
+//===----------------------------------------------------------------------===//
+// Common utilities
+//
+
+/// Return whether a type is both scalar and integer.
+static bool isScalarIntType(const QualType &Ty) {
+  return Ty->isIntegerType() && Ty->isScalarType();
+}
+
+/// Return the variable declaration if the declared value is a variable and if
+/// it is a scalar integer type.
+static VarDecl *getVarIfScalarInt(ValueDecl *VD) {
+  if(isa<VarDecl>(VD)) {
+    VarDecl *Var = cast<VarDecl>(VD);
+    if(isScalarIntType(Var->getType())) return Var;
+  }
+  return nullptr;
+}
+
+// Filter functions to only select appropriate operator types.  Return true if
+// the operator is of a type that should be analyzed, or false otherwise.
+typedef bool (*UnaryOpFilter)(UnaryOperator::Opcode);
+typedef bool (*BinaryOpFilter)(BinaryOperator::Opcode);
+
+// Don't analyze *any* operation types.
+bool NoUnaryOp(UnaryOperator::Opcode Op) { return false; }
+bool NoBinaryOp(BinaryOperator::Opcode Op) { return false; }
+
+// Filter out non-assignment binary operations.
+bool FilterAssignOp(BinaryOperator::Opcode Op) {
+  switch(Op) {
+  case BO_Assign: case BO_MulAssign: case BO_DivAssign: case BO_RemAssign:
+  case BO_AddAssign: case BO_SubAssign: case BO_ShlAssign: case BO_ShrAssign:
+  case BO_AndAssign: case BO_XorAssign: case BO_OrAssign:
+    return true;
+  default: return false;
+  }
+}
+
+// Filter out non-relational binary operations.
+bool FilterRelationalOp(BinaryOperator::Opcode Op) {
+  switch(Op) {
+  case BO_LT: case BO_GT: case BO_LE: case BO_GE: case BO_EQ: case BO_NE:
+    return true;
+  default: return false;
+  }
+}
+
+// Filter out non-math/logic binary operations.
+bool FilterMathLogicOp(BinaryOperator::Opcode Op) {
+  switch(Op) {
+  case BO_Mul: case BO_Div: case BO_Rem: case BO_Add: case BO_Sub:
+  case BO_Shl: case BO_Shr: case BO_And: case BO_Xor: case BO_Or:
+    return true;
+  default: return false;
+  }
+}
+
+// Filter out non-math unary operations.
+bool FilterMathOp(UnaryOperator::Opcode Op) {
+  switch(Op) {
+  case UO_PostInc: case UO_PostDec: case UO_PreInc: case UO_PreDec:
+    return true;
+  default: return false;
+  }
+}
+
+/// A vector of variable declarations.
+typedef llvm::SmallVector<VarDecl *, 4> VarVec;
+
+/// An array access.
+class ArrayAccess {
+public:
+  ArrayAccess(VarDecl *Base, Expr *Idx) : Valid(true), Base(Base), Idx(Idx) {}
+
+  bool isValid() const { return Valid; }
+  VarDecl *getBase() const { return Base; }
+  Expr *getIndex() const { return Idx; }
+  const VarVec &getVarsInIdx() const { return VarsInIdx; }
+
+  void setInvalid() { Valid = false; }
+  void addVarInIdx(VarDecl *V) { if(V != Base) VarsInIdx.push_back(V); }
+
+  void print(llvm::raw_ostream &O, PrintingPolicy &Policy) const {
+    O << "Array: " << Base->getName() << "\n";
+    O << "Index expression: ";
+    Idx->printPretty(O, nullptr, Policy);
+    O << "\nVariables used in index calculation:";
+    for(auto Var : VarsInIdx) O << " " << Var->getName();
+    O << "\n";
+  }
+
+  void dump(PrintingPolicy &Policy) const { print(llvm::dbgs(), Policy); }
+
+private:
+  bool Valid;
+  VarDecl *Base; // The array base
+  Expr *Idx; // Expression used to calculate index
+  VarVec VarsInIdx; // Variables used in index calculation
+};
+
+/// Traverse a statement looking for array accesses.
+// TODO *** NEED TO LIMIT TO AFFINE ACCESSES ***
+class ArrayAccessPattern : public RecursiveASTVisitor<ArrayAccessPattern> {
+public:
+  /// Which sub-tree of a binary operator we're traversing.  This determines
+  /// whether we're reading or writing the array.
+  enum TraverseStructure { LHS, RHS, None };
+
+  /// Traverse a statement.  There's a couple of special traversal rules:
+  ///
+  ///  - If it's an assignment operation, record structure of the traversal
+  ///    before visiting each of the left & right sub-trees
+  ///  - If it's an array subscript, record all variables used to calculate
+  ///    the index
+  bool TraverseStmt(Stmt *S) {
+    BinaryOperator *BinOp = dyn_cast<BinaryOperator>(S);
+    ArraySubscriptExpr *Subscript = dyn_cast<ArraySubscriptExpr>(S);
+
+    if(BinOp && FilterAssignOp(BinOp->getOpcode())) {
+      Side = LHS;
+      RecursiveASTVisitor<ArrayAccessPattern>::TraverseStmt(BinOp->getLHS());
+      Side = RHS;
+      RecursiveASTVisitor<ArrayAccessPattern>::TraverseStmt(BinOp->getRHS());
+      Side = None;
+    }
+    else if(Subscript) {
+      RecursiveASTVisitor<ArrayAccessPattern>::TraverseStmt(S);
+      CurAccess = nullptr; // Don't record any more variables
+    }
+    else RecursiveASTVisitor<ArrayAccessPattern>::TraverseStmt(S);
+    return true;
+  }
+
+  /// Analyze an array access; in particular, the index.
+  bool VisitArraySubscriptExpr(ArraySubscriptExpr *Sub) {
+    Expr *Base = Sub->getBase(), *Idx = Sub->getIdx();
+    DeclRefExpr *DR;
+    VarDecl *VD;
+
+    assert(Side != None && "Unhandled tree structure");
+
+    DR = dyn_cast<DeclRefExpr>(Base->IgnoreImpCasts());
+    if(!DR) goto end;
+    VD = dyn_cast<VarDecl>(DR->getDecl());
+    if(!VD) goto end;
+    if(Side == LHS) {
+      ArrayWrites.emplace_back(VD, Idx);
+      CurAccess = &ArrayWrites.back();
+    }
+    else {
+      ArrayReads.emplace_back(VD, Idx);
+      CurAccess = &ArrayReads.back();
+    }
+end:
+    return true;
+  }
+
+  /// Record any variables seen during traversing
+  bool VisitDeclRefExpr(DeclRefExpr *DR) {
+    if(CurAccess) {
+      VarDecl *VD = dyn_cast<VarDecl>(DR->getDecl());
+      if(VD) CurAccess->addVarInIdx(VD);
+      else CurAccess->setInvalid(); // Can't analyze if decl != variable
+    }
+    return true;
+  }
+
+  const llvm::SmallVector<ArrayAccess, 8> &getArrayReads() const
+  { return ArrayReads; }
+  const llvm::SmallVector<ArrayAccess, 8> &getArrayWrites() const
+  { return ArrayWrites; }
+
+private:
+  llvm::SmallVector<ArrayAccess, 8> ArrayReads, ArrayWrites;
+
+  // Traversal state
+  enum TraverseStructure Side;
+  ArrayAccess *CurAccess;
+};
+
+//===----------------------------------------------------------------------===//
+// Prefetch analysis -- ForStmts
+//
+
+/// An induction variable and expressions describing its range.
+class InductionVariable {
+public:
+  /// The direction of change for the induction variable
+  enum Direction {
+    Increases, // Update changes variable from lower to higher values
+    Decreases, // Update changes variable from higher to lower values
+    Unknown // Update has an unknown effect, e.g., container interators
+  };
+
+  InductionVariable(VarDecl *Var, Expr *Init, Expr *Cond, Expr *Update)
+    : Var(Var), Init(Init), Cond(Cond), Update(Update), LowerB(nullptr),
+      UpperB(nullptr), Dir(Unknown) {
+
+    const UnaryOperator *Unary;
+    assert(getVarIfScalarInt(Var) && "Invalid induction variable");
+
+    // Try to classify update direction to determine upper/lower bounds
+    if((Unary = dyn_cast<UnaryOperator>(Update))) {
+      classifyUnaryOpDirection(Unary->getOpcode());
+      if(Dir != Unknown) goto end;
+    }
+
+end:
+    // TODO if update is a math/assign operator, e.g., +=, need to update
+    // bounds expression to *unwind*
+    if(Dir == Increases) {
+      LowerB = Init;
+      UpperB = Cond;
+    }
+    else if(Dir == Decreases) {
+      LowerB = Cond;
+      UpperB = Init;
+    }
+  }
+
+  VarDecl *getVariable() const { return Var; }
+  Expr *getInit() const { return Init; }
+  Expr *getCond() const { return Cond; }
+  Expr *getUpdate() const { return Update; }
+  Expr *getLowerBound() const { return LowerB; }
+  Expr *getUpperBound() const { return UpperB; }
+  enum Direction getUpdateDirection() const { return Dir; }
+
+  void print(llvm::raw_ostream &O, PrintingPolicy &Policy) const {
+    O << "Induction Variable: " << Var->getName() << "\n";
+    O << "Direction: ";
+    switch(Dir) {
+    case Increases: O << "increases\n"; break;
+    case Decreases: O << "decreases\n"; break;
+    case Unknown: O << "unknown update direction\n"; break;
+    }
+    if(LowerB) {
+      O << "Lower bound:\n";
+      LowerB->printPretty(O, nullptr, Policy);
+    }
+    if(UpperB) {
+      O << "Upper bound:\n";
+      UpperB->printPretty(O, nullptr, Policy);
+    }
+  }
+
+  void dump(PrintingPolicy &Policy) const { print(llvm::dbgs(), Policy); }
+
+private:
+  VarDecl *Var;
+  Expr *Init, *Cond, *Update;
+
+  /// Expressions describing the lower & upper bounds of the induction variable
+  /// and its update direction.
+  Expr *LowerB, *UpperB;
+  enum Direction Dir;
+
+  /// Try to classify the induction variable's update direction based on the
+  /// unary operation type.
+  void classifyUnaryOpDirection(UnaryOperator::Opcode Op) {
+    switch(Op) {
+    case UO_PostInc:
+    case UO_PreInc:
+      Dir = Increases;
+      break;
+    case UO_PostDec:
+    case UO_PreDec:
+      Dir = Decreases;
+      break;
+    default: break;
+    }
+  }
+};
+
+/// Map a variable declaration to the induction variable's information.
+typedef llvm::DenseMap<VarDecl *, InductionVariable> IVMap;
+typedef std::pair<VarDecl *, InductionVariable> IVPair;
+
+/// Map an induction variable to an expression describing a bound.
+typedef llvm::DenseMap<VarDecl *, Expr *> IVBoundMap;
+typedef std::pair<VarDecl *, Expr *> IVBoundPair;
+
+/// Traversal to find induction variables in loop initialization, condition and
+/// update expressions.
+template<UnaryOpFilter UnaryFilt, BinaryOpFilter BinaryFilt>
+class IVFinder : public RecursiveASTVisitor<IVFinder<UnaryFilt, BinaryFilt>> {
+public:
+  // Visit binary operators to find induction variables.
+  bool VisitBinaryOperator(BinaryOperator *B) {
+    Expr *LHS;
+    DeclRefExpr *DR;
+    VarDecl *Var;
+
+    // Filter out irrelevant operation types
+    if(!BinaryFilt(B->getOpcode())) goto end;
+
+    // Look for DeclRefExprs -- these reference induction variables
+    LHS = B->getLHS();
+    DR = dyn_cast<DeclRefExpr>(LHS->IgnoreImpCasts());
+    if(!DR) goto end;
+
+    // Make sure that both the expression acting on the induction variable &
+    // the variable itself are scalar integers (casts may change types)
+    Var = getVarIfScalarInt(DR->getDecl());
+    if(!isScalarIntType(LHS->getType()) || !Var) goto end;
+    InductionVars[Var] = B;
+end:
+    return true;
+  }
+
+  // Visit unary operators to find induction variables.
+  bool VisitUnaryOperator(UnaryOperator *U) {
+    Expr *SubExpr;
+    DeclRefExpr *DR;
+    VarDecl *Var;
+
+    // Filter out irrelevant operation types
+    if(!UnaryFilt(U->getOpcode())) goto end;
+
+    // Look for DeclRefExprs -- these reference induction variables
+    SubExpr = U->getSubExpr();
+    DR = dyn_cast<DeclRefExpr>(SubExpr->IgnoreImpCasts());
+    if(!DR) goto end;
+
+    // Make sure that both the expression acting on the induction variable &
+    // the variable itself are scalar integers (casts may change types)
+    Var = getVarIfScalarInt(DR->getDecl());
+    if(!isScalarIntType(SubExpr->getType()) || !Var) goto end;
+    InductionVars[Var] = U;
+end:
+    return true;
+  }
+
+  /// Return all induction variables found.
+  const IVBoundMap &getInductionVars() const { return InductionVars; }
+
+  /// Return the bounds expression for a given induction variable, or nullptr
+  /// if none was found.
+  Expr *getVarBound(VarDecl *Var) {
+    IVBoundMap::iterator it = InductionVars.find(Var);
+    if(it != InductionVars.end()) return it->second;
+    else return nullptr;
+  }
+
+private:
+  IVBoundMap InductionVars;
+};
+
+/// Search a for-loop statement for array access patterns based on loop
+/// induction variables that can be prefetched at runtime.
+void PrefetchAnalysis::analyzeForStmt() {
+  ForStmt *Loop = cast<ForStmt>(S);
+  Expr *InitExpr, *CondExpr, *UpdateExpr;
+  IVFinder<NoUnaryOp, FilterAssignOp> Init;
+  IVFinder<NoUnaryOp, FilterRelationalOp> Cond;
+  IVFinder<FilterMathOp, FilterMathLogicOp> Update;
+  IVMap IVs;
+  ArrayAccessPattern ArrAccesses;
+
+  // Start by finding the induction variables in the loop expressions.
+  Init.TraverseStmt(Loop->getInit());
+  Cond.TraverseStmt(Loop->getCond());
+  Update.TraverseStmt(Loop->getInc());
+
+  // Find induction variables which are referenced in all three
+  const IVBoundMap &InitVars = Init.getInductionVars();
+  for(auto IV = InitVars.begin(), E = InitVars.end(); IV != E; IV++) {
+    InitExpr = IV->second;
+    CondExpr = Cond.getVarBound(IV->first),
+    UpdateExpr = Update.getVarBound(IV->first);
+    if(InitExpr && CondExpr && UpdateExpr)
+      IVs.insert(IVPair(IV->first, InductionVariable(IV->first, InitExpr,
+                                                     CondExpr, UpdateExpr)));
+  }
+
+  // Look for array/pointer accesses based on induction variables
+  ArrAccesses.TraverseStmt(Loop->getBody());
+  for(auto &Read : ArrAccesses.getArrayReads()) {
+    bool AllInductionVars = true;
+    for(auto &Var : Read.getVarsInIdx())
+      if(!InitVars.count(Var)) AllInductionVars = false;
+
+    if(AllInductionVars) {
+      // TODO this is totally wrong for anything besides trivial accesses.  We
+      // need to do the following:
+      //
+      //  - Clone the array index expression sub-tree
+      //  - Generate 2 new expressions - one with the lower bound(s) of the
+      //    induction variable(s) and one with higher bound(s)
+      VarDecl *IdxVar = Read.getVarsInIdx()[0];
+      InductionVariable &VarInfo = IVs.find(IdxVar)->second;
+      Expr *LB = cast<BinaryOperator>(VarInfo.getLowerBound())->getRHS(),
+           *UB = cast<BinaryOperator>(VarInfo.getUpperBound())->getRHS();
+      ToPrefetch.emplace_back(PrefetchRange::Read, Read.getBase(), LB, UB);
+    }
+  }
+
+  for(auto &Write : ArrAccesses.getArrayWrites()) {
+    bool AllInductionVars = true;
+    for(auto &Var : Write.getVarsInIdx())
+      if(!InitVars.count(Var)) AllInductionVars = false;
+
+    if(AllInductionVars) {
+      // TODO this is totally wrong for anything besides trivial accesses.  We
+      // need to do the following:
+      //
+      //  - Clone the array index expression sub-tree
+      //  - Generate 2 new expressions - one with the lower bound(s) of the
+      //    induction variable(s) and one with higher bound(s)
+      VarDecl *IdxVar = Write.getVarsInIdx()[0];
+      InductionVariable &VarInfo = IVs.find(IdxVar)->second;
+      Expr *LB = cast<BinaryOperator>(VarInfo.getLowerBound())->getRHS(),
+           *UB = cast<BinaryOperator>(VarInfo.getUpperBound())->getRHS();
+      ToPrefetch.emplace_back(PrefetchRange::Write, Write.getBase(), LB, UB);
+    }
+  }
+}
+
+//===----------------------------------------------------------------------===//
+// Prefetch analysis API
+//
+
+void PrefetchAnalysis::analyzeStmt() {
+  // TODO other types of statements
+  if(isa<ForStmt>(S)) analyzeForStmt();
+}
+
+void PrefetchAnalysis::print(llvm::raw_ostream &O, ASTContext &Ctx) const {
+  PrintingPolicy Policy(Ctx.getLangOpts());
+  for(auto &Range : ToPrefetch) {
+    O << "Array '" << Range.getArray()->getName() << "': ";
+    Range.getStart()->printPretty(O, nullptr, Policy);
+    O << " to ";
+    Range.getEnd()->printPretty(O, nullptr, Policy);
+    O << " (" << Range.getTypeName() << ")\n";
+  }
+}
+
Index: lib/AST/Stmt.cpp
===================================================================
--- lib/AST/Stmt.cpp	(revision 320332)
+++ lib/AST/Stmt.cpp	(working copy)
@@ -1623,6 +1623,28 @@
   return nullptr;
 }
 
+OMPPrefetchClause *
+OMPPrefetchClause::Create(const ASTContext &C, OpenMPPrefetchClauseKind Kind,
+                          SourceLocation KindLoc, ArrayRef<Expr *> VL,
+                          Expr *Start, Expr *End, SourceLocation StartLoc,
+                          SourceLocation LParenLoc,
+                          SourceLocation FirstColonLoc,
+                          SourceLocation SecondColonLoc,
+                          SourceLocation EndLoc) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPPrefetchClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * VL.size());
+  OMPPrefetchClause *Clause =
+    new (Mem) OMPPrefetchClause(StartLoc, LParenLoc, FirstColonLoc, SecondColonLoc,
+                                EndLoc, VL.size());
+  Clause->setPrefetchKind(Kind);
+  Clause->setPrefetchKindLoc(KindLoc);
+  Clause->setStartOfRange(Start);
+  Clause->setEndOfRange(End);
+  Clause->setVarRefs(VL);
+  return Clause;
+}
+
 OMPParallelDirective *OMPParallelDirective::Create(
                                               const ASTContext &C,
                                               SourceLocation StartLoc,
Index: lib/AST/StmtPrinter.cpp
===================================================================
--- lib/AST/StmtPrinter.cpp	(revision 320332)
+++ lib/AST/StmtPrinter.cpp	(working copy)
@@ -810,7 +810,22 @@
     OS << ")";
   }
 }
+
+void OMPClausePrinter::VisitOMPPrefetchClause(OMPPrefetchClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "prefetch(";
+    OS << getOpenMPSimpleClauseTypeName(Node->getClauseKind(),
+                                        Node->getPrefetchKind())
+       << " :";
+    VisitOMPClauseList(Node, ' ');
+    OS << ",";
+    Node->getStartOfRange()->printPretty(OS, nullptr, Policy, 0);
+    OS << ",";
+    Node->getEndOfRange()->printPretty(OS, nullptr, Policy, 0);
+    OS << ")";
+  }
 }
+}
 
 //===----------------------------------------------------------------------===//
 //  OpenMP directives printing methods
Index: lib/AST/StmtProfile.cpp
===================================================================
--- lib/AST/StmtProfile.cpp	(revision 320332)
+++ lib/AST/StmtProfile.cpp	(working copy)
@@ -428,7 +428,12 @@
 void OMPClauseProfiler::VisitOMPDependClause(const OMPDependClause *C) {
   VisitOMPClauseList(C);
 }
+void OMPClauseProfiler::VisitOMPPrefetchClause(const OMPPrefetchClause *C) {
+  VisitOMPClauseList(C);
+  Profiler->VisitStmt(C->getStartOfRange());
+  Profiler->VisitStmt(C->getEndOfRange());
 }
+}
 
 void
 StmtProfiler::VisitOMPExecutableDirective(const OMPExecutableDirective *S) {
Index: lib/Basic/OpenMPKinds.cpp
===================================================================
--- lib/Basic/OpenMPKinds.cpp	(revision 320332)
+++ lib/Basic/OpenMPKinds.cpp	(working copy)
@@ -96,6 +96,11 @@
 #define OPENMP_DEPEND_KIND(Name) .Case(#Name, OMPC_DEPEND_##Name)
 #include "clang/Basic/OpenMPKinds.def"
         .Default(OMPC_DEPEND_unknown);
+  case OMPC_prefetch:
+    return llvm::StringSwitch<OpenMPPrefetchClauseKind>(Str)
+#define OPENMP_PREFETCH_KIND(Name) .Case(#Name, OMPC_PREFETCH_##Name)
+#include "clang/Basic/OpenMPKinds.def"
+        .Default(OMPC_PREFETCH_unknown);
   case OMPC_unknown:
   case OMPC_threadprivate:
   case OMPC_if:
@@ -195,6 +200,7 @@
   case OMPC_update:
   case OMPC_capture:
   case OMPC_seq_cst:
+  case OMPC_prefetch:
     break;
   }
   llvm_unreachable("Invalid OpenMP simple clause kind");
Index: lib/CodeGen/BackendUtil.cpp
===================================================================
--- lib/CodeGen/BackendUtil.cpp	(revision 320332)
+++ lib/CodeGen/BackendUtil.cpp	(working copy)
@@ -15,6 +15,7 @@
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Frontend/Utils.h"
 #include "llvm/ADT/StringSwitch.h"
+#include "llvm/Analysis/Passes.h"
 #include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
@@ -39,6 +40,7 @@
 #include "llvm/Transforms/Instrumentation.h"
 #include "llvm/Transforms/ObjCARC.h"
 #include "llvm/Transforms/Scalar.h"
+#include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/SymbolRewriter.h"
 #include <memory>
 using namespace clang;
@@ -132,6 +134,16 @@
 
   std::unique_ptr<TargetMachine> TM;
 
+  /// Set up the assembly helper, including gathering passes
+  void SetupAssemblyHelper(BackendAction Action,
+                           raw_pwrite_stream *OS);
+
+  /// Run only IR optimization passes on a module
+  void ApplyIROptPasses(Module* TheModule);
+
+  /// Run backend passes to generate code
+  void ApplyCodegenPasses(Module* TheModule);
+
   void EmitAssembly(BackendAction Action, raw_pwrite_stream *OS);
 };
 
@@ -271,6 +283,18 @@
   MPM->add(createRewriteSymbolsPass(DL));
 }
 
+static void addPopcornMigPointPasses(const PassManagerBuilder &Builder,
+                                     legacy::PassManagerBase &PM) {
+  PM.add(createPopcornCompatibilityPass());
+  PM.add(createSelectMigrationPointsPass());
+}
+
+static void addPopcornAlignmentPasses(const PassManagerBuilder &Builder,
+                                      legacy::PassManagerBase &PM) {
+  PM.add(createNameStringLiteralsPass());
+  PM.add(createStaticVarSectionsPass());
+}
+
 void EmitAssemblyHelper::CreatePasses() {
   unsigned OptLevel = CodeGenOpts.OptimizationLevel;
   CodeGenOptions::InliningMethod Inlining = CodeGenOpts.getInlining();
@@ -420,6 +444,29 @@
     MPM->add(createInstrProfilingPass(Options));
   }
 
+  // Popcorn Compiler Toolchain passes -- add after IR optimization passes
+  // Select migration points.
+  if (CodeGenOpts.PopcornMigratable) {
+    if (OptLevel > 0)
+      PMBuilder.addExtension(PassManagerBuilder::EP_OptimizerLast,
+                             addPopcornMigPointPasses);
+    else {
+      MPM->add(createPopcornCompatibilityPass());
+      MPM->add(createSelectMigrationPointsPass());
+    }
+  }
+
+  // Adjust global symbol linkage for alignment.
+  if (CodeGenOpts.PopcornAlignment) {
+    if (OptLevel > 0)
+      PMBuilder.addExtension(PassManagerBuilder::EP_OptimizerLast,
+                             addPopcornAlignmentPasses);
+    else {
+      MPM->add(createNameStringLiteralsPass());
+      MPM->add(createStaticVarSectionsPass());
+    }
+  }
+
   PMBuilder.populateModulePassManager(*MPM);
 }
 
@@ -570,7 +617,7 @@
   // Normal mode, emit a .s or .o file by running the code generator. Note,
   // this also adds codegenerator level optimization passes.
   TargetMachine::CodeGenFileType CGFT = TargetMachine::CGFT_AssemblyFile;
-  if (Action == Backend_EmitObj)
+  if (Action == Backend_EmitObj || Action == Backend_EmitMultiObj)
     CGFT = TargetMachine::CGFT_ObjectFile;
   else if (Action == Backend_EmitMCNull)
     CGFT = TargetMachine::CGFT_Null;
@@ -592,8 +639,8 @@
   return true;
 }
 
-void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
-                                      raw_pwrite_stream *OS) {
+void EmitAssemblyHelper::SetupAssemblyHelper(BackendAction Action,
+                                             raw_pwrite_stream *OS) {
   TimeRegion Region(llvm::TimePassesIsEnabled ? &CodeGenerationTime : nullptr);
 
   bool UsesCodeGen = (Action != Backend_EmitNothing &&
@@ -629,7 +676,9 @@
 
   // Before executing passes, print the final values of the LLVM options.
   cl::PrintOptionValues();
+}
 
+void EmitAssemblyHelper::ApplyIROptPasses(Module* M) {
   // Run passes. For now we do all passes at once, but eventually we
   // would like to have the option of streaming code generation.
 
@@ -647,7 +696,9 @@
     PrettyStackTraceString CrashInfo("Per-module optimization passes");
     PerModulePasses->run(*TheModule);
   }
+}
 
+void EmitAssemblyHelper::ApplyCodegenPasses(Module* M) {
   if (CodeGenPasses) {
     PrettyStackTraceString CrashInfo("Code generation");
     CodeGenPasses->run(*TheModule);
@@ -654,6 +705,13 @@
   }
 }
 
+void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
+                                      raw_pwrite_stream *OS) {
+  SetupAssemblyHelper(Action, OS);
+  ApplyIROptPasses(TheModule);
+  ApplyCodegenPasses(TheModule);
+}
+
 void clang::EmitBackendOutput(DiagnosticsEngine &Diags,
                               const CodeGenOptions &CGOpts,
                               const clang::TargetOptions &TOpts,
@@ -677,3 +735,38 @@
     }
   }
 }
+
+void clang::ApplyIROptimizations(DiagnosticsEngine &Diags,
+                                 const CodeGenOptions &CGOpts,
+                                 const clang::TargetOptions &TOpts,
+                                 const LangOptions &LOpts, Module *M,
+                                 BackendAction Action, raw_pwrite_stream *OS) {
+  EmitAssemblyHelper AsmHelper(Diags, CGOpts, TOpts, LOpts, M);
+  AsmHelper.SetupAssemblyHelper(Action, OS);
+  AsmHelper.ApplyIROptPasses(M);
+}
+
+void clang::CodegenBackendOutput(DiagnosticsEngine &Diags,
+                                 const CodeGenOptions &CGOpts,
+                                 const clang::TargetOptions &TOpts,
+                                 const LangOptions &LOpts, StringRef TDesc,
+                                 Module *M, BackendAction Action,
+                                 raw_pwrite_stream *OS) {
+  EmitAssemblyHelper AsmHelper(Diags, CGOpts, TOpts, LOpts, M);
+  AsmHelper.SetupAssemblyHelper(Action, OS);
+
+  // If an optional clang TargetInfo description string was passed in, use it to
+  // verify the LLVM TargetMachine's DataLayout.
+  if (AsmHelper.TM && !TDesc.empty()) {
+    std::string DLDesc =
+        AsmHelper.TM->getDataLayout()->getStringRepresentation();
+    if (DLDesc != TDesc) {
+      unsigned DiagID = Diags.getCustomDiagID(
+          DiagnosticsEngine::Error, "backend data layout '%0' does not match "
+                                    "expected target description '%1'");
+      Diags.Report(DiagID) << DLDesc << TDesc;
+    }
+  }
+
+  AsmHelper.ApplyCodegenPasses(M);
+}
Index: lib/CodeGen/CGStmt.cpp
===================================================================
--- lib/CodeGen/CGStmt.cpp	(revision 320332)
+++ lib/CodeGen/CGStmt.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/AST/StmtVisitor.h"
 #include "clang/Basic/PrettyStackTrace.h"
 #include "clang/Basic/TargetInfo.h"
+#include "clang/CodeGen/PrefetchBuilder.h"
 #include "clang/Sema/LoopHint.h"
 #include "clang/Sema/SemaDiagnostic.h"
 #include "llvm/ADT/StringExtras.h"
@@ -840,6 +841,16 @@
 
   LexicalScope ForScope(*this, S.getSourceRange());
 
+  if(S.prefetchEnabled()) {
+    const PrefetchAnalysis *PA = getContext().getPrefetchAnalysis(&S);
+    if(PA) {
+      PrefetchBuilder PB(this);
+      PB.EmitPrefetchCallDeclarations();
+      for(auto &Range : PA->getArraysToPrefetch()) PB.EmitPrefetchCall(Range);
+      PB.EmitPrefetchExecuteCall();
+    }
+  }
+
   // Evaluate the first part before the loop.
   if (S.getInit())
     EmitStmt(S.getInit());
@@ -2147,6 +2158,69 @@
   }
 }
 
+
+void CodeGenFunction::addOffloaded(const CapturedStmt *S, ValueDecl *L,
+                                   ValueDecl *G) {
+  assert(S && isa<CapturedStmt>(S) && "Invalid captured statement");
+  assert(L && G && "Invalid value declarations");
+  OffloadedLocals[S].emplace_back(L, G);
+}
+
+const CodeGenFunction::OffloadList &
+CodeGenFunction::getOffloaded(const CapturedStmt *S) const {
+  assert(S && isa<CapturedStmt>(S) && "Invalid captured statement");
+  OffloadMap::const_iterator it = OffloadedLocals.find(S);
+  assert((it != OffloadedLocals.end()) && "Captured statement not visited?");
+  return it->second;
+}
+
+VarDecl *CodeGenFunction::CreateOffloadedGlobal(const Stmt &S, const Expr *I) {
+  ASTContext &AST = getContext();
+  DeclContext *TUC = AST.getTranslationUnitDecl();
+  SourceRange SR = S.getSourceRange();
+  IdentifierInfo *II = &AST.Idents.get("distr_omp_" +
+      std::string(CurFn->getName()) + "_" +
+      cast<DeclRefExpr>(I)->getDecl()->getNameAsString());
+  QualType Ty = I->getType();
+  if(Ty.isLocalConstQualified()) Ty.removeLocalConst();
+  TypeSourceInfo *TSI = AST.getTrivialTypeSourceInfo(Ty, SR.getBegin());
+  return VarDecl::Create(AST, TUC, SR.getBegin(), SR.getEnd(),
+                         II, Ty, TSI, clang::SC_Static);
+}
+
+LValue CodeGenFunction::GetVarDeclLValue(const Expr *I, VarDecl *VD) {
+  QualType SrcType = I->getType();
+  if(SrcType.isLocalConstQualified()) SrcType.removeLocalConst();
+  llvm::Type *Ty = CGM.getTypes().ConvertType(SrcType);
+  llvm::Constant *GV = CGM.GetAddrOfGlobalVar(VD, Ty);
+  llvm::GlobalVariable *CastGV = cast<llvm::GlobalVariable>(GV);
+  CastGV->setInitializer(llvm::Constant::getNullValue(Ty));
+  CastGV->setLinkage(llvm::GlobalValue::InternalLinkage);
+  return MakeNaturalAlignAddrLValue(GV, SrcType);
+}
+
+DeclRefExpr *CodeGenFunction::GetDeclRefForOffload(ValueDecl *VD) {
+  ASTContext &AST = getContext();
+  QualType Ty = VD->getType();
+  DeclRefExpr *DRE = DeclRefExpr::Create(AST, NestedNameSpecifierLoc(),
+                                         SourceLocation(), VD, false,
+                                         VD->getSourceRange().getBegin(),
+                                         Ty, VK_LValue);
+  DRE->getDecl()->setIsUsed();
+  return DRE;
+}
+
+void CodeGenFunction::RestoreOffloadedLocals(const CapturedStmt *S) {
+  Expr *Global;
+  const OffloadList &Offloaded = getOffloaded(S);
+  for(auto Pair : Offloaded) {
+    if(Pair.first->getType().isLocalConstQualified()) continue;
+    LValue LocalLV(EmitDeclRefLValue(GetDeclRefForOffload(Pair.first)));
+    Global = GetDeclRefForOffload(Pair.second);
+    EmitAnyExprToMem(Global, LocalLV.getAddress(), LocalLV.getQuals(), false);
+  }
+}
+
 LValue CodeGenFunction::InitCapturedStruct(const CapturedStmt &S) {
   const RecordDecl *RD = S.getCapturedRecordDecl();
   QualType RecordTy = getContext().getRecordType(RD);
@@ -2155,6 +2229,8 @@
   LValue SlotLV = MakeNaturalAlignAddrLValue(
       CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
 
+  if(S.offloadShared()) OffloadedLocals[&S] = OffloadList();
+
   RecordDecl::field_iterator CurField = RD->field_begin();
   for (CapturedStmt::capture_init_iterator I = S.capture_init_begin(),
                                            E = S.capture_init_end();
@@ -2164,7 +2240,18 @@
       auto VAT = CurField->getCapturedVLAType();
       EmitStoreThroughLValue(RValue::get(VLASizeMap[VAT->getSizeExpr()]), LV);
     } else {
-      EmitInitializerForField(*CurField, LV, *I, None);
+      if(S.offloadShared()) {
+        // If distributed, create global variable, emit initializer & place
+        // address of new global into capture struct
+        assert(isa<DeclRefExpr>(*I) && "Invalid capture type");
+        VarDecl *GLD = CreateOffloadedGlobal(S, *I);
+        LValue GLV = GetVarDeclLValue(*I, GLD);
+        EmitAnyExprToMem(*I, GLV.getAddress(), GLV.getQuals(), false);
+        Expr *GlobalRef = GetDeclRefForOffload(GLD);
+        EmitInitializerForField(*CurField, LV, GlobalRef, None);
+        addOffloaded(&S, cast<DeclRefExpr>(*I)->getDecl(), GLD);
+      }
+      else EmitInitializerForField(*CurField, LV, *I, None);
     }
   }
 
Index: lib/CodeGen/CGStmtOpenMP.cpp
===================================================================
--- lib/CodeGen/CGStmtOpenMP.cpp	(revision 320332)
+++ lib/CodeGen/CGStmtOpenMP.cpp	(working copy)
@@ -17,6 +17,7 @@
 #include "TargetInfo.h"
 #include "clang/AST/Stmt.h"
 #include "clang/AST/StmtOpenMP.h"
+#include "llvm/IR/CallSite.h"
 using namespace clang;
 using namespace CodeGen;
 
@@ -489,6 +490,8 @@
   }
   CGF.CGM.getOpenMPRuntime().emitParallelCall(CGF, S.getLocStart(), OutlinedFn,
                                               CapturedStruct, IfCond);
+
+  if(CS->offloadShared()) CGF.RestoreOffloadedLocals(CS);
 }
 
 void CodeGenFunction::EmitOMPParallelDirective(const OMPParallelDirective &S) {
@@ -743,6 +746,162 @@
   }
 }
 
+/// Ease the variable lookup burden for captures.
+typedef llvm::DenseMap<const VarDecl *, DeclRefExpr *> CaptureMap;
+
+/// Map variable declarations captured in the outer function to their field in
+/// the captured struct.
+static void
+buildCapturedMap(ASTContext &C, CapturedStmt *CS, CaptureMap &Map) {
+  // Captures are in a 1-to-1 correspondence with captured record fields
+  Map.clear();
+  for(auto Child : CS->children()) {
+    if(isa<DeclRefExpr>(Child)) {
+      DeclRefExpr *DRE = cast<DeclRefExpr>(Child);
+      ValueDecl *Decl = DRE->getDecl();
+      if(isa<VarDecl>(Decl)) Map[cast<VarDecl>(Decl)] = DRE;
+    }
+  }
+}
+
+/// Create an expression representing the address of some array index.
+static Expr *getPrefetchAddr(ASTContext &C, Expr *Ptr, Expr *Subscript) {
+  QualType BaseTy = Ptr->getType().getDesugaredType(C), IdxTy;
+
+  // Get an array subscript
+  if(isa<ArrayType>(BaseTy)) IdxTy = cast<ArrayType>(BaseTy)->getElementType();
+  else IdxTy = cast<PointerType>(BaseTy)->getPointeeType();
+  Expr *Index = new (C) ArraySubscriptExpr(Ptr, Subscript, IdxTy,
+                                           VK_RValue, OK_Ordinary,
+                                           SourceLocation());
+
+  // Take the address of the array subscript
+  QualType RePtrTy = C.getPointerType(IdxTy);
+  UnaryOperator *Addr = new (C) UnaryOperator(Index, UO_AddrOf, RePtrTy, VK_LValue,
+                               OK_Ordinary, SourceLocation());
+
+  // Finally, cast to a const void * type
+  QualType VoidPtrTy = C.getPointerType(C.VoidTy.withConst());
+  return ImplicitCastExpr::Create(C, VoidPtrTy, CK_BitCast, Addr, nullptr,
+                                  VK_RValue);
+}
+
+static Expr *getArrayIndexAddr(ASTContext &C, Expr *Arr, const llvm::APInt &Idx) {
+  QualType Ty = Arr->getType();
+  if(Ty->isArrayType()) {
+    Ty = C.getPointerType(cast<ArrayType>(Ty)->getElementType());
+    Arr = ImplicitCastExpr::Create(C, Ty, CK_ArrayToPointerDecay, Arr, nullptr,
+                                   VK_RValue);
+  }
+  Expr *IdxLiteral =
+    IntegerLiteral::Create(C, Idx, C.LongTy, SourceLocation());
+  return getPrefetchAddr(C, Arr, IdxLiteral);
+}
+
+static Expr *getArrayIndexAddr(ASTContext &C, Expr *Arr, int64_t Idx) {
+  return getArrayIndexAddr(C, Arr, llvm::APInt(64, Idx, true));
+}
+
+static llvm::Constant *getPrefetchKind(CodeGenFunction &CGF,
+                                       OpenMPPrefetchClauseKind Kind) {
+  llvm::Type *Ty = llvm::Type::getInt32Ty(CGF.CurFn->getContext());
+  switch(Kind) {
+  case OMPC_PREFETCH_read: return llvm::ConstantInt::get(Ty, 0);
+  case OMPC_PREFETCH_write: return llvm::ConstantInt::get(Ty, 1);
+  //case OMPC_PREFETCH_release: return llvm::ConstantInt::get(Ty, 3);
+  default:
+    llvm_unreachable("Invalid prefetch type\n");
+    return nullptr;
+  }
+}
+
+void CodeGenFunction::EmitOMPPrefetchClauses(const OMPLoopDirective &D) {
+  ASTContext &AST = getContext();
+  CaptureMap AllCaptures;
+  CaptureMap::iterator Captured;
+  const ConstantArrayType *ArrTy;
+  Expr *Base, *Start, *End, *StartAddr, *EndAddr;
+  RValue LoweredStart, LoweredEnd;
+  std::vector<llvm::Value *> Params;
+  std::vector<llvm::Type *> ParamTypes;
+  llvm::FunctionType *FnType;
+  llvm::Constant *Prefetch, *Execute;
+
+  bool HasPrefetch = !D.getClausesOfKind(OMPC_prefetch).empty();
+  if(HasPrefetch) {
+    // declare void @popcorn_prefetch(i32, i8*, i8*)
+    ParamTypes = { Int32Ty, Int8PtrTy, Int8PtrTy };
+    FnType = llvm::FunctionType::get(VoidTy, ParamTypes, false);
+    Prefetch = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch");
+
+    // declare i64 @popcorn_prefetch_execute()
+    ParamTypes.clear();
+    FnType = llvm::FunctionType::get(Int64Ty, ParamTypes, false);
+    Execute = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch_execute");
+
+    // For each prefetched variable, construct start & end range expressions
+    // and call @popcorn_prefetch
+    CapturedStmt *CS = cast<CapturedStmt>(D.getAssociatedStmt());
+    buildCapturedMap(AST, CS, AllCaptures);
+
+    for(auto &&I = D.getClausesOfKind(OMPC_prefetch); I; ++I) {
+      auto *C = cast<OMPPrefetchClause>(*I);
+      Start = C->getStartOfRange();
+      End = C->getEndOfRange();
+
+      for(auto &V : C->varlists()) {
+        const DeclRefExpr *DR = cast<DeclRefExpr>(V);
+        const VarDecl *VD = cast<VarDecl>(DR->getDecl());
+        Captured = AllCaptures.find(VD);
+
+        // TODO the current mechanism for calculating addresses applies an
+        // "inbounds" tag to the array index addressing expression, but we
+        // don't necessarily know this is true.
+        if(Captured != AllCaptures.end()) {
+          Base = Captured->second;
+          if(Start && End) {
+            // User specified entire range
+            StartAddr = getPrefetchAddr(AST, Base, Start);
+            EndAddr = getPrefetchAddr(AST, Base, End);
+          }
+          else if(Start) {
+            // User specified an expression affine to loop iteration variable
+            // TODO if expression is affine transformation of loop induction
+            // variable, need to re-generate for lower/upper bound variables
+            assert(isa<DeclRefExpr>(Start) &&
+                   "Can't handle transformations on loop variables yet");
+            StartAddr = getPrefetchAddr(AST, Base, D.getLowerBoundVariable());
+            EndAddr = getPrefetchAddr(AST, Base, D.getUpperBoundVariable());
+          }
+          else {
+            // User didn't specify a range, prefetch the entire array (note:
+            // should have type checked it's an array by now).
+            QualType QTy = Base->getType();
+            while(isa<DecayedType>(QTy))
+              QTy = cast<DecayedType>(QTy)->getOriginalType();
+            ArrTy = cast<ConstantArrayType>(QTy);
+            const llvm::APInt &Size = ArrTy->getSize();
+            StartAddr = getArrayIndexAddr(AST, Base, 0);
+            EndAddr = getArrayIndexAddr(AST, Base, Size);
+          }
+
+          LoweredStart = EmitAnyExpr(StartAddr);
+          LoweredEnd = EmitAnyExpr(EndAddr);
+          Params = { getPrefetchKind(*this, C->getPrefetchKind()),
+                     LoweredStart.getScalarVal(),
+                     LoweredEnd.getScalarVal() };
+          EmitCallOrInvoke(Prefetch, Params);
+        }
+        else llvm_unreachable("Invalid prefetch variable");
+      }
+    }
+
+    // Finally, call @popcorn_prefetch_execute to issue requests
+    Params.clear();
+    EmitCallOrInvoke(Execute, Params);
+  }
+}
+
 void CodeGenFunction::EmitOMPSimdInit(const OMPLoopDirective &D) {
   // Walk clauses and process safelen/lastprivate.
   LoopStack.setParallel();
@@ -1137,6 +1296,8 @@
         auto LoopExit = getJumpDestInCurrentScope(createBasicBlock("omp.loop.exit"));
         // UB = min(UB, GlobalUB);
         EmitIgnoredExpr(S.getEnsureUpperBound());
+        // Popcorn: emit prefetch function declarations & requests
+        if(S.prefetchingEnabled()) EmitOMPPrefetchClauses(S);
         // IV = LB;
         EmitIgnoredExpr(S.getInit());
         // while (idx <= UB) { BODY; ++idx; }
@@ -2049,6 +2210,7 @@
   case OMPC_threadprivate:
   case OMPC_depend:
   case OMPC_mergeable:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed in 'omp atomic'.");
   }
 }
Index: lib/CodeGen/CMakeLists.txt
===================================================================
--- lib/CodeGen/CMakeLists.txt	(revision 320332)
+++ lib/CodeGen/CMakeLists.txt	(working copy)
@@ -73,6 +73,8 @@
   MicrosoftCXXABI.cpp
   ModuleBuilder.cpp
   ObjectFilePCHContainerOperations.cpp
+  PopcornUtil.cpp
+  PrefetchBuilder.cpp
   SanitizerMetadata.cpp
   TargetInfo.cpp
 
Index: lib/CodeGen/CodeGenAction.cpp
===================================================================
--- lib/CodeGen/CodeGenAction.cpp	(revision 320332)
+++ lib/CodeGen/CodeGenAction.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/CodeGen/BackendUtil.h"
 #include "clang/CodeGen/CodeGenAction.h"
 #include "clang/CodeGen/ModuleBuilder.h"
+#include "clang/CodeGen/PopcornUtil.h"
 #include "clang/Frontend/CompilerInstance.h"
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Lex/Preprocessor.h"
@@ -34,6 +35,7 @@
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Support/Timer.h"
+#include "llvm/Transforms/Utils/Cloning.h"
 #include <memory>
 using namespace clang;
 using namespace llvm;
@@ -41,6 +43,7 @@
 namespace clang {
   class BackendConsumer : public ASTConsumer {
     virtual void anchor();
+  protected:
     DiagnosticsEngine &Diags;
     BackendAction Action;
     const CodeGenOptions &CodeGenOpts;
@@ -129,7 +132,7 @@
         LLVMIRGeneration.stopTimer();
     }
 
-    void HandleTranslationUnit(ASTContext &C) override {
+    void HandleTranslationUnitCommon(ASTContext &C) {
       {
         PrettyStackTraceString CrashInfo("Per-file LLVM IR generation");
         if (llvm::TimePassesIsEnabled)
@@ -165,7 +168,11 @@
                 [=](const DiagnosticInfo &DI) { linkerDiagnosticHandler(DI); }))
           return;
       }
+    }
 
+    void HandleTranslationUnit(ASTContext &C) override {
+      HandleTranslationUnitCommon(C);
+
       // Install an inline asm handler so that diagnostics get printed through
       // our diagnostics hooks.
       LLVMContext &Ctx = TheModule->getContext();
@@ -261,6 +268,76 @@
   };
   
   void BackendConsumer::anchor() {}
+
+  class MultiBackendConsumer : public BackendConsumer {
+  private:
+    virtual void anchor() override;
+    SmallVector<raw_pwrite_stream *, 2> &AsmOutStreams;
+    const SmallVector<std::shared_ptr<TargetOptions>, 2> &AsmTargetOpts;
+    const SmallVector<TargetInfo *, 2> &AsmTargetInfos;
+    const CodeGenOptions &NoOptCodegen;
+  public:
+    MultiBackendConsumer(DiagnosticsEngine &Diags,
+                    const HeaderSearchOptions &HeaderSearchOpts,
+                    const PreprocessorOptions &PPOpts,
+                    const CodeGenOptions &CodeGenOpts,
+                    const CodeGenOptions &NoOptCodegen,
+                    const SmallVector<std::shared_ptr<TargetOptions>, 2> &TargetOpts,
+                    const LangOptions &LangOpts, bool TimePasses,
+                    const std::string &InFile, llvm::Module *LinkModule,
+                    SmallVector<raw_pwrite_stream *, 2> &OSs, LLVMContext &C,
+                    const SmallVector<TargetInfo *, 2> &TargetInfos,
+                    CoverageSourceInfo *CoverageInfo = nullptr)
+        : BackendConsumer(Backend_EmitMultiObj, Diags, HeaderSearchOpts,
+                          PPOpts, CodeGenOpts, *TargetOpts[0], LangOpts,
+                          TimePasses, InFile, LinkModule, OSs[0], C,
+                          CoverageInfo),
+          AsmOutStreams(OSs), AsmTargetOpts(TargetOpts),
+          AsmTargetInfos(TargetInfos), NoOptCodegen(NoOptCodegen) {}
+
+    void HandleTranslationUnit(ASTContext &C) override {
+      HandleTranslationUnitCommon(C);
+
+      // Install an inline asm handler so that diagnostics get printed through
+      // our diagnostics hooks.
+      LLVMContext &Ctx = TheModule->getContext();
+      LLVMContext::InlineAsmDiagHandlerTy OldHandler =
+        Ctx.getInlineAsmDiagnosticHandler();
+      void *OldContext = Ctx.getInlineAsmDiagnosticContext();
+      Ctx.setInlineAsmDiagnosticHandler(InlineAsmDiagHandler, this);
+
+      LLVMContext::DiagnosticHandlerTy OldDiagnosticHandler =
+          Ctx.getDiagnosticHandler();
+      void *OldDiagnosticContext = Ctx.getDiagnosticContext();
+      Ctx.setDiagnosticHandler(DiagnosticHandler, this);
+
+      // Apply IR optimizations, but strip target-specific attributes from
+      // all functions added by analyses
+      std::shared_ptr<TargetOptions> IRTargetOpts =
+        Popcorn::GetPopcornTargetOpts(TheModule->getTargetTriple());
+      ApplyIROptimizations(Diags, CodeGenOpts, *IRTargetOpts, LangOpts,
+                           TheModule.get(), Action, nullptr);
+      Popcorn::StripTargetAttributes(*TheModule);
+
+      // Generate machine code for each target
+      for(size_t i = 0; i < AsmTargetOpts.size(); i++) {
+        llvm::Module* ArchModule = CloneModule(TheModule.get());
+        ArchModule->setTargetTriple(AsmTargetInfos[i]->getTriple().getTriple());
+        ArchModule->setDataLayout(AsmTargetInfos[i]->getTargetDescription());
+        Popcorn::AddArchSpecificTargetFeatures(*ArchModule, AsmTargetOpts[i]);
+        CodegenBackendOutput(Diags, NoOptCodegen, *AsmTargetOpts[i], LangOpts,
+                             AsmTargetInfos[i]->getTargetDescription(),
+                             ArchModule, Action, AsmOutStreams[i]);
+        delete ArchModule;
+      }
+
+      Ctx.setInlineAsmDiagnosticHandler(OldHandler, OldContext);
+
+      Ctx.setDiagnosticHandler(OldDiagnosticHandler, OldDiagnosticContext);
+    }
+  };
+
+  void MultiBackendConsumer::anchor() {}
 }
 
 /// ConvertBackendLocation - Convert a location in a temporary llvm::SourceMgr
@@ -626,6 +703,7 @@
   case Backend_EmitMCNull:
     return CI.createNullOutputFile();
   case Backend_EmitObj:
+  case Backend_EmitMultiObj:
     return CI.createDefaultOutputFile(true, InFile, "o");
   }
 
@@ -632,13 +710,7 @@
   llvm_unreachable("Invalid action!");
 }
 
-std::unique_ptr<ASTConsumer>
-CodeGenAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
-  BackendAction BA = static_cast<BackendAction>(Act);
-  raw_pwrite_stream *OS = GetOutputStream(CI, InFile, BA);
-  if (BA != Backend_EmitNothing && !OS)
-    return nullptr;
-
+llvm::Module *CodeGenAction::getLinkModuleToUse(CompilerInstance &CI) {
   llvm::Module *LinkModuleToUse = LinkModule;
 
   // If we were not given a link module, and the user requested that one be
@@ -662,6 +734,10 @@
     LinkModuleToUse = ModuleOrErr.get().release();
   }
 
+  return LinkModuleToUse;
+}
+
+CoverageSourceInfo *CodeGenAction::getCoverageInfo(CompilerInstance &CI) {
   CoverageSourceInfo *CoverageInfo = nullptr;
   // Add the preprocessor callback only when the coverage mapping is generated.
   if (CI.getCodeGenOpts().CoverageMapping) {
@@ -669,6 +745,19 @@
     CI.getPreprocessor().addPPCallbacks(
                                     std::unique_ptr<PPCallbacks>(CoverageInfo));
   }
+  return CoverageInfo;
+}
+
+std::unique_ptr<ASTConsumer>
+CodeGenAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
+  BackendAction BA = static_cast<BackendAction>(Act);
+  raw_pwrite_stream *OS = GetOutputStream(CI, InFile, BA);
+  if (BA != Backend_EmitNothing && !OS)
+    return nullptr;
+
+  llvm::Module *LinkModuleToUse = getLinkModuleToUse(CI);
+  CoverageSourceInfo *CoverageInfo = getCoverageInfo(CI);
+
   std::unique_ptr<BackendConsumer> Result(new BackendConsumer(
       BA, CI.getDiagnostics(), CI.getHeaderSearchOpts(),
       CI.getPreprocessorOpts(), CI.getCodeGenOpts(), CI.getTargetOpts(),
@@ -684,6 +773,42 @@
   SM.print(nullptr, llvm::errs());
 }
 
+bool CodeGenAction::ExecuteActionIRCommon(BackendAction &BA,
+                                          CompilerInstance &CI) {
+  bool Invalid;
+  SourceManager &SM = CI.getSourceManager();
+  FileID FID = SM.getMainFileID();
+  llvm::MemoryBuffer *MainFile = SM.getBuffer(FID, &Invalid);
+  if (Invalid)
+    return true;
+
+  llvm::SMDiagnostic Err;
+  TheModule = parseIR(MainFile->getMemBufferRef(), Err, *VMContext);
+  if (!TheModule) {
+    // Translate from the diagnostic info to the SourceManager location if
+    // available.
+    // TODO: Unify this with ConvertBackendLocation()
+    SourceLocation Loc;
+    if (Err.getLineNo() > 0) {
+      assert(Err.getColumnNo() >= 0);
+      Loc = SM.translateFileLineCol(SM.getFileEntryForID(FID),
+                                    Err.getLineNo(), Err.getColumnNo() + 1);
+    }
+
+    // Strip off a leading diagnostic code if there is one.
+    StringRef Msg = Err.getMessage();
+    if (Msg.startswith("error: "))
+      Msg = Msg.substr(7);
+
+    unsigned DiagID =
+        CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
+
+    CI.getDiagnostics().Report(Loc, DiagID) << Msg;
+    return true;
+  }
+  return false;
+}
+
 void CodeGenAction::ExecuteAction() {
   // If this is an IR file, we have to treat it specially.
   if (getCurrentFileKind() == IK_LLVM_IR) {
@@ -693,37 +818,9 @@
     if (BA != Backend_EmitNothing && !OS)
       return;
 
-    bool Invalid;
-    SourceManager &SM = CI.getSourceManager();
-    FileID FID = SM.getMainFileID();
-    llvm::MemoryBuffer *MainFile = SM.getBuffer(FID, &Invalid);
-    if (Invalid)
+    if(ExecuteActionIRCommon(BA, CI))
       return;
 
-    llvm::SMDiagnostic Err;
-    TheModule = parseIR(MainFile->getMemBufferRef(), Err, *VMContext);
-    if (!TheModule) {
-      // Translate from the diagnostic info to the SourceManager location if
-      // available.
-      // TODO: Unify this with ConvertBackendLocation()
-      SourceLocation Loc;
-      if (Err.getLineNo() > 0) {
-        assert(Err.getColumnNo() >= 0);
-        Loc = SM.translateFileLineCol(SM.getFileEntryForID(FID),
-                                      Err.getLineNo(), Err.getColumnNo() + 1);
-      }
-
-      // Strip off a leading diagnostic code if there is one.
-      StringRef Msg = Err.getMessage();
-      if (Msg.startswith("error: "))
-        Msg = Msg.substr(7);
-
-      unsigned DiagID =
-          CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
-
-      CI.getDiagnostics().Report(Loc, DiagID) << Msg;
-      return;
-    }
     const TargetOptions &TargetOpts = CI.getTargetOpts();
     if (TheModule->getTargetTriple() != TargetOpts.Triple) {
       CI.getDiagnostics().Report(SourceLocation(),
@@ -769,3 +866,140 @@
 void EmitObjAction::anchor() { }
 EmitObjAction::EmitObjAction(llvm::LLVMContext *_VMContext)
   : CodeGenAction(Backend_EmitObj, _VMContext) {}
+
+void EmitMultiObjAction::anchor() { }
+EmitMultiObjAction::EmitMultiObjAction(llvm::LLVMContext *_VMContext)
+  : CodeGenAction(Backend_EmitMultiObj, _VMContext) {}
+
+static std::string AppendArchName(StringRef File, const TargetInfo *TI) {
+  size_t dot = File.rfind('.');
+  std::string NewFile = File.substr(0, dot);
+  NewFile += "_";
+  NewFile += TI->getTriple().getArchName();
+  NewFile += File.substr(dot, StringRef::npos);
+  return NewFile;
+}
+
+/// Create target information & output streams for each target.
+bool EmitMultiObjAction::InitializeTargets(CompilerInstance &CI,
+                                           StringRef InFile) {
+  // Note: remove output filename from frontend args, as it will override any
+  // special names we try to specify.
+  std::string OutFile(InFile);
+  if(CI.getFrontendOpts().OutputFile != "") {
+    OutFile = CI.getFrontendOpts().OutputFile;
+    CI.getFrontendOpts().OutputFile = "";
+  }
+
+  // Populate list of targets requested.  If none are requested, default to all
+  // supported targets.
+  std::vector<std::string> &Requested = CI.getCodeGenOpts().PopcornTargets;
+  if(Requested.size()) {
+    for(auto &Target : Requested) {
+      if(!Popcorn::SupportedTarget(Target)) {
+        std::string Msg("Popcorn: unsupported target '" + Target + "'");
+        unsigned DiagID =
+            CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
+        CI.getDiagnostics().Report(DiagID) << Msg;
+        return false;
+      }
+      Targets.push_back(Target);
+    }
+  }
+  else Popcorn::GetAllTargets(this->Targets);
+
+  BackendAction BA = Backend_EmitMultiObj;
+  if(Targets.size() > 1) {
+    for(size_t i = 0; i < Targets.size(); i++) {
+      std::shared_ptr<TargetOptions> Opts = Popcorn::GetPopcornTargetOpts(Targets[i]);
+      TargetOpts.push_back(Opts);
+      TargetInfos.push_back(TargetInfo::CreateTargetInfo(CI.getDiagnostics(), Opts));
+
+      raw_pwrite_stream *OS;
+      OS = GetOutputStream(CI, AppendArchName(OutFile, TargetInfos[i]), BA);
+      if (!OS) return false;
+      OutFiles.push_back(OS);
+    }
+  }
+  else {
+    std::shared_ptr<TargetOptions> Opts = Popcorn::GetPopcornTargetOpts(Targets[0]);
+    TargetOpts.push_back(Opts);
+    TargetInfos.push_back(TargetInfo::CreateTargetInfo(CI.getDiagnostics(), Opts));
+
+    raw_pwrite_stream *OS = GetOutputStream(CI, OutFile, BA);
+    if (!OS) return false;
+    OutFiles.push_back(OS);
+  }
+  CI.getFrontendOpts().OutputFile = OutFile;
+
+  return true;
+}
+
+/// Initialize target information & open output streams for each target.
+std::unique_ptr<ASTConsumer>
+EmitMultiObjAction::CreateASTConsumer(CompilerInstance &CI,
+                                      StringRef InFile) {
+  if(!InitializeTargets(CI, InFile)) return nullptr;
+  llvm::Module *LinkModuleToUse = getLinkModuleToUse(CI);
+  CoverageSourceInfo *CoverageInfo = getCoverageInfo(CI);
+
+  // Create a MultiBackendConsumer, which is identical to a BackendConsumer
+  // except that it runs the generated IR through multiple backends.
+  std::unique_ptr<MultiBackendConsumer> Result(new MultiBackendConsumer(
+      CI.getDiagnostics(), CI.getHeaderSearchOpts(),
+      CI.getPreprocessorOpts(), CI.getCodeGenOpts(), CI.getCodeGenNoOpts(),
+      TargetOpts, CI.getLangOpts(), CI.getFrontendOpts().ShowTimers, InFile,
+      LinkModuleToUse, OutFiles, *VMContext, TargetInfos, CoverageInfo));
+  BEConsumer = Result.get();
+  return std::move(Result);
+}
+
+void EmitMultiObjAction::ExecuteAction() {
+  // If this is an IR file, we have to treat it specially.
+  if (getCurrentFileKind() == IK_LLVM_IR) {
+    // Initialize targets here because we never called CreateASTConsumer
+    CompilerInstance &CI = getCompilerInstance();
+    StringRef OutFile = getCurrentFile();
+    BackendAction BA = Backend_EmitMultiObj;
+
+    if(!InitializeTargets(CI, OutFile)) {
+      // TODO add diagnostics saying we couldn't initialize targets
+      return;
+    }
+
+    if(ExecuteActionIRCommon(BA, CI)) {
+      // TODO add diagnostics saying we couldn't do common IR work
+      return;
+    }
+
+    // Apply IR optimizations, but strip target-specific attributes from all
+    // functions added by analyses
+    std::shared_ptr<TargetOptions> IRTargetOpts =
+      Popcorn::GetPopcornTargetOpts(TheModule->getTargetTriple());
+    ApplyIROptimizations(CI.getDiagnostics(), CI.getCodeGenOpts(),
+                         *IRTargetOpts, CI.getLangOpts(),
+                         TheModule.get(), BA, nullptr);
+    Popcorn::StripTargetAttributes(*TheModule);
+
+    // Emit machine code for all specified architectures
+    for(size_t i = 0; i < Targets.size(); i++) {
+      llvm::Module *ArchModule = CloneModule(TheModule.get());
+      ArchModule->setTargetTriple(Targets[i]);
+      ArchModule->setDataLayout(TargetInfos[i]->getTargetDescription());
+      Popcorn::AddArchSpecificTargetFeatures(*ArchModule, TargetOpts[i]);
+      LLVMContext &Ctx = ArchModule->getContext();
+      Ctx.setInlineAsmDiagnosticHandler(BitcodeInlineAsmDiagHandler);
+      CodegenBackendOutput(CI.getDiagnostics(), CI.getCodeGenNoOpts(),
+                           *TargetOpts[i], CI.getLangOpts(),
+                           TargetInfos[i]->getTargetDescription(),
+                           ArchModule, BA, OutFiles[i]);
+      delete ArchModule;
+    }
+
+    return;
+  }
+
+  // Otherwise follow the normal AST path.
+  this->ASTFrontendAction::ExecuteAction();
+}
+
Index: lib/CodeGen/CodeGenFunction.h
===================================================================
--- lib/CodeGen/CodeGenFunction.h	(revision 320332)
+++ lib/CodeGen/CodeGenFunction.h	(working copy)
@@ -913,6 +913,15 @@
   llvm::MDNode *createProfileWeightsForLoop(const Stmt *Cond,
                                             uint64_t LoopCount);
 
+  /// \brief Locals that were offloaded to global memory for a captured
+  /// statement and need to be restored after the statement has executed.
+  /// First declaration in the pair is the local, second is the global.
+  /// Maintain a mapping of captured statements & their offloaded locals.
+  typedef std::pair<ValueDecl *, ValueDecl *> OffloadPair;
+  typedef llvm::SmallVector<OffloadPair, 4> OffloadList;
+  typedef llvm::DenseMap<const CapturedStmt *, OffloadList> OffloadMap;
+  OffloadMap OffloadedLocals;
+
 public:
   /// Increment the profiler's counter for the given statement.
   void incrementProfileCounter(const Stmt *S) {
@@ -2084,6 +2093,15 @@
   void EmitCXXForRangeStmt(const CXXForRangeStmt &S,
                            ArrayRef<const Attr *> Attrs = None);
 
+  /// \brief Offload/restore capabilities for local variables captured in
+  /// capture statements.
+  void addOffloaded(const CapturedStmt *S, ValueDecl *L, ValueDecl *G);
+  const OffloadList &getOffloaded(const CapturedStmt *S) const;
+  VarDecl *CreateOffloadedGlobal(const Stmt &S, const Expr *I);
+  LValue GetVarDeclLValue(const Expr *I, VarDecl *VD);
+  DeclRefExpr *GetDeclRefForOffload(ValueDecl *VD);
+  void RestoreOffloadedLocals(const CapturedStmt *S);
+
   LValue InitCapturedStruct(const CapturedStmt &S);
   llvm::Function *EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K);
   void GenerateCapturedStmtFunctionProlog(const CapturedStmt &S);
@@ -2191,6 +2209,10 @@
   ///
   /// \param D Directive (possibly) with the 'linear' clause.
   void EmitOMPLinearClauseInit(const OMPLoopDirective &D);
+  /// \brief Emit prefetching requests for loop directive.
+  ///
+  /// \param D Directive (possibly) with the 'prefetch' clause.
+  void EmitOMPPrefetchClauses(const OMPLoopDirective &D);
 
   void EmitOMPParallelDirective(const OMPParallelDirective &S);
   void EmitOMPSimdDirective(const OMPSimdDirective &S);
Index: lib/CodeGen/PopcornUtil.cpp
===================================================================
--- lib/CodeGen/PopcornUtil.cpp	(nonexistent)
+++ lib/CodeGen/PopcornUtil.cpp	(working copy)
@@ -0,0 +1,103 @@
+//===--- PopcornUtil.cpp - LLVM Popcorn Linux Utilities -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include <clang/CodeGen/PopcornUtil.h>
+#include <llvm/ADT/Triple.h>
+#include <llvm/ADT/SmallVector.h>
+
+using namespace clang;
+using namespace llvm;
+
+const static std::vector<std::string> PopcornSupported = {
+  "aarch64-linux-gnu",
+  "x86_64-linux-gnu"
+};
+
+bool Popcorn::SupportedTarget(const StringRef Target) {
+  for(auto SupportedTarget : PopcornSupported)
+    if(Target == SupportedTarget) return true;
+  return false;
+}
+
+void Popcorn::GetAllTargets(SmallVector<std::string, 2> &Targets) {
+  Targets.clear();
+  for(auto Target : PopcornSupported) Targets.push_back(Target);
+}
+
+typedef std::shared_ptr<TargetOptions> TargetOptionsPtr;
+
+TargetOptionsPtr Popcorn::GetPopcornTargetOpts(const StringRef TripleStr) {
+  Triple Triple(Triple::normalize(TripleStr));
+  assert(!Triple.getTriple().empty() && "Invalid target triple");
+
+  TargetOptionsPtr Opts(new TargetOptions);
+  Opts->Triple = Triple.getTriple();
+  Opts->ABI = "";
+  Opts->FPMath = "";
+  Opts->FeaturesAsWritten.clear();
+  Opts->LinkerVersion = "";
+  Opts->Reciprocals.clear();
+
+  // TODO need to make CPU selectable & add target features according to CPU
+
+  switch(Triple.getArch()) {
+  case Triple::ArchType::aarch64:
+    Opts->ABI = "aapcs";
+    Opts->CPU = "generic";
+    Opts->FeaturesAsWritten.push_back("+neon");
+    break;
+  case Triple::ArchType::x86_64:
+    Opts->CPU = "x86-64";
+    Opts->FPMath = "sse";
+    Opts->FeaturesAsWritten.push_back("+sse");
+    Opts->FeaturesAsWritten.push_back("+sse2");
+    Opts->FeaturesAsWritten.push_back("+rtm");
+    break;
+  default: llvm_unreachable("Triple not currently supported on Popcorn");
+  }
+
+  return Opts;
+}
+
+void Popcorn::StripTargetAttributes(Module &M) {
+  /// Target-specific function attributes
+  static SmallVector<std::string, 2> TargetAttributes = {
+    "target-cpu",
+    "target-features"
+  };
+
+  for(Function &F : M) {
+    AttrBuilder AB(F.getAttributes(), AttributeSet::FunctionIndex);
+    for(std::string &Attr : TargetAttributes) {
+      if(F.hasFnAttribute(Attr))
+        AB.removeAttribute(Attr);
+    }
+    F.setAttributes(
+      AttributeSet::get(F.getContext(), AttributeSet::FunctionIndex, AB));
+  }
+}
+
+void Popcorn::AddArchSpecificTargetFeatures(Module &M,
+                                            TargetOptionsPtr TargetOpts) {
+  static const char *TF = "target-features";
+  std::string AllFeatures("");
+
+  for(auto &Feature : TargetOpts->FeaturesAsWritten)
+    AllFeatures += Feature + ",";
+  AllFeatures = AllFeatures.substr(0, AllFeatures.length() - 1);
+
+  for(Function &F : M) {
+    AttrBuilder AB(F.getAttributes(), AttributeSet::FunctionIndex);
+    assert(!F.hasFnAttribute(TF) && "Target features weren't stripped");
+    AB.addAttribute(TF, AllFeatures);
+    F.setAttributes(
+      AttributeSet::get(F.getContext(), AttributeSet::FunctionIndex, AB));
+  }
+}
+
Index: lib/CodeGen/PrefetchBuilder.cpp
===================================================================
--- lib/CodeGen/PrefetchBuilder.cpp	(nonexistent)
+++ lib/CodeGen/PrefetchBuilder.cpp	(working copy)
@@ -0,0 +1,98 @@
+//=- Prefetch.cpp - Prefetching Analysis for Structured Blocks -----------*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements prefetching analysis for structured blocks.  The
+// analysis traverses the AST to determine how arrays are accessed in structured
+// blocks and generates expressions defining ranges of elements accessed.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/CodeGen/PrefetchBuilder.h"
+#include "llvm/IR/CallSite.h"
+#include "llvm/Support/Debug.h"
+
+using namespace clang;
+
+//===----------------------------------------------------------------------===//
+// Prefetch builder API
+//
+
+void PrefetchBuilder::EmitPrefetchCallDeclarations() {
+  using namespace clang::CodeGen;
+  std::vector<llvm::Type *> ParamTypes;
+  llvm::FunctionType *FnType;
+
+  // declare void @popcorn_prefetch(i32, i8*, i8*)
+  ParamTypes = { CGF.Int32Ty, CGF.Int8PtrTy, CGF.Int8PtrTy };
+  FnType = llvm::FunctionType::get(CGF.VoidTy, ParamTypes, false);
+  Prefetch = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch");
+
+  // declare i64 @popcorn_prefetch_execute()
+  ParamTypes.clear();
+  FnType = llvm::FunctionType::get(CGF.Int64Ty, ParamTypes, false);
+  Execute = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch_execute");
+}
+
+static llvm::Constant *getPrefetchKind(CodeGen::CodeGenFunction &CGF,
+                                       enum PrefetchRange::Type Perm) {
+  llvm::Type *Ty = llvm::Type::getInt32Ty(CGF.CurFn->getContext());
+  switch(Perm) {
+  case PrefetchRange::Read: return llvm::ConstantInt::get(Ty, 0);
+  case PrefetchRange::Write: return llvm::ConstantInt::get(Ty, 1);
+  default: llvm_unreachable("Invalid prefetch type\n"); return nullptr;
+  }
+}
+
+Expr *PrefetchBuilder::buildArrayIndexAddress(VarDecl *Base, Expr *Subscript) {
+  // Build DeclRefExpr for variable representing base
+  QualType Ty = Base->getType(), ElemTy;
+  DeclRefExpr *DRE = DeclRefExpr::Create(Ctx, NestedNameSpecifierLoc(),
+                                         SourceLocation(), Base, false,
+                                         Base->getSourceRange().getBegin(),
+                                         Ty, VK_LValue);
+
+  // Get an array subscript, e.g., arr[idx]
+  Ty = Ty.getDesugaredType(Ctx);
+  if(isa<ArrayType>(Ty)) ElemTy = cast<ArrayType>(ElemTy)->getElementType();
+  else ElemTy = cast<PointerType>(Ty)->getPointeeType();
+  Expr *Subscr = new (Ctx) ArraySubscriptExpr(DRE, Subscript, ElemTy, VK_RValue,
+                                              OK_Ordinary, SourceLocation());
+
+  // Get the address of the array index, e.g., &arr[idx]
+  QualType RePtrTy = Ctx.getPointerType(ElemTy);
+  UnaryOperator *Addr = new (Ctx) UnaryOperator(Subscr, UO_AddrOf, RePtrTy,
+                                                VK_LValue, OK_Ordinary,
+                                                SourceLocation());
+
+  // Finally, cast it to a void *, e.g., (void *)&arr[idx]
+  QualType VoidPtrTy = Ctx.getPointerType(Ctx.VoidTy.withConst());
+  return ImplicitCastExpr::Create(Ctx, VoidPtrTy, CK_BitCast, Addr, nullptr,
+                                  VK_RValue);
+}
+
+void PrefetchBuilder::EmitPrefetchCall(const PrefetchRange &P) {
+  Expr *StartAddr, *EndAddr;
+  CodeGen::RValue LoweredStart, LoweredEnd;
+  std::vector<llvm::Value *> Params;
+
+  StartAddr = buildArrayIndexAddress(P.getArray(), P.getStart());
+  EndAddr = buildArrayIndexAddress(P.getArray(), P.getEnd());
+  LoweredStart = CGF.EmitAnyExpr(StartAddr);
+  LoweredEnd = CGF.EmitAnyExpr(EndAddr);
+  Params = { getPrefetchKind(CGF, P.getType()),
+             LoweredStart.getScalarVal(),
+             LoweredEnd.getScalarVal() };
+  CGF.EmitCallOrInvoke(Prefetch, Params);
+}
+
+void PrefetchBuilder::EmitPrefetchExecuteCall() {
+  std::vector<llvm::Value *> Params;
+  CGF.EmitCallOrInvoke(Execute, Params);
+}
+
Index: lib/Driver/Tools.cpp
===================================================================
--- lib/Driver/Tools.cpp	(revision 320332)
+++ lib/Driver/Tools.cpp	(working copy)
@@ -4934,6 +4934,49 @@
       A->render(Args, CmdArgs);
   }
 
+  // Forward Popcorn & other standard compiler flags to -cc1 to generate
+  // multi-ISA binaries
+  if(Args.hasArg(options::OPT_popcorn_migratable) ||
+     Args.hasArg(options::OPT_popcorn_metadata)) {
+    // Full-blown Popcorn migration capabilities, including adding migration
+    // points, symbol alignment and generating stack transformation metadata
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+    CmdArgs.push_back("-popcorn-migratable");
+    CmdArgs.push_back("-mllvm");
+    if(Args.hasArg(options::OPT_popcorn_migratable))
+      CmdArgs.push_back("-popcorn-instrument=migration");
+    else
+      CmdArgs.push_back("-popcorn-instrument=metadata");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-optimize-regalloc");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-fast-isel=false");
+    for(auto Target : Args.getAllArgValues(options::OPT_popcorn_target)) {
+      std::string combined("-popcorn-target=" + Target);
+      CmdArgs.push_back(Args.MakeArgString(combined));
+    }
+  }
+  else if(Args.hasArg(options::OPT_popcorn_libc)) {
+    // Symbol alignment for libc & generate stack transformation metadata for
+    // libc thread start functions
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-popcorn-instrument=libc");
+  }
+  else if(Args.hasArg(options::OPT_popcorn_alignment)) {
+    // Only symbol alignment
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+  }
+
+  if(Args.hasArg(options::OPT_distributed_omp))
+    CmdArgs.push_back("-distributed-omp");
+
   // With -save-temps, we want to save the unoptimized bitcode output from the
   // CompileJobAction, so disable optimizations if they are not already
   // disabled.
Index: lib/Frontend/CompilerInvocation.cpp
===================================================================
--- lib/Frontend/CompilerInvocation.cpp	(revision 320332)
+++ lib/Frontend/CompilerInvocation.cpp	(working copy)
@@ -358,22 +358,11 @@
 
 static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
                              DiagnosticsEngine &Diags,
-                             const TargetOptions &TargetOpts) {
+                             const TargetOptions &TargetOpts,
+                             unsigned OptimizationLevel) {
   using namespace options;
   bool Success = true;
 
-  unsigned OptimizationLevel = getOptimizationLevel(Args, IK, Diags);
-  // TODO: This could be done in Driver
-  unsigned MaxOptLevel = 3;
-  if (OptimizationLevel > MaxOptLevel) {
-    // If the optimization level is not supported, fall back on the default
-    // optimization
-    Diags.Report(diag::warn_drv_optimization_value)
-        << Args.getLastArg(OPT_O)->getAsString(Args) << "-O" << MaxOptLevel;
-    OptimizationLevel = MaxOptLevel;
-  }
-  Opts.OptimizationLevel = OptimizationLevel;
-
   // We must always run at least the always inlining pass.
   Opts.setInlining(
     (Opts.OptimizationLevel > 1) ? CodeGenOptions::NormalInlining
@@ -675,9 +664,41 @@
   Opts.CudaGpuBinaryFileNames =
       Args.getAllArgValues(OPT_fcuda_include_gpubinary);
 
+  Opts.PopcornAlignment = Args.hasArg(OPT_popcorn_alignment);
+  Opts.PopcornMigratable = Args.hasArg(OPT_popcorn_migratable);
+
+  // TODO: the Popcorn compiler doesn't currently support vectorization
+  if(Opts.PopcornMigratable || Args.hasArg(OPT_popcorn_libc)) {
+    Opts.VectorizeBB = 0;
+    Opts.VectorizeLoop = 0;
+    Opts.VectorizeSLP = 0;
+  }
+
+  if(Opts.PopcornMigratable)
+    for(auto Target : Args.getAllArgValues(OPT_popcorn_target))
+      Opts.PopcornTargets.push_back(Target);
+
   return Success;
 }
 
+static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
+                             DiagnosticsEngine &Diags,
+                             const TargetOptions &TargetOpts) {
+  unsigned OptimizationLevel = getOptimizationLevel(Args, IK, Diags);
+  // TODO: This could be done in Driver
+  unsigned MaxOptLevel = 3;
+  if (OptimizationLevel > MaxOptLevel) {
+    // If the optimization level is not supported, fall back on the default
+    // optimization
+    Diags.Report(diag::warn_drv_optimization_value)
+        << Args.getLastArg(OPT_O)->getAsString(Args) << "-O" << MaxOptLevel;
+    OptimizationLevel = MaxOptLevel;
+  }
+  Opts.OptimizationLevel = OptimizationLevel;
+  return ParseCodeGenArgs(Opts, Args, IK, Diags, TargetOpts,
+                          OptimizationLevel);
+}
+
 static void ParseDependencyOutputArgs(DependencyOutputOptions &Opts,
                                       ArgList &Args) {
   using namespace options;
@@ -856,7 +877,11 @@
     case OPT_emit_codegen_only:
       Opts.ProgramAction = frontend::EmitCodeGenOnly; break;
     case OPT_emit_obj:
-      Opts.ProgramAction = frontend::EmitObj; break;
+      if(Args.hasArg(OPT_popcorn_migratable))
+        Opts.ProgramAction = frontend::EmitMultiObj;
+      else
+        Opts.ProgramAction = frontend::EmitObj;
+      break;
     case OPT_fixit_EQ:
       Opts.FixItSuffix = A->getValue();
       // fall-through!
@@ -1704,6 +1729,8 @@
   Opts.SanitizeAddressFieldPadding =
       getLastArgIntValue(Args, OPT_fsanitize_address_field_padding, 0, Diags);
   Opts.SanitizerBlacklistFiles = Args.getAllArgValues(OPT_fsanitize_blacklist);
+
+  Opts.DistributedOmp = Args.hasArg(OPT_distributed_omp);
 }
 
 static void ParsePreprocessorArgs(PreprocessorOptions &Opts, ArgList &Args,
@@ -1803,6 +1830,7 @@
   case frontend::EmitLLVMOnly:
   case frontend::EmitCodeGenOnly:
   case frontend::EmitObj:
+  case frontend::EmitMultiObj:
   case frontend::FixIt:
   case frontend::GenerateModule:
   case frontend::GeneratePCH:
@@ -1890,6 +1918,11 @@
   ParseTargetArgs(Res.getTargetOpts(), Args);
   Success &= ParseCodeGenArgs(Res.getCodeGenOpts(), Args, DashX, Diags,
                               Res.getTargetOpts());
+  // TODO Popcorn: until we can limit optimizations across migration points, we
+  // need to turn off backend optimizations
+  if(Args.hasArg(OPT_popcorn_migratable))
+    Success &= ParseCodeGenArgs(Res.getCodeGenNoOpts(), Args, DashX, Diags,
+                                Res.getTargetOpts(), 0);
   ParseHeaderSearchArgs(Res.getHeaderSearchOpts(), Args);
   if (DashX != IK_AST && DashX != IK_LLVM_IR) {
     ParseLangArgs(*Res.getLangOpts(), Args, DashX, Diags);
Index: lib/FrontendTool/ExecuteCompilerInvocation.cpp
===================================================================
--- lib/FrontendTool/ExecuteCompilerInvocation.cpp	(revision 320332)
+++ lib/FrontendTool/ExecuteCompilerInvocation.cpp	(working copy)
@@ -50,6 +50,7 @@
   case EmitLLVMOnly:           return new EmitLLVMOnlyAction();
   case EmitCodeGenOnly:        return new EmitCodeGenOnlyAction();
   case EmitObj:                return new EmitObjAction();
+  case EmitMultiObj:           return new EmitMultiObjAction();
   case FixIt:                  return new FixItAction();
   case GenerateModule:         return new GenerateModuleAction;
   case GeneratePCH:            return new GeneratePCHAction;
Index: lib/Parse/ParseOpenMP.cpp
===================================================================
--- lib/Parse/ParseOpenMP.cpp	(revision 320332)
+++ lib/Parse/ParseOpenMP.cpp	(working copy)
@@ -14,6 +14,7 @@
 #include "RAIIObjectsForParser.h"
 #include "clang/AST/ASTConsumer.h"
 #include "clang/AST/ASTContext.h"
+#include "clang/AST/RecursiveASTVisitor.h"
 #include "clang/AST/StmtOpenMP.h"
 #include "clang/Parse/ParseDiagnostic.h"
 #include "clang/Parse/Parser.h"
@@ -25,6 +26,82 @@
 // OpenMP declarative directives.
 //===----------------------------------------------------------------------===//
 
+/// \brief Helper class to find variables declared or used in a statement's
+/// sub-tree.
+class VarFinder : public RecursiveASTVisitor<VarFinder> {
+public:
+  void reset() { Variables.clear(); }
+
+  bool VisitDeclRefExpr(DeclRefExpr *D) {
+    ValueDecl *VD = D->getDecl();
+    if(isa<VarDecl>(VD)) Variables.insert(cast<VarDecl>(VD));
+    return true;
+  }
+
+  bool VisitVarDecl(VarDecl *D) { Variables.insert(D); return true; }
+
+  const llvm::SmallPtrSet<const VarDecl *, 2> &
+  getDeclaredOrReferencedVars() const { return Variables; }
+
+private:
+  llvm::SmallPtrSet<const VarDecl *, 2> Variables;
+};
+
+void Parser::CheckOpenMPPrefetchClauses(StmtResult Directive) {
+  VarFinder CapturedVarFinder, LoopVarFinder, UseFinder;
+
+  OMPLoopDirective *D = dyn_cast<OMPLoopDirective>(Directive.get());
+  if(D) {
+    // OpenMP Standard 4.5, Section 2.6:
+    // A loop has canonical loop form if it conforms to the following:
+    //    for (init-expr; test-expr; incr-expr) structured-block
+    //      init-expr     One of the following:
+    //                    var = lb
+    //                    integer-type var = lb
+    //                    random-access-iterator-type var = lb
+    //                    pointer-type var = lb
+    //
+    // Thus we can examine the initialization statement to find the loop
+    // iteration variable.
+    CapturedStmt *Captured = cast<CapturedStmt>(D->getAssociatedStmt());
+    ForStmt *For = cast<ForStmt>(Captured->getCapturedStmt());
+    BinaryOperator *InitExpr = cast<BinaryOperator>(For->getInit());
+
+    // Find captured & loop iteration variables
+    CapturedVarFinder.TraverseStmt(Captured);
+    const llvm::SmallPtrSet<const VarDecl *, 2> &CapturedVars =
+      CapturedVarFinder.getDeclaredOrReferencedVars();
+    LoopVarFinder.TraverseStmt(InitExpr);
+    const llvm::SmallPtrSet<const VarDecl *, 2> &LoopVars =
+      LoopVarFinder.getDeclaredOrReferencedVars();
+
+    for(auto &&I = D->getClausesOfKind(OMPC_prefetch); I; ++I) {
+      auto *C = cast<OMPPrefetchClause>(*I);
+
+      // Verify we're only prefetching captured variables
+      for(auto E : C->varlists()) {
+        UseFinder.reset();
+        // TODO this cast is nasty
+        UseFinder.TraverseStmt((Expr *)E);
+        for(const auto &V : UseFinder.getDeclaredOrReferencedVars())
+          if(!CapturedVars.count(V))
+            Diag(E->getExprLoc(), diag::err_omp_invalid_prefetch_capture);
+      }
+
+      // Verify loop iteration variable use
+      Expr *Start = C->getStartOfRange(), *End = C->getEndOfRange();
+      if(Start && !End) {
+        UseFinder.reset();
+        UseFinder.TraverseStmt(Start);
+
+        for(const auto &V : UseFinder.getDeclaredOrReferencedVars())
+          if(!LoopVars.count(V)) Diag(C->getFirstColonLoc(),
+                                      diag::err_omp_invalid_prefetch_loop_var);
+      }
+    }
+  }
+}
+
 static OpenMPDirectiveKind ParseOpenMPDirectiveKind(Parser &P) {
   // Array of foldings: F[i][0] F[i][1] ===> F[i][2].
   // E.g.: OMPD_for OMPD_simd ===> OMPD_for_simd
@@ -294,6 +371,21 @@
           DKind, DirName, CancelRegion, Clauses, AssociatedStmt.get(), Loc,
           EndLoc);
 
+    // Enable optimizations for Popcorn Linux, if requested.
+    if(PP.getLangOpts().DistributedOmp) {
+      if((DKind == OMPD_parallel || DKind == OMPD_parallel_for ||
+          DKind == OMPD_parallel_for_simd || DKind == OMPD_parallel_sections)) {
+        CapturedStmt *CS = cast<CapturedStmt>(AssociatedStmt.get());
+        CS->setOffloadShared(true);
+      }
+
+      if(DKind == OMPD_for || DKind == OMPD_parallel_for ||
+         DKind == OMPD_parallel_for_simd) {
+        cast<OMPExecutableDirective>(Directive.get())->setPrefetching(true);
+        CheckOpenMPPrefetchClauses(Directive);
+      }
+    }
+
     // Exit scope.
     Actions.EndOpenMPDSABlock(Directive.get());
     OMPDirectiveScope.Exit();
@@ -385,7 +477,7 @@
 ///       lastprivate-clause | reduction-clause | proc_bind-clause |
 ///       schedule-clause | copyin-clause | copyprivate-clause | untied-clause |
 ///       mergeable-clause | flush-clause | read-clause | write-clause |
-///       update-clause | capture-clause | seq_cst-clause
+///       update-clause | capture-clause | seq_cst-clause | prefetch-clause
 ///
 OMPClause *Parser::ParseOpenMPClause(OpenMPDirectiveKind DKind,
                                      OpenMPClauseKind CKind, bool FirstClause) {
@@ -479,6 +571,7 @@
   case OMPC_copyprivate:
   case OMPC_flush:
   case OMPC_depend:
+  case OMPC_prefetch:
     Clause = ParseOpenMPVarListClause(CKind);
     break;
   case OMPC_unknown:
@@ -702,17 +795,20 @@
 ///       'flush' '(' list ')'
 ///    depend-clause:
 ///       'depend' '(' in | out | inout : list ')'
+///    prefetch-clause:
+///       'prefetch' '(' read | write ':' list [ ':' start ':' end ] ')'
 ///
 OMPClause *Parser::ParseOpenMPVarListClause(OpenMPClauseKind Kind) {
   SourceLocation Loc = Tok.getLocation();
   SourceLocation LOpen = ConsumeToken();
-  SourceLocation ColonLoc = SourceLocation();
+  SourceLocation ColonLoc = SourceLocation(), EndColonLoc = SourceLocation();
   // Optional scope specifier and unqualified id for reduction identifier.
   CXXScopeSpec ReductionIdScopeSpec;
   UnqualifiedId ReductionId;
   bool InvalidReductionId = false;
   OpenMPDependClauseKind DepKind = OMPC_DEPEND_unknown;
-  SourceLocation DepLoc;
+  OpenMPPrefetchClauseKind PrefKind = OMPC_PREFETCH_unknown;
+  SourceLocation DepLoc, PrefLoc;
 
   // Parse '('.
   BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
@@ -755,6 +851,20 @@
     } else {
       Diag(Tok, diag::warn_pragma_expected_colon) << "dependency type";
     }
+  } else if (Kind == OMPC_prefetch) {
+  // Handle permission type for prefetch clause.
+    ColonProtectionRAIIObject ColonRAII(*this);
+    PrefKind = static_cast<OpenMPPrefetchClauseKind>(getOpenMPSimpleClauseType(
+        Kind, Tok.is(tok::identifier) ? PP.getSpelling(Tok) : ""));
+    PrefLoc = Tok.getLocation();
+
+    if (PrefKind == OMPC_PREFETCH_unknown) {
+      SkipUntil(tok::r_paren, tok::annot_pragma_openmp_end, StopBeforeMatch);
+      Diag(PrefLoc, diag::err_omp_invalid_prefetch_kind) << true;
+    } else {
+      ConsumeToken(); // Keyword
+      ConsumeToken(); // Colon
+    }
   }
 
   SmallVector<Expr *, 5> Vars;
@@ -761,7 +871,8 @@
   bool IsComma = ((Kind != OMPC_reduction) && (Kind != OMPC_depend)) ||
                  ((Kind == OMPC_reduction) && !InvalidReductionId) ||
                  ((Kind == OMPC_depend) && DepKind != OMPC_DEPEND_unknown);
-  const bool MayHaveTail = (Kind == OMPC_linear || Kind == OMPC_aligned);
+  const bool MayHaveTail = (Kind == OMPC_linear || Kind == OMPC_aligned ||
+                            Kind == OMPC_prefetch);
   while (IsComma || (Tok.isNot(tok::r_paren) && Tok.isNot(tok::colon) &&
                      Tok.isNot(tok::annot_pragma_openmp_end))) {
     ColonProtectionRAIIObject ColonRAII(*this, MayHaveTail);
@@ -787,9 +898,9 @@
           << (Kind == OMPC_flush);
   }
 
-  // Parse ':' linear-step (or ':' alignment).
+  // Parse ':' linear-step, ':' alignment, or ':' start.
   Expr *TailExpr = nullptr;
-  const bool MustHaveTail = MayHaveTail && Tok.is(tok::colon);
+  const bool MustHaveTail = (MayHaveTail && Tok.is(tok::colon));
   if (MustHaveTail) {
     ColonLoc = Tok.getLocation();
     ConsumeToken();
@@ -802,6 +913,20 @@
                 StopBeforeMatch);
   }
 
+  // Parse ':' end.
+  Expr *EndExpr = nullptr;
+  if (Kind == OMPC_prefetch && Tok.is(tok::colon)) {
+    EndColonLoc = Tok.getLocation();
+    ConsumeToken();
+    ExprResult Tail =
+        Actions.CorrectDelayedTyposInExpr(ParseAssignmentExpression());
+    if (Tail.isUsable())
+      EndExpr = Tail.get();
+    else
+      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                StopBeforeMatch);
+  }
+
   // Parse ')'.
   T.consumeClose();
   if ((Kind == OMPC_depend && DepKind != OMPC_DEPEND_unknown && Vars.empty()) ||
@@ -810,10 +935,10 @@
     return nullptr;
 
   return Actions.ActOnOpenMPVarListClause(
-      Kind, Vars, TailExpr, Loc, LOpen, ColonLoc, Tok.getLocation(),
-      ReductionIdScopeSpec,
+      Kind, Vars, TailExpr, EndExpr, Loc, LOpen, ColonLoc, EndColonLoc,
+      Tok.getLocation(), ReductionIdScopeSpec,
       ReductionId.isValid() ? Actions.GetNameFromUnqualifiedId(ReductionId)
                             : DeclarationNameInfo(),
-      DepKind, DepLoc);
+      DepKind, DepLoc, PrefKind, PrefLoc);
 }
 
Index: lib/Parse/ParsePragma.cpp
===================================================================
--- lib/Parse/ParsePragma.cpp	(revision 320332)
+++ lib/Parse/ParsePragma.cpp	(working copy)
@@ -156,6 +156,23 @@
                     Token &FirstToken) override;
 };
 
+struct PragmaNoPopcornHandler: public PragmaHandler {
+  PragmaNoPopcornHandler() : PragmaHandler("popcorn") {}
+  void HandlePragma(Preprocessor &PP,  PragmaIntroducerKind Introducer,
+                    Token &FirstToken) override;
+};
+
+struct PragmaPopcornHandler : public PragmaHandler {
+  enum Type {
+    Prefetch, // Prefetch for the statement following the pragma
+    None      // Unknown pragma type
+  };
+
+  PragmaPopcornHandler() : PragmaHandler("popcorn") {}
+  void HandlePragma(Preprocessor &PP, PragmaIntroducerKind Introducer,
+                    Token &FirstToken) override;
+};
+
 }  // end namespace
 
 void Parser::initializePragmaHandlers() {
@@ -235,6 +252,12 @@
 
   NoUnrollHintHandler.reset(new PragmaUnrollHintHandler("nounroll"));
   PP.AddPragmaHandler(NoUnrollHintHandler.get());
+
+  if (getLangOpts().DistributedOmp)
+    PopcornHandler.reset(new PragmaPopcornHandler());
+  else
+    PopcornHandler.reset(new PragmaNoPopcornHandler());
+  PP.AddPragmaHandler(PopcornHandler.get());
 }
 
 void Parser::resetPragmaHandlers() {
@@ -304,6 +327,9 @@
 
   PP.RemovePragmaHandler(NoUnrollHintHandler.get());
   NoUnrollHintHandler.reset();
+
+  PP.RemovePragmaHandler(PopcornHandler.get());
+  PopcornHandler.reset();
 }
 
 /// \brief Handle the annotation token produced for #pragma unused(...)
@@ -868,6 +894,32 @@
   return true;
 }
 
+StmtResult Parser::HandlePragmaPopcorn() {
+  assert(Tok.is(tok::annot_pragma_popcorn_prefetch));
+  ConsumeToken(); // The annotation token.
+
+  while (Tok.isNot(tok::annot_pragma_popcorn_prefetch_end)) {
+    // TODO handle clauses
+    ConsumeToken();
+  }
+  ConsumeToken(); // Consume final token.
+
+  StmtResult R = ParseStatement();
+
+  if (R.isInvalid()) return StmtError();
+  else if (isa<ForStmt>(R.get())) {
+    ForStmt *S = cast<ForStmt>(R.get());
+    S->setPrefetchEnabled(true);
+    PrefetchAnalysis PA(R.get());
+    PA.analyzeStmt();
+    getActions().getASTContext().addPrefetchAnalysis(R.get(), PA);
+  }
+  else PP.Diag(R.get()->getLocStart(),
+               diag::warn_pragma_popcorn_prefetch_invalid_stmt);
+
+  return R;
+}
+
 // #pragma GCC visibility comes in two variants:
 //   'push' '(' [visibility] ')'
 //   'pop'
@@ -1458,10 +1510,10 @@
 PragmaNoOpenMPHandler::HandlePragma(Preprocessor &PP,
                                     PragmaIntroducerKind Introducer,
                                     Token &FirstTok) {
-  if (!PP.getDiagnostics().isIgnored(diag::warn_pragma_omp_ignored,
+  if (!PP.getDiagnostics().isIgnored(diag::warn_pragma_popcorn_ignored,
                                      FirstTok.getLocation())) {
-    PP.Diag(FirstTok, diag::warn_pragma_omp_ignored);
-    PP.getDiagnostics().setSeverity(diag::warn_pragma_omp_ignored,
+    PP.Diag(FirstTok, diag::warn_pragma_popcorn_ignored);
+    PP.getDiagnostics().setSeverity(diag::warn_pragma_popcorn_ignored,
                                     diag::Severity::Ignored, SourceLocation());
   }
   PP.DiscardUntilEndOfDirective();
@@ -2119,3 +2171,66 @@
   PP.EnterTokenStream(TokenArray, 1, /*DisableMacroExpansion=*/false,
                       /*OwnsTokens=*/true);
 }
+
+void PragmaNoPopcornHandler::HandlePragma(Preprocessor &PP,
+                                          PragmaIntroducerKind Introducer,
+                                          Token &Tok) {
+  if (!PP.getDiagnostics().isIgnored(diag::warn_pragma_omp_ignored,
+                                     Tok.getLocation())) {
+    PP.Diag(Tok, diag::warn_pragma_omp_ignored);
+    PP.getDiagnostics().setSeverity(diag::warn_pragma_omp_ignored,
+                                    diag::Severity::Ignored, SourceLocation());
+  }
+  PP.DiscardUntilEndOfDirective();
+}
+
+void PragmaPopcornHandler::HandlePragma(Preprocessor &PP,
+                                        PragmaIntroducerKind Introducer,
+                                        Token &Tok) {
+  // Incoming token is "popcorn" for "#pragma popcorn".
+  PP.Lex(Tok);
+  if (Tok.isNot(tok::identifier)) {
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_popcorn_no_arg);
+    return;
+  }
+
+  IdentifierInfo *OptionInfo = Tok.getIdentifierInfo();
+  enum PragmaPopcornHandler::Type Ty =
+    llvm::StringSwitch<enum PragmaPopcornHandler::Type>(OptionInfo->getName())
+                             .Case("prefetch", PragmaPopcornHandler::Prefetch)
+                             .Default(PragmaPopcornHandler::None);
+  if (Ty == PragmaPopcornHandler::None) {
+    PP.Diag(Tok.getLocation(), diag::warn_pragma_popcorn_invalid_option)
+        << OptionInfo->getName();
+    return;
+  }
+
+  switch(Ty) {
+  default: llvm_unreachable("Should have weeded out invalid types"); break;
+  case PragmaPopcornHandler::Prefetch: {
+    // Capture all tokens to be included for prefetching analysis.
+    SmallVector<Token, 16> Pragma;
+    Token NextTok;
+
+    NextTok.startToken();
+    NextTok.setKind(tok::annot_pragma_popcorn_prefetch);
+    NextTok.setLocation(Tok.getLocation());
+    while (NextTok.isNot(tok::eod)) {
+      Pragma.push_back(NextTok);
+      PP.Lex(NextTok);
+    }
+    SourceLocation EodLoc = NextTok.getLocation();
+    NextTok.startToken();
+    NextTok.setKind(tok::annot_pragma_popcorn_prefetch_end);
+    NextTok.setLocation(EodLoc);
+    Pragma.push_back(NextTok);
+  
+    Token *Toks = new Token[Pragma.size()];
+    std::copy(Pragma.begin(), Pragma.end(), Toks);
+    PP.EnterTokenStream(Toks, Pragma.size(),
+                        /*DisableMacroExpansion=*/false, /*OwnsTokens=*/true);
+    break;
+  }
+  }
+}
+
Index: lib/Parse/ParseStmt.cpp
===================================================================
--- lib/Parse/ParseStmt.cpp	(revision 320332)
+++ lib/Parse/ParseStmt.cpp	(working copy)
@@ -357,6 +357,9 @@
   case tok::annot_pragma_loop_hint:
     ProhibitAttributes(Attrs);
     return ParsePragmaLoopHint(Stmts, OnlyStatement, TrailingElseLoc, Attrs);
+
+  case tok::annot_pragma_popcorn_prefetch:
+    return HandlePragmaPopcorn();
   }
 
   // If we reached this code, the statement must end in a semicolon.
Index: lib/Parse/Parser.cpp
===================================================================
--- lib/Parse/Parser.cpp	(revision 320332)
+++ lib/Parse/Parser.cpp	(working copy)
@@ -282,6 +282,7 @@
       // Ran out of tokens.
       return false;
 
+    case tok::annot_pragma_popcorn_prefetch_end:
     case tok::annot_pragma_openmp_end:
       // Stop before an OpenMP pragma boundary.
     case tok::annot_module_begin:
Index: lib/Sema/SemaOpenMP.cpp
===================================================================
--- lib/Sema/SemaOpenMP.cpp	(revision 320332)
+++ lib/Sema/SemaOpenMP.cpp	(working copy)
@@ -4616,6 +4616,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -4831,6 +4832,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -4952,6 +4954,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -5075,6 +5078,7 @@
   case OMPC_flush:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -5129,10 +5133,12 @@
 
 OMPClause *Sema::ActOnOpenMPVarListClause(
     OpenMPClauseKind Kind, ArrayRef<Expr *> VarList, Expr *TailExpr,
-    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation ColonLoc,
+    Expr *EndExpr, SourceLocation StartLoc, SourceLocation LParenLoc,
+    SourceLocation ColonLoc, SourceLocation EndColonLoc,
     SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,
     const DeclarationNameInfo &ReductionId, OpenMPDependClauseKind DepKind,
-    SourceLocation DepLoc) {
+    SourceLocation DepLoc, OpenMPPrefetchClauseKind PrefKind,
+    SourceLocation PrefLoc) {
   OMPClause *Res = nullptr;
   switch (Kind) {
   case OMPC_private:
@@ -5172,6 +5178,11 @@
     Res = ActOnOpenMPDependClause(DepKind, DepLoc, ColonLoc, VarList, StartLoc,
                                   LParenLoc, EndLoc);
     break;
+  case OMPC_prefetch:
+    Res = ActOnOpenMPPrefetchClause(PrefKind, PrefLoc, VarList, TailExpr,
+                                    EndExpr, StartLoc, LParenLoc, ColonLoc,
+                                    EndColonLoc, EndLoc);
+    break;
   case OMPC_if:
   case OMPC_final:
   case OMPC_num_threads:
@@ -6785,3 +6796,58 @@
                                  DepLoc, ColonLoc, Vars);
 }
 
+OMPClause *
+Sema::ActOnOpenMPPrefetchClause(OpenMPPrefetchClauseKind PrefKind,
+                                SourceLocation PrefLoc,
+                                ArrayRef<Expr *> VarList,
+                                Expr *Start, Expr *End,
+                                SourceLocation StartLoc,
+                                SourceLocation LParenLoc,
+                                SourceLocation FirstColonLoc,
+                                SourceLocation SecondColonLoc,
+                                SourceLocation EndLoc) {
+  // Check validity of range expressions & variables which use them
+  if(Start) {
+    if(!Start->getType()->isIntegerType()) {
+      Diag(Start->getExprLoc(), diag::err_omp_invalid_prefetch_range_type);
+      return nullptr;
+    }
+
+    if(End) {
+      if(!End->getType()->isIntegerType()) {
+        Diag(End->getExprLoc(), diag::err_omp_invalid_prefetch_range_type);
+        return nullptr;
+      }
+    }
+
+    for(const auto &Var : VarList) {
+      QualType T = Var->getType();
+
+      if(!T->isArrayType() && !T->isPointerType()) {
+        Diag(Var->getExprLoc(), diag::err_omp_invalid_prefetch_var_type)
+          << "array or pointer";
+        return nullptr;
+      }
+    }
+  }
+  else {
+    for(const auto &Var : VarList) {
+      // Note: array types with known sizes may be decayed to pointer types.
+      // We want the original type (i.e., the array type) but we can't simply
+      // call T.getDesugaredType() as it will return the pointer type.
+      QualType T = Var->getType();
+      while(isa<DecayedType>(T)) T = cast<DecayedType>(T)->getOriginalType();
+
+      if(!T->isConstantArrayType()) {
+        Diag(Var->getExprLoc(), diag::err_omp_invalid_prefetch_var_type)
+          << "constant-sized array";
+        return nullptr;
+      }
+    }
+  }
+
+  return OMPPrefetchClause::Create(Context, PrefKind, PrefLoc, VarList, Start,
+                                   End, StartLoc, LParenLoc, FirstColonLoc,
+                                   SecondColonLoc, EndLoc);
+}
+
Index: lib/Sema/TreeTransform.h
===================================================================
--- lib/Sema/TreeTransform.h	(revision 320332)
+++ lib/Sema/TreeTransform.h	(working copy)
@@ -7469,6 +7469,14 @@
       C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
 }
 
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implmented");
+  return C;
+}
+
 //===----------------------------------------------------------------------===//
 // Expression transformation
 //===----------------------------------------------------------------------===//
Index: lib/Serialization/ASTReaderStmt.cpp
===================================================================
--- lib/Serialization/ASTReaderStmt.cpp	(revision 320332)
+++ lib/Serialization/ASTReaderStmt.cpp	(working copy)
@@ -2065,6 +2065,11 @@
   C->setVarRefs(Vars);
 }
 
+void OMPClauseReader::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
+}
+
 //===----------------------------------------------------------------------===//
 // OpenMP Directives.
 //===----------------------------------------------------------------------===//
Index: lib/Serialization/ASTWriterStmt.cpp
===================================================================
--- lib/Serialization/ASTWriterStmt.cpp	(revision 320332)
+++ lib/Serialization/ASTWriterStmt.cpp	(working copy)
@@ -1916,6 +1916,11 @@
     Writer->Writer.AddStmt(VE);
 }
 
+void OMPClauseWriter::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
+}
+
 //===----------------------------------------------------------------------===//
 // OpenMP Directives.
 //===----------------------------------------------------------------------===//
Index: tools/libclang/CIndex.cpp
===================================================================
--- tools/libclang/CIndex.cpp	(revision 320332)
+++ tools/libclang/CIndex.cpp	(working copy)
@@ -2147,7 +2147,11 @@
 void OMPClauseEnqueue::VisitOMPDependClause(const OMPDependClause *C) {
   VisitOMPClauseList(C);
 }
+void OMPClauseEnqueue::VisitOMPPrefetchClause(const OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
 }
+}
 
 void EnqueueVisitor::EnqueueChildren(const OMPClause *S) {
   unsigned size = WL.size();

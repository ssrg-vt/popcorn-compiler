//===----- llvm/Target/TargetValues.h - Value Properties ----*- C++ -----*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file provides an API for detecting properties of architecture-specific
// values & for generating a series of simple metadata instructions for
// reconstituting a value.  This is used by the stack transformation runtime to
// set up architecture-specific live values.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TARGET_TARGETVAL_H
#define LLVM_TARGET_TARGETVAL_H

#include <memory>
#include <vector>
#include "llvm/CodeGen/StackTransformTypes.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/VirtRegMap.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/CallSite.h"

namespace llvm {

/// A value created by the backend to satisfy the stackmap.  Note that this is
/// not necessarily an error -- some backends may create and save the value
/// whereas other backends may materialize the value as needed.
struct TemporaryValue {
  enum type {
    StackSlotRef
  };

  enum type Type;
  unsigned Size;

  /// The virtual register used if the temporary is stored in a register
  unsigned Vreg;

  /// If the value is of type StackSlotRef, the stack slot and offset into the
  /// stack slot being referenced
  int StackSlot;
  int64_t Offset;
};

typedef std::unique_ptr<TemporaryValue> TemporaryValuePtr;

//===----------------------------------------------------------------------===//
// Superclass for ISA-specific values
//

class TargetValues {
public:
  TargetValues(const TargetValues &) = delete;
  void operator=(const TargetValues &) = delete;
  virtual ~TargetValues() {};

  /// Get the size in bytes of sub-registers of a register operand, or 0 if the
  /// operand doesn't have sub-registers.
  virtual unsigned getSubRegSize(const MachineOperand &MO) const { return 0; }

  /// Return metadata describing the locations (registers, stack slots) of
  /// arguments marshaled for the given function call.
  virtual void getMarshaledArguments(const ImmutableCallSite &IRCall,
                                     const MachineInstr *MICall,
                                     std::vector<MachineLiveLocPtr> &Locs) const
  { Locs.clear(); }

  /// The code generator may have materialized a temporary value solely to
  /// satisfy the stackmap if the value is materialized as-needed elsewhere.
  /// Return metadata describing the temporary value in this situation.
  virtual TemporaryValuePtr getTemporaryValue(const MachineInstr *MI,
                                              const VirtRegMap *VRM) const
  { return nullptr; }

  /// Return a machine-specific value generated by a machine instruction.
  virtual MachineLiveValPtr getMachineValue(const MachineInstr *MI) const = 0;

  /// Add any required architecture-specific live values, e.g., the TOC pointer
  /// on PowerPC.
  virtual void addRequiredArchLiveValues(MachineFunction *MF,
                                         const MachineInstr *MIStackMap,
                                         const CallInst *IRStackMap) const
  { return; }

  /// Chameleon only: return a message describing any found limitations or
  /// potential randomization issues with the specified instruction.
  virtual bool
  getRandomizeRestrictions(const MachineInstr *MI, std::string &Msg) const
  { return false; }

protected:
  TargetValues() {}

  /// Return whether or not the operand is some type of symbol reference.
  static bool isSymbolValue(const MachineOperand &MO)
  { return MO.isGlobal() || MO.isSymbol() || MO.isMCSymbol(); }
  static bool isSymbolValue(const MachineOperand *MO)
  { return isSymbolValue(*MO); }
  static bool isSymbolValueConstant(const MachineOperand &MO);
  static bool isSymbolValueConstant(const MachineOperand *MO)
  { return isSymbolValueConstant(*MO); }
};

} // End llvm namespace

#endif


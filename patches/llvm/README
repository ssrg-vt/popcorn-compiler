--------
Overview
--------

Both LLVM+clang are patched in order to clean up the build process when
generating multi-ISA binaries.  The clang driver is modified to add the
"-popcorn-migratable" flag, which adds IR-level passes that instrument the
generated binary for migration.  This flag also inserts migration points
(currently at the beginning and end of functions).  The patches add several
middle-end and back-end changes required for stack transformation, as detailed
below.

# TODO compile the IR once for each architecture?

-----------------
Middle-end passes
-----------------

The patches add the following middle-end passes:

-name-string-literals:
This pass gives a symbol name to anonymous literal strings so that the
alignment tool is able to prevent address spaces clashes across architectures.
Normally, anonymous string literals (e.g., printf("I'm a string literal!")) are
dumped into the .rodata section at the linker's discretion, leading to
mis-alignment and garbage pointers across architectures (e.g., a pointer to a
string literal on aarch64 may point to the middle of another string literal on
x86-64).  This pass generates names for them so that the alignment tool can put
the strings in separate areas of virtual memory to avoid clashes.

-static-var-sections:
This pass adjusts the linkage of static global variables to put them in their
own section so that the alignment tool is able to see and properly align them
(by default, LLVM lumps static global variables in with their respective .data,
.rodata, .bss, etc. and the alignment tool can't align them).

-live-values:
This pass runs a live-value analysis over the LLVM IR.  This is used by the
insert-stackmaps pass (see below) to gather all live values at function call
sites, or sites where the stack frame can be transformed.

-insert-stackmaps:
This pass uses results from the live-value analysis to dump the
"llvm.experimental.stackmap" [1] intrinsic into the IR.  This intrinsic tells
LLVM backends to generate stackmaps at the intrinsic's location.  A stackmap
encodes frame information (e.g., size and address within the function) and live
value location information (e.g., a stack slot or a register) for values
post-register allocation.

These passes are runnable from opt, or can be invoked at the clang command line
using the -popcorn-migratable flag.

----------------
Back-end changes
----------------

The modifications to the backend mainly affect how live value location
information is generated by the architecture-specific backends.  In particular,
we modify where and how the "llvm.experimental.stackmap" intrinsic generates
location information for equivalence points in the application's execution.

The "stack-info" middle-end pass runs a liveness analysis over the IR and
inserts stackmap intrinsics containing all live values at all function call
sites.  This intrinsic notifies the LLVM backends to generate the locations of
these live values and place them in a special ELF section named
".llvm_stackmaps".  Most of the backend modifications tailor this additional
section to stack transformation-specific requirements. First, because stackmaps
are an IR-level intrinsic they encode the instruction address and live value
information after the function call procedure has finished *rather* than
directly after the function call returns, e.g., directly after the called
function executes the "ret" instruction on x86-64.  The patch compensates for
this by encoding the exact return address rather than the default location
encoded by the stackmap.  Additionally, backend changes capture extra live
value locations including duplicate locations (a single live value could exist
in multiple locations) and architecture-specific locations.  Finally, the
changes generate extra type metadata needed by the stack transformation runtime
(e.g., is the value a pointer? an alloca? etc.).

Note: these modifications only work for register allocators that work off of
the virtual register allocation mechanisms, meaning that the fast register
allocator (which allocates registers/stack slots directly) is not supported.


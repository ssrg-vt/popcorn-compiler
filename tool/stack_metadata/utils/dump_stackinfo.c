/**
 * Utility for dumping information produced by post-compilation augmentation
 * tool.
 *
 * Author: Rob Lyerly <rlyerly@vt.edu>
 * Date: 1/8/2016
 */

#include <unistd.h>

#include "definitions.h"
#include "bin.h"
#include "stackmap.h"
#include "util.h"
#include "het_bin.h"
#include "StackTransformTypes.def"

///////////////////////////////////////////////////////////////////////////////
// Configuration
///////////////////////////////////////////////////////////////////////////////

static const char *args = "hb:s:";
static const char *help =
"dump-stackinfo - dump information generated by gen-stackinfo\n\n\
\
Usage: ./dump-stackinfo [ OPTIONS ]\n\
Options:\n\
\t-h      : print help & exit\n\
\t-b file : name of post-processed executable\n\
\t-s name : name of section added to objects (default is '.stack_transform')";

static const char *thebin_fn = NULL;
static const char *st_section_name = ".stack_transform";
bool verbose = false;

///////////////////////////////////////////////////////////////////////////////
// Utilities
///////////////////////////////////////////////////////////////////////////////

static void print_help()
{
  printf("%s\n", help);
  exit(0);
}

static void parse_args(int argc, char **argv)
{
  int arg;

  while((arg = getopt(argc, argv, args)) != -1)
  {
    switch(arg)
    {
    case 'h':
      print_help();
      break;
    case 'b':
      thebin_fn = optarg;
      break;
    case 's':
      st_section_name = optarg;
      break;
    default:
      fprintf(stderr, "Unknown argument '%c'\n", arg);
      break;
    }
  }

  if(!thebin_fn)
    die("please specify a binary (run with -h for more information)",
        INVALID_ARGUMENT);
}

///////////////////////////////////////////////////////////////////////////////
// Printing metadata
///////////////////////////////////////////////////////////////////////////////

bool dump_unwind_funcs(Elf_Scn *scn)
{
  uint64_t num_funcs, i;
  Elf_Data *data = NULL;
  GElf_Shdr shdr;
  unwind_addr *funcs;

  if(gelf_getshdr(scn, &shdr) != &shdr) return false;
  if(shdr.sh_size != 0 && shdr.sh_entsize == 0) return false;
  if(!(data = elf_getdata(scn, data))) return false;

  num_funcs = shdr.sh_size / shdr.sh_entsize;
  funcs = (unwind_addr *)data->d_buf;
  printf("found %lu entries\n", num_funcs);
  for(i = 0; i < num_funcs; i++)
    printf("0x%lx: %u records (offset=%u)\n", funcs[i].addr,
           funcs[i].num_unwind, funcs[i].unwind_offset);
  printf("\n");

  return true;
}

bool dump_unwind_locs(Elf_Scn *scn)
{
  uint64_t num_locs, i;
  Elf_Data *data = NULL;
  GElf_Shdr shdr;
  unwind_loc *locs;

  if(gelf_getshdr(scn, &shdr) != &shdr) return false;
  if(shdr.sh_size != 0 && shdr.sh_entsize == 0) return false;
  if(!(data = elf_getdata(scn, data))) return false;

  num_locs = shdr.sh_size / shdr.sh_entsize;
  locs = (unwind_loc *)data->d_buf;
  printf("found %lu entries\n", num_locs);
  for(i = 0; i < num_locs; i++)
    printf("%lu: Register %u at frame pointer + %d\n",
           i, locs[i].reg, locs[i].offset);
  printf("\n");

  return true;
}

bool dump_callsite_section(Elf_Scn *scn)
{
  uint64_t num_sites, i;
  Elf_Data *data = NULL;
  GElf_Shdr shdr;
  call_site *sites;

  if(gelf_getshdr(scn, &shdr) != &shdr) return false;
  if(shdr.sh_size != 0 && shdr.sh_entsize == 0) return false;
  if(!(data = elf_getdata(scn, data))) return false;

  num_sites = shdr.sh_size / shdr.sh_entsize;
  sites = (call_site *)data->d_buf;
  printf("found %lu entries\n", num_sites);
  for(i = 0; i < num_sites; i++)
    printf("%lu: 0x%lx, %u, %u unwind entries (offset=%lu), "
           "%u live value(s) (offset=%lu), "
           "%u arch-specific live value(s) (offset=%lu)\n",
      sites[i].id, sites[i].addr, sites[i].frame_size,
      sites[i].num_unwind, sites[i].unwind_offset,
      sites[i].num_live, sites[i].live_offset,
      sites[i].num_arch_live, sites[i].arch_live_offset);
  printf("\n");

  return true;
}

bool print_loc_record(live_value *record)
{
  switch(record->type) {
  case SM_REGISTER:
    printf("in register %u", record->regnum);
    break;
  case SM_DIRECT:
    printf("at register %u + %d",
          record->regnum, record->offset_or_constant);
    break;
  case SM_INDIRECT:
    printf("at pointer generated by register %u + %d",
          record->regnum, record->offset_or_constant);
    break;
  case SM_CONSTANT:
    printf("%d", record->offset_or_constant);
    break;
  case SM_CONST_IDX:
    printf("in constant pool at index %d",
          record->offset_or_constant);
    break;
  default:
    printf("unknown type %x\n", record->type);
    return false;
  }

  if(record->is_duplicate)
    printf(" (duplicate record)");

  if(record->is_ptr)
    printf(", is a pointer");

  if(record->is_alloca)
    printf(", is an alloca of size %u byte(s)", record->alloca_size);

  if(record->is_temporary)
    printf(", is a stackmap temporary");

  printf("\n");

  return true;
}

bool dump_livelocs_section(Elf_Scn *scn)
{
  uint64_t num_locs, i;
  Elf_Data *data = NULL;
  GElf_Shdr shdr;
  live_value *locs;

  if(gelf_getshdr(scn, &shdr) != &shdr) return false;
  if(shdr.sh_size != 0 && shdr.sh_entsize == 0) return false;
  if(!(data = elf_getdata(scn, data))) return false;

  num_locs = shdr.sh_size / shdr.sh_entsize;
  locs = (live_value *)data->d_buf;
  printf("found %lu entries\n", num_locs);
  for(i = 0; i < num_locs; i++)
  {
    printf("%lu: value is ", i);
    if(!print_loc_record(&locs[i])) return false;
  }
  printf("\n");

  return true;
}

bool print_arch_val_record(arch_live_value *record)
{
  switch(record->type) {
  case SM_REGISTER:
    printf("in register %u", record->regnum);
    break;
  case SM_INDIRECT:
    printf("at pointer generated by register %u + %d",
          record->regnum, record->offset);
    break;
  default:
    printf("unknown type %x\n", record->type);
    return false;
  }

  switch(record->inst_type) {
#define X(name) \
  case name: printf(", " #name " "); break;
VALUE_GEN_INST
#undef X
  default:
    printf(", unknown instruction type %x\n", record->inst_type);
    return false;
  }

  switch(record->operand_type) {
  case SM_REGISTER:
    printf("register %u\n", record->operand_regnum);
    break;
  case SM_DIRECT:
    printf("value stored at register %u + %ld\n", record->operand_regnum,
          record->operand_offset_or_constant);
    break;
  case SM_INDIRECT:
    printf("register %u + %ld\n", record->operand_regnum,
           record->operand_offset_or_constant);
    break;
  case SM_CONSTANT:
    printf("value = %ld / 0x%lx\n", record->operand_offset_or_constant,
          record->operand_offset_or_constant);
    break;
  default:
    printf("unknown operand type %x\n", record->operand_type);
    return false;
  }
  return true;
}

bool dump_archlive_section(Elf_Scn *scn)
{
  uint64_t num_live, i;
  Elf_Data *data = NULL;
  GElf_Shdr shdr;
  arch_live_value *live;

  if(gelf_getshdr(scn, &shdr) != &shdr) return false;
  if(shdr.sh_size != 0 && shdr.sh_entsize == 0) return false;
  if(!(data = elf_getdata(scn, data))) return false;

  num_live = shdr.sh_size / shdr.sh_entsize;
  live = (arch_live_value *)data->d_buf;
  printf("found %lu entries\n", num_live);
  for(i = 0; i < num_live; i++)
  {
    printf("%lu: value is ", i);
    if(!print_arch_val_record(&live[i])) return false;
  }
  printf("\n");

  return true;
}

ret_t dump_metadata(bin *thebin)
{
  char sec_name[BUF_SIZE];
  Elf_Scn *scn;

  /* Function unwinding metadata */
  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_UNWIND_ADDR);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_unwind_funcs(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  /* Register unwinding records */
  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_UNWIND);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_unwind_locs(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  /* Call sites, sorted by ID */
  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_ID);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_callsite_section(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  /* Call sites, sorted by address */
  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_ADDR);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_callsite_section(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  /* Live value location records */
  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_LIVE);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_livelocs_section(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  /* Architecture-specific live value location records */
  snprintf(sec_name, BUF_SIZE, "%s.%s", st_section_name, SECTION_ARCH);
  if((scn = get_section_by_name(thebin->e, sec_name)))
  {
    printf("Reading section %s: ", sec_name);
    if(!dump_archlive_section(scn))
    {
      printf("failed.\n");
      return READ_ELF_FAILED;
    }
  }
  else return FIND_SECTION_FAILED;

  return SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
// Driver
///////////////////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
  ret_t ret;
  bin *thebin = NULL;

  parse_args(argc, argv);

  if(elf_version(EV_CURRENT) == EV_NONE)
    die("could not initialize libELF", INVALID_ELF_VERSION);

  if((ret = init_elf_bin(thebin_fn, &thebin)) != SUCCESS)
    die("could not initialize the binary", ret);

  if((ret = dump_metadata(thebin)) != SUCCESS)
    die("could not read metadata from binary", ret);

  free_elf_bin(thebin);

  return 0;
}


--------
Overview
--------

This folder contains several useful scripts.  These are copied to the
installation folder by the installation script.  You can find more information
about using the scripts by running them with "-h".

1. Generating an LLVM patch

The "gen-compare-llvm-diff.sh" script will generate a patch from the modified
LLVM source.  It checks the patch against the release, and then checks to see
if the generated patch is different from the patch currently in the Popcorn
compiler repository.  If so, it swaps out the old patch with the new (and
retains the old patch).

2. Checking alignment

The "check-align.py" script is useful for sanity checking symbol alignment in
multi-ISA binaries.  This can be useful for detecting when, for instance,
there's clashing symbols or symbols that can't be aligned with linker scripts.
The tool searches through the symbol tables to match symbols by name, and then
compare the virtual addresses at which they are placed.  It returns a non-zero
status when it finds a misalignment.

- To use the tool:

  $ check-align.py bin_aarch64 bin_x86-64

3. Parsing call chain information

If applications are built against the call information library (see
"lib/stack_depth/README" for more information), the library will dump call
statistics to a file ("stack_depth.dat" by default).  The "stack-depth-info.py"
script can be used to parse this file and print human-readable information.

- To use the tool:

  $ stack-depth-info.py -d stack_depth.dat

  This will print basic information including call stack depth, which functions
  were called, and how many times they were called.

- The default references functions by their address.  The script can also use
  the symbol table of the binary to convert function address to names:

  $ stack-depth-info.py -d stack-depth.dat -b <binary name>

- To print detailed call information, use the "-v" switch

4. Testing various points

There are several ways to migrate applications between architectures, depending
on how the migration library was built.  If the library was built with
migration triggering via environment variables (see "lib/migration/INSTALL" for
more information), the user can set a range of PCs at which the migration
library will trigger a migration.  When calling a migration point from within
this range of PCs, the migration library will initiate the procedure.  Rather
than having the user manually set these points, the "test-migration.py" script
can automate the process.  It also provides some functionality for methodically
testing migration at various points -- run the script with "-h" for more
information.

NOTE: the script has no way of knowing where migration points were inserted
into the application.  By default the script will parse the symbol table to
find all functions and will assume migration points were inserted at all of
them.  This is in general not correct, as it will include library functions.
Instead, a correct list of functions can be generated by generating call
information (see 2 above) and running the stack-depth-info.py script with "-f".

